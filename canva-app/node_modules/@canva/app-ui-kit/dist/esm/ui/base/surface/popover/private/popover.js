import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { composeRefs } from '../../../../../base/react/compose_refs';
import classNames from 'classnames';
import * as React from 'react';
import Measure from 'react-measure';
import { CSSTransition } from 'react-transition-group';
import { baseUnit } from '../../../metrics/metrics';
import { useEnableAnimations } from '../../../provider/provider';
import { useStableFunction } from '../../../stable_function/stable_function';
import backgroundStyles from '../../background/background.css';
import { SurfaceHeader } from '../../header/header';
import { ContentContainer } from '../../internal/content_container';
import { resolveTrigger } from '../../internal/trigger';
import { Pin } from '../../pin/pin';
import { Arrow } from './arrow';
import styles, { customProperties } from './popover.css';
const WIDTH_CLASS = {
    ['16u']: styles.width16U,
    ['32u']: styles.width32U,
    ['40u']: styles.width40U,
    ['45u']: styles.width45U,
    ['52u']: styles.width52U,
    ['trigger']: styles.widthReference,
    ['auto']: styles.widthAuto
};
export function Popover(
    { id: idProp, open, onRequestClose, onCloseComplete, onScroll, blockOutsidePointerEvents = false, trigger, placement = 'auto', enableFlip, enableShift, width = 'auto', widthMode = 'fixed', offset = '1u', arrow = false, borderRadius = 'container', background = 'surface', shadow = 'surface', children, title, description, header, headerStart, headerEnd, headerAlignment, headerDivider = 'always', footer, ...contentContainerProps }
) {
    const defaultId = React.useId();
    const id = idProp || defaultId;
    const PinComponent = useEnableAnimations() ? TransitionPin : StaticPin;
    const contentContainerRef = React.useRef(null);
    const contentContainerClassName = classNames(styles.contentContainer, WIDTH_CLASS[width], widthMode === 'maximum' && styles.widthModeMaximum, borderRadius === 'container' && styles.withBorderRadius, background === 'surface' && styles.withBackground, background === 'surface' && backgroundStyles.elevationSurfaceFloatingBackground, shadow === 'surface' && styles.withShadow);
    const onCalculateLayout = React.useCallback((data)=>{
        const element = contentContainerRef.current;
        if (element == null) return;
        element.style.setProperty(customProperties.referenceWidth, `${Math.floor(data.reference.width)}px`);
        element.style.setProperty(customProperties.availableWidth, `${data.available.width}px`);
        element.style.setProperty(customProperties.availableHeight, `${data.available.height}px`);
    }, []);
    const pinRef = React.useRef(null);
    const contentHeightRef = React.useRef(0);
    const updatePinPosition = React.useCallback(()=>{
        pinRef.current?.update();
    }, []);
    const onResize = React.useCallback((contentRect)=>{
        const contentHeight = contentRect.client?.height ?? 0;
        if (contentHeightRef.current !== contentHeight) {
            contentHeightRef.current = contentHeight;
            updatePinPosition();
        }
    }, [
        updatePinPosition
    ]);
    const [isScrolled, setIsScrolled] = React.useState(false);
    const scrollTopRef = React.useRef(0);
    const handleScroll = React.useCallback((e)=>{
        const scrollTop = e.target?.scrollTop ?? 0;
        onScroll?.({
            scrollTop
        });
        if (headerDivider !== 'when-scrolled') return;
        if (scrollTopRef.current === 0 && scrollTop > 0 || scrollTopRef.current > 0 && scrollTop === 0) {
            scrollTopRef.current = scrollTop;
            setIsScrolled(scrollTop > 0);
        }
    }, [
        onScroll,
        setIsScrolled,
        headerDivider
    ]);
    const showHeaderDivider = headerDivider === 'always' || headerDivider === 'when-scrolled' && isScrolled;
    const onOutsidePointerDown = React.useCallback(({ target })=>{
        if (onRequestClose && target !== 'reference')
        onRequestClose();
    }, [
        onRequestClose
    ]);
    const resolvedTrigger = resolveTrigger({
        trigger,
        open,
        id,
        role: contentContainerProps.role
    });
    const standardHeader = title != null ? _jsx(SurfaceHeader, {
        title: title,
        description: description,
        start: headerStart,
        end: headerEnd,
        alignment: headerAlignment,
        divider: false
    }) : undefined;
    return _jsx(PinComponent, {
        ref: pinRef,
        placement: placement,
        enableFlip: enableFlip,
        enableShift: enableShift,
        offset: resolveOffset(offset),
        open: open,
        onOutsidePointerDown: onOutsidePointerDown,
        onCloseComplete: onCloseComplete,
        blockOutsidePointerEvents: blockOutsidePointerEvents,
        onCalculateLayout: onCalculateLayout,
        reference: resolvedTrigger,
        children: ({ setArrow })=>_jsx(Measure, {
                onResize: onResize,
                client: true,
                children: ({ measureRef })=>_jsxs(ContentContainer, {
                        ref: composeRefs(contentContainerRef, measureRef),
                        className: contentContainerClassName,
                        id: id,
                        onRequestEscape: onRequestClose,
                        onScroll: handleScroll,
                        ...contentContainerProps,
                        children: [
                            arrow ? _jsx(Arrow, {
                                ref: setArrow,
                                placement: placement
                            }) : null,
                            (standardHeader != null || header != null) && _jsxs("div", {
                                className: classNames(styles.header, {
                                    [styles.headerBorder]: showHeaderDivider
                                }),
                                children: [
                                    standardHeader,
                                    header
                                ]
                            }),
                            _jsx("div", {
                                className: styles.content,
                                children: children
                            }),
                            footer != null && _jsx("div", {
                                className: styles.footer,
                                children: footer
                            })
                        ]
                    })
            })
    });
}
const TRANSITION_DURATION = parseInt(styles.transitionTime, 10);
const TRANSITION_CLASS_NAMES = {
    appear: styles.visible,
    appearActive: styles.visible,
    appearDone: styles.visible,
    enter: styles.visible,
    enterActive: styles.visible,
    enterDone: styles.visible,
    exit: styles.hidden,
    exitActive: styles.hidden,
    exitDone: styles.hidden
};
function TransitionPin({ open, onCloseComplete, children, ref, ...props }) {
    const [transitionOpen, setTransitionOpen] = React.useState(open);
    const wrapper = (children)=>
        _jsx(SuspendableCssTransition, {
            classNames: TRANSITION_CLASS_NAMES,
            open: open,
            onEnter: ()=>setTransitionOpen(true),
            onExiting: ()=>setTransitionOpen(false),
            onExited: onCloseComplete,
            timeout: TRANSITION_DURATION,
            children: children
        });
    const wrappedChildren = typeof children === 'function' ? (options)=>wrapper(children(options)) : wrapper(children);
    return _jsx(Pin, {
        ...props,
        ref: ref,
        open: open || transitionOpen,
        children: wrappedChildren
    });
}
function StaticPin({ open, onCloseComplete, children, ref, ...props }) {
    const prevOpen = React.useRef(open);
    React.useEffect(()=>{
        if (prevOpen.current && !open)
            onCloseComplete?.();
        prevOpen.current = open;
    }, [
        open,
        onCloseComplete
    ]);
    const wrappedChildren = typeof children === 'function' ? (options)=>_jsx("div", {
            className: styles.visible,
            children: children(options)
        }) : _jsx("div", {
        className: styles.visible,
        children: children
    });
    return _jsx(Pin, {
        ...props,
        ref: ref,
        open: open,
        children: wrappedChildren
    });
}
function resolveOffset(offset) {
    if (typeof offset === 'object') return offset;
    return {
        main: offset === '0' ? 0 : parseUnitMultiplier(offset),
        cross: 0
    };
}
const parseUnitMultiplier = (value)=>parseFloat(value.slice(0, -1)) * baseUnit;
function SuspendableCssTransition({ children, classNames, onEnter, onExited, onExiting, open, timeout }) {
    const stableOnExiting = useStableFunction(onExiting ?? (()=>{}));
    const stableOnExited = useStableFunction(onExited ?? (()=>{}));
    const nodeRef = React.useRef(null);
    React.useEffect(()=>{
        if (open)
            return;
        const timerId = setTimeout(stableOnExiting, timeout);
        return ()=>clearTimeout(timerId);
    }, [
        timeout,
        stableOnExiting,
        open
    ]);
    React.useEffect(()=>stableOnExited, [
        stableOnExited
    ]);
    return _jsx(CSSTransition, {
        in: open,
        appear: true,
        timeout: timeout,
        classNames: classNames,
        onEnter: onEnter,
        nodeRef: nodeRef,
        children: _jsx("div", {
            ref: nodeRef,
            children: children
        })
    });
}
