import { arrow, autoUpdate, flip, hide, offset, platform, shift, useFloating } from '@floating-ui/react';
import { composeRefs } from '../../../../../base/react/compose_refs';
import * as React from 'react';
import { getVisualViewport } from '../../../device_capabilities/visual_viewport';
import { useIsomorphicLayoutEffect } from '../../../hydration/use_isomorphic_layout_effect';
import { baseUnit } from '../../../metrics/metrics';
import { getSafeAreaInsets } from '../../../platform_quirks/get_safe_area_insets';
import { useDirection } from '../../../provider/provider';
import { useStableFunction } from '../../../stable_function/stable_function';
const BOUNDARY_PADDING_MAP = {
    ['0']: 0,
    ['1u']: baseUnit
};
export function useFloatingUiBackend({ placement: backendPlacement, enableFlip, enableShift, rtlAware, offset: backendOffset, boundary, boundaryPadding: backendBoundaryPadding, onCalculateLayout }) {
    const arrowRef = React.useRef(null);
    const contentRef = React.useRef(null);
    const bootstrapDirection = useDirection();
    const isRtl = React.useCallback(()=>{
        if (!rtlAware) return false;
        return bootstrapDirection === 'RTL';
    }, [
        bootstrapDirection,
        rtlAware
    ]);
    const includeSafeAreaInsets = boundary === 'viewport' && window.frameElement == null;
    const boundaryPadding = resolveBoundaryPadding({
        backendBoundaryPadding,
        includeSafeAreaInsets
    });
    const { stickyPlacement, store, enableStickyPlacementRef, cachedPlacementRef } = useStickyPlacement(boundaryPadding);
    const isRtlDirection = isRtl();
    let floatingUiPlacement = getFloatingUiPlacement(backendPlacement, isRtlDirection);
    if (enableStickyPlacementRef.current && cachedPlacementRef.current != null) floatingUiPlacement = cachedPlacementRef.current;
    const calculateLayout = useStableFunction(({ placement, reference, content })=>{
        if (onCalculateLayout == null)
            return;
        const visualViewport = getVisualViewport();
        const viewportWidth = visualViewport?.width ?? window.innerWidth;
        const viewportHeight = visualViewport?.height ?? window.innerHeight;
        const availableWidth = viewportWidth - boundaryPadding.left - boundaryPadding.right;
        const availableHeight = calculateAvailableHeight(placement, reference, viewportHeight, enableFlip, boundaryPadding, backendOffset.main);
        onCalculateLayout({
            reference,
            content,
            available: {
                width: availableWidth,
                height: availableHeight
            }
        });
    });
    const { refs: { setReference, setFloating }, floatingStyles, update, middlewareData, placement } = useFloating({
        platform: {
            ...platform,
            isRTL: isRtl
        },
        strategy: 'fixed',
        placement: floatingUiPlacement,
        whileElementsMounted: (reference, floating, update)=>{
            const onUpdate = ()=>{
                calculateLayout({
                    placement: floatingUiPlacement,
                    reference: reference.getBoundingClientRect(),
                    content: floating.getBoundingClientRect()
                });
                update();
            };
            return autoUpdate(reference, floating, onUpdate);
        },
        middleware: [
            enableFlip && stickyPlacement({
                backendOffset
            }),
            offset({
                mainAxis: backendOffset.main,
                crossAxis: backendOffset.cross
            }),
            enableFlip && !enableStickyPlacementRef.current && flip({
                flipAlignment: false,
                padding: boundaryPadding,
                boundary: boundary === 'viewport' ? 'clippingAncestors' : boundary,
                rootBoundary: typeof window !== 'undefined' ? getViewportRect() : undefined
            }),
            enableShift && shift({
                padding: boundaryPadding,
                crossAxis: true,
                boundary: boundary === 'viewport' ? 'clippingAncestors' : boundary
            }),
            enableFlip && store(),
            arrow({
                element: arrowRef
            }),
            {
                name: 'hide',
                fn: (state)=>{
                    const { rects: { reference: referenceRect }, elements: { reference: referenceEl } } = state;
                    const focusdElement = window.document.activeElement;
                    const Node = (focusdElement?.ownerDocument?.defaultView ?? window).Node;
                    const focusedElementMayOpenVirtualKB = focusdElement instanceof Node && (focusdElement.tagName === 'INPUT' || focusdElement.tagName === 'TEXTAREA');
                    const isFocusInInputInContent = focusedElementMayOpenVirtualKB && contentRef.current instanceof Node && contentRef.current.contains(focusdElement);
                    const isFocusInReference = focusedElementMayOpenVirtualKB && referenceEl instanceof Node && referenceEl.contains(focusdElement);
                    const enabled = !isFocusInInputInContent && !isFocusInReference && !(referenceRect.width === 0 && referenceRect.height === 0 && referenceRect.x === 0 && referenceRect.y === 0);
                    if (!enabled) return {};
                    return hide({
                        boundary: boundary === 'viewport' ? getViewportRect() : boundary
                    }).fn(state);
                }
            }
        ]
    });
    useIsomorphicLayoutEffect(()=>{
        const arrow = arrowRef.current;
        if (arrow != null) updateArrow(arrow, middlewareData, placement);
    }, [
        middlewareData,
        placement
    ]);
    return {
        setReference,
        contentProps: {
            ref: composeRefs(setFloating, contentRef),
            style: {
                ...floatingStyles,
                visibility: middlewareData.hide?.referenceHidden ? 'hidden' : 'visible'
            }
        },
        setArrow: useStableFunction((arrow)=>{
            arrowRef.current = arrow;
            if (arrow != null) updateArrow(arrow, middlewareData, placement);
        }),
        update
    };
}
const ARROW_ROTATION_MAP = {
    ['left']: '90deg',
    ['right']: '-90deg',
    ['top']: '180deg',
    ['bottom']: '0deg'
};
function updateArrow(arrow, middlewareData, placement) {
    const x = middlewareData.arrow?.x;
    const y = middlewareData.arrow?.y;
    const side = placement.split('-')[0];
    arrow.style.setProperty('position', 'absolute');
    arrow.style.setProperty('left', x != null ? `${x}px` : '');
    arrow.style.setProperty('top', y != null ? `${y}px` : '');
    arrow.style.setProperty('right', '');
    arrow.style.setProperty('bottom', '');
    arrow.style.setProperty(side, '100%');
    arrow.style.setProperty('transform', `rotate(${ARROW_ROTATION_MAP[side]})`);
}
const FLOATING_UI_PLACEMENT_MAP = {
    ['start-top']: {
        ltr: 'left-start',
        rtl: 'right-start'
    },
    ['start-center']: {
        ltr: 'left',
        rtl: 'right'
    },
    ['start-bottom']: {
        ltr: 'left-end',
        rtl: 'right-end'
    },
    ['end-top']: {
        ltr: 'right-start',
        rtl: 'left-start'
    },
    ['end-center']: {
        ltr: 'right',
        rtl: 'left'
    },
    ['end-bottom']: {
        ltr: 'right-end',
        rtl: 'left-end'
    },
    ['top-start']: {
        ltr: 'top-start',
        rtl: 'top-start'
    },
    ['top-center']: {
        ltr: 'top',
        rtl: 'top'
    },
    ['top-end']: {
        ltr: 'top-end',
        rtl: 'top-end'
    },
    ['bottom-start']: {
        ltr: 'bottom-start',
        rtl: 'bottom-start'
    },
    ['bottom-center']: {
        ltr: 'bottom',
        rtl: 'bottom'
    },
    ['bottom-end']: {
        ltr: 'bottom-end',
        rtl: 'bottom-end'
    }
};
function getFloatingUiPlacement(placement, isRtl) {
    const mapping = FLOATING_UI_PLACEMENT_MAP[placement];
    return isRtl ? mapping.rtl : mapping.ltr;
}
function getAvailableVerticalSpace({ viewportHeight, boundaryPadding, offset, reference }) {
    const visibleSpaceTop = Math.min(viewportHeight, reference.top);
    const visibleSpaceBottom = Math.min(viewportHeight, viewportHeight - reference.bottom);
    return {
        top: visibleSpaceTop - boundaryPadding.top - offset,
        bottom: visibleSpaceBottom - boundaryPadding.bottom - offset
    };
}
function calculateAvailableHeight(placement, reference, viewportHeight, enableFlip, boundaryPadding, offset) {
    const isVerticalPlacement = placement.startsWith('bottom') || placement.startsWith('top');
    if (!isVerticalPlacement) return viewportHeight - boundaryPadding.top - boundaryPadding.bottom;
    const availableSpace = getAvailableVerticalSpace({
        viewportHeight,
        boundaryPadding,
        offset,
        reference
    });
    if (enableFlip)
        return Math.max(availableSpace.top, availableSpace.bottom);
    else
        return placement.startsWith('top') ? availableSpace.top : availableSpace.bottom;
}
function useStickyPlacement(boundaryPadding) {
    const contentHeightRef = React.useRef(undefined);
    const cachedPlacementRef = React.useRef(undefined);
    const enableStickyPlacementRef = React.useRef(false);
    const stickyPlacement = useStableFunction(({ backendOffset })=>({
            name: 'stickyPlacement',
            options: [
                backendOffset
            ],
            fn: ({ rects: { floating }, elements: { reference: referenceEl } })=>{
                if (cachedPlacementRef.current == null)
                    return {};
                const availableSpace = getAvailableVerticalSpace({
                    viewportHeight: window.innerHeight,
                    boundaryPadding,
                    offset: backendOffset.main,
                    reference: referenceEl.getBoundingClientRect()
                });
                const cachedPlacement = cachedPlacementRef.current;
                const contentHeight = floating.height;
                let hasEnoughSpaceInCurrentPlacement = false;
                if (cachedPlacement.startsWith('top'))
                    hasEnoughSpaceInCurrentPlacement = contentHeight <= availableSpace.top;
                else if (cachedPlacement.startsWith('bottom')) hasEnoughSpaceInCurrentPlacement = contentHeight <= availableSpace.bottom;
                else return {};
                if (!enableStickyPlacementRef.current && contentHeightRef.current !== contentHeight && hasEnoughSpaceInCurrentPlacement)
                    enableStickyPlacementRef.current = true;
                if (enableStickyPlacementRef.current && !hasEnoughSpaceInCurrentPlacement) {
                    enableStickyPlacementRef.current = false;
                    cachedPlacementRef.current = undefined;
                }
                return {};
            }
        }));
    const store = useStableFunction(()=>({
            name: 'store',
            fn: ({ placement: currentPlacement, rects: { floating } })=>{
                contentHeightRef.current = floating.height;
                if (!enableStickyPlacementRef.current) cachedPlacementRef.current = currentPlacement;
                return {};
            }
        }));
    return {
        stickyPlacement,
        store,
        enableStickyPlacementRef,
        cachedPlacementRef
    };
}
function getViewportRect() {
    let width = document.documentElement.clientWidth;
    let height = document.documentElement.clientHeight;
    let x = 0;
    let y = 0;
    const visualViewport = getVisualViewport();
    if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height;
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
        const iframe = window.frameElement;
        if (iframe) {
            const iframeRect = iframe.getBoundingClientRect();
            x = visualViewport.offsetLeft - iframeRect.left;
            y = visualViewport.offsetTop - iframeRect.top;
        }
    }
    return {
        x,
        y,
        width,
        height
    };
}
const DEFAULT_INSETS = {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
};
function resolveBoundaryPadding({ backendBoundaryPadding, includeSafeAreaInsets }) {
    const desiredPaddingPx = BOUNDARY_PADDING_MAP[backendBoundaryPadding];
    const insets = includeSafeAreaInsets ? getSafeAreaInsets() : DEFAULT_INSETS;
    return {
        top: Math.max(desiredPaddingPx, insets.top),
        right: Math.max(desiredPaddingPx, insets.right),
        bottom: Math.max(desiredPaddingPx, insets.bottom),
        left: Math.max(desiredPaddingPx, insets.left)
    };
}
