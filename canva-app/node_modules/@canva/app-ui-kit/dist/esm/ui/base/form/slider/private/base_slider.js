import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import classNames from 'classnames';
import * as React from 'react';
import { useIsomorphicLayoutEffect } from '../../../hydration/use_isomorphic_layout_effect';
import { useSheetScrollIsolation } from '../../../surface/sheet/behavior/behavior';
import { NeverSnap } from './bar_snap_behavior';
import styles, { customProperties } from './base_slider.css';
import sliderStyles, { customProperties as sliderCustomProperties } from './slider.css';
const clamp = ({ value, min, max })=>{
    return Math.min(Math.max(min, value), max);
};
const valueAsPercent = ({ value, min, max })=>{
    const range = max - min;
    const valueFromMin = clamp({
        value,
        min,
        max
    }) - min;
    const percent = valueFromMin / range * 100;
    return percent > 99.5 ? 100 : percent;
};
export const BaseSlider = React.memo(
    function BaseSlider({ id, min, max, step, snap, value, disabled, ariaLabel, ariaLabelledBy, ariaDescribedBy, ariaValueText, trackColor, track: trackProp, fill: fillProp, handle: handleProp, snapBehavior: snapBehaviorProp, blurOnDragEnd, onDragStart, onDragEnd, onChange, onChangeComplete, onBarResize, origin, fillColor }) {
        const [state, setState] = React.useState({
            active: false,
            focused: false,
            handleHovering: false,
            trackHovering: false,
            leftBound: 0,
            width: 0
        });
        const inputRef = React.useRef(null);
        const styledBarRef = React.useRef(null);
        const snapBehavior = React.useMemo(()=>snapBehaviorProp || new NeverSnap(), [
            snapBehaviorProp
        ]);
        const isDraggingRef = React.useRef(false);
        const dragStartValueRef = React.useRef(clamp({
            value,
            min,
            max
        }));
        const keyPressedRef = React.useRef(false);
        const onChangeCompleteRef = React.useRef(onChangeComplete);
        const onDragEndRef = React.useRef(onDragEnd);
        React.useEffect(()=>{
            onChangeCompleteRef.current = onChangeComplete;
        }, [
            onChangeComplete
        ]);
        React.useEffect(()=>{
            onDragEndRef.current = onDragEnd;
        }, [
            onDragEnd
        ]);
        React.useEffect(()=>{
            return ()=>{
                if (isDraggingRef.current) onDragEndRef.current?.();
            };
        }, []);
        useIsomorphicLayoutEffect(()=>{
            const measureWidth = ()=>{
                if (styledBarRef.current) {
                    const width = styledBarRef.current.offsetWidth;
                    const leftBound = styledBarRef.current.getBoundingClientRect().left;
                    setState((prev)=>({
                            ...prev,
                            width,
                            leftBound
                        }));
                    onBarResize?.({
                        width,
                        start: leftBound
                    });
                }
            };
            measureWidth();
            if (typeof ResizeObserver !== 'undefined' && styledBarRef.current) {
                const resizeObserver = new ResizeObserver(measureWidth);
                resizeObserver.observe(styledBarRef.current);
                return ()=>{
                    resizeObserver.disconnect();
                };
            }
        }, [
            onBarResize
        ]);
        const fillCalculations = React.useMemo(()=>{
            const trackWidth = state.width;
            const startingPoint = origin != null ? clamp({
                value: origin,
                min,
                max
            }) : snap;
            const handleWidth = parseInt(sliderStyles.handleDiameter, 10);
            const leftValue = startingPoint === undefined || startingPoint === min ? min : Math.min(startingPoint, value);
            const leftAsPercent = (leftValue - min) / (max - min) * 100;
            const startFill = leftAsPercent === 0 ? 0 : handleWidth / 2 + (trackWidth - handleWidth) * leftAsPercent / 100;
            const rightValue = startingPoint === max ? max : startingPoint === undefined ? value : Math.max(startingPoint, value);
            const rightAsPercent = (rightValue - min) / (max - min) * 100;
            const endFill = rightAsPercent === 100 ? trackWidth : handleWidth / 2 + (trackWidth - handleWidth) * rightAsPercent / 100;
            const color = fillColor !== undefined ? fillColor : trackColor !== undefined || value == null ? 'transparent' : undefined;
            return {
                startFill,
                endFill,
                color
            };
        }, [
            state.width,
            min,
            max,
            value,
            trackColor,
            origin,
            snap,
            fillColor
        ]);
        const handlePositionerPercent = React.useMemo(()=>{
            const finalValue = value == null ? min + (max - min) / 2 : value;
            return valueAsPercent({
                value: finalValue,
                min,
                max
            });
        }, [
            value,
            min,
            max
        ]);
        const handlePositionerStyle = React.useMemo(()=>{
            const startingPoint = origin != null ? clamp({
                value: origin,
                min,
                max
            }) : snap;
            const snapAsPercent = startingPoint != null ? (startingPoint - min) / (max - min) * 100 : undefined;
            if (snapAsPercent == null) return {
                width: `${handlePositionerPercent}%`
            };
            if (handlePositionerPercent >= snapAsPercent) return {
                width: `${handlePositionerPercent - snapAsPercent}%`,
                [customProperties.handlePositionerMargin]: `${snapAsPercent}%`
            };
            return {
                width: `${snapAsPercent - handlePositionerPercent}%`,
                [customProperties.handlePositionerMargin]: `${handlePositionerPercent}%`,
                transform: `scaleX(-1)`
            };
        }, [
            min,
            max,
            handlePositionerPercent,
            origin,
            snap
        ]);
        const track = React.useCallback((props)=>trackProp != null ? trackProp(props) : defaultTrack({
                ...props,
                insetStart: handlePositionerPercent <= 0.5,
                insetEnd: handlePositionerPercent >= 99.5
            }), [
            trackProp,
            handlePositionerPercent
        ]);
        const fill = React.useCallback((props)=>fillProp != null ? fillProp(props) : defaultFill({
                ...props,
                insetStart: handlePositionerPercent <= 0.5,
                insetEnd: handlePositionerPercent >= 99.5
            }), [
            fillProp,
            handlePositionerPercent
        ]);
        const handle = handleProp ?? defaultHandle;
        const handleDragStart = React.useCallback((value)=>{
            dragStartValueRef.current = clamp({
                value,
                min,
                max
            });
            isDraggingRef.current = true;
            setState((prev)=>({
                    ...prev,
                    active: true
                }));
            onDragStart?.();
        }, [
            min,
            max,
            onDragStart
        ]);
        const handleDragEnd = React.useCallback((newValue)=>{
            if (!isDraggingRef.current) return;
            isDraggingRef.current = false;
            setState((prev)=>({
                    ...prev,
                    active: false
                }));
            blurOnDragEnd && inputRef.current?.blur();
            newValue != null && onChangeCompleteRef.current?.(dragStartValueRef.current, newValue);
            onDragEndRef.current?.();
        }, [
            blurOnDragEnd
        ]);
        const handleMouseUp = React.useCallback((event)=>{
            const target = event.target;
            const value = clamp({
                value: parseFloat(target.value),
                min,
                max
            });
            handleDragEnd(value);
        }, [
            min,
            max,
            handleDragEnd
        ]);
        const handleMouseDown = React.useCallback((event)=>{
            const target = event.target;
            target.addEventListener('mouseup', handleMouseUp, {
                once: true
            });
            const value = clamp({
                value: parseFloat(target.value),
                min,
                max
            });
            handleDragStart(value);
        }, [
            min,
            max,
            handleDragStart,
            handleMouseUp
        ]);
        const handleTouchStart = React.useCallback((event)=>{
            if (event.touches.length > 1) return;
            const target = event.target;
            const value = clamp({
                value: parseFloat(target.value),
                min,
                max
            });
            handleDragStart(value);
        }, [
            min,
            max,
            handleDragStart
        ]);
        const handleTouchEnd = React.useCallback((event)=>{
            if (event.touches.length > 0) return;
            const target = event.target;
            const value = clamp({
                value: parseFloat(target.value),
                min,
                max
            });
            handleDragEnd(value);
        }, [
            min,
            max,
            handleDragEnd
        ]);
        const handleKeyDown = React.useCallback(()=>{
            keyPressedRef.current = true;
            snapBehavior.onKeyDown();
        }, [
            snapBehavior
        ]);
        const handleKeyUp = React.useCallback(()=>{
            keyPressedRef.current = false;
            snapBehavior.onKeyUp();
        }, [
            snapBehavior
        ]);
        const handleFocus = React.useCallback(()=>{
            setState((prev)=>({
                    ...prev,
                    focused: true
                }));
        }, []);
        const handleBlur = React.useCallback(()=>{
            setState((prev)=>({
                    ...prev,
                    focused: false
                }));
        }, []);
        const handleMouseEnter = React.useCallback(()=>{
            setState((prev)=>({
                    ...prev,
                    trackHovering: true
                }));
        }, []);
        const handleMouseMove = React.useCallback((e)=>{
            const handleWidth = parseInt(sliderStyles.handleDiameter, 10);
            const trackWidth = state.width;
            const handleOverlayDiameter = parseInt(sliderStyles.handleOverlayDiameter, 10);
            const mouseX = e.clientX - state.leftBound;
            const handleX = handleWidth / 2 + (trackWidth - handleWidth) * handlePositionerPercent / 100;
            if (mouseX >= handleX - handleOverlayDiameter / 2 && mouseX <= handleX + handleOverlayDiameter / 2) setState((prev)=>({
                    ...prev,
                    handleHovering: true
                }));
            else setState((prev)=>({
                    ...prev,
                    handleHovering: false
                }));
        }, [
            state.width,
            state.leftBound,
            handlePositionerPercent
        ]);
        const handleMouseLeave = React.useCallback(()=>{
            setState((prev)=>({
                    ...prev,
                    trackHovering: false,
                    handleHovering: false
                }));
        }, []);
        const handleChange = React.useCallback((event)=>{
            const newValue = clamp({
                value: parseFloat(event.target.value),
                min,
                max
            });
            const range = max - min;
            const pxPerUnit = state.width / range;
            snapBehavior.onChange({
                onChange,
                value
            }, newValue, pxPerUnit);
            if (keyPressedRef.current) onChangeComplete?.(value, newValue);
        }, [
            max,
            min,
            state.width,
            snapBehavior,
            value,
            onChange,
            onChangeComplete
        ]);
        const sheetScrollIsolationRef = useSheetScrollIsolation();
        return _jsxs("div", {
            className: styles.root,
            ref: sheetScrollIsolationRef,
            children: [
                _jsxs("div", {
                    className: styles.styledBarRoot,
                    ref: styledBarRef,
                    children: [
                        track({
                            color: trackColor,
                            min,
                            max,
                            snap
                        }),
                        fill({
                            disabled,
                            trackWidth: state.width,
                            startFill: fillCalculations.startFill,
                            endFill: fillCalculations.endFill,
                            color: fillCalculations.color
                        }),
                        _jsx("div", {
                            className: styles.handlePositionerContainer,
                            children: _jsx("div", {
                                className: styles.handlePositioner,
                                style: handlePositionerStyle,
                                children: handle({
                                    ...state,
                                    disabled
                                })
                            })
                        })
                    ]
                }),
                _jsx("input", {
                    id: id,
                    className: classNames(styles.hiddenSlider, {
                        [styles.disabled]: disabled
                    }),
                    ref: inputRef,
                    type: "range",
                    onChange: handleChange,
                    onKeyDown: handleKeyDown,
                    onKeyUp: handleKeyUp,
                    onFocus: handleFocus,
                    onBlur: handleBlur,
                    onMouseEnter: handleMouseEnter,
                    onMouseMove: handleMouseMove,
                    onMouseLeave: handleMouseLeave,
                    onTouchStart: handleTouchStart,
                    onTouchEnd: handleTouchEnd,
                    onMouseDown: handleMouseDown,
                    min: min,
                    max: max,
                    step: step,
                    value: value,
                    disabled: disabled,
                    "aria-label": ariaLabel,
                    "aria-labelledby": ariaLabelledBy,
                    "aria-describedby": ariaDescribedBy,
                    "aria-valuetext": ariaValueText
                })
            ]
        });
    }
);
const defaultTrack = ({ min, max, snap, color, insetStart, insetEnd })=>{
    const snapIndicatorBufferWidth = snap != null && `calc(${(snap - min) / (max - min) * 100}% - 0.5 * ${sliderStyles.snapIndicatorSize})`;
    return _jsxs("div", {
        className: sliderStyles.track,
        children: [
            _jsx("div", {
                className: classNames(sliderStyles.trackFill, {
                    [sliderStyles.insetStart]: insetStart,
                    [sliderStyles.insetEnd]: insetEnd
                }),
                style: {
                    [sliderCustomProperties.trackColor]: color
                }
            }),
            _jsx("div", {
                className: classNames(sliderStyles.startStopIndicator, {
                    [sliderStyles.insetStart]: insetStart
                })
            }),
            _jsx("div", {
                className: classNames(sliderStyles.endStopIndicator, {
                    [sliderStyles.insetEnd]: insetEnd
                })
            }),
            snapIndicatorBufferWidth && _jsxs("div", {
                className: sliderStyles.snapIndicatorContainer,
                children: [
                    _jsx("div", {
                        className: sliderStyles.snapIndicatorBuffer,
                        style: {
                            width: snapIndicatorBufferWidth
                        }
                    }),
                    _jsx("div", {
                        className: sliderStyles.snapIndicator
                    })
                ]
            })
        ]
    });
};
const defaultFill = ({ disabled, trackWidth, startFill, endFill, color, insetStart, insetEnd })=>{
    return _jsx("div", {
        className: classNames(sliderStyles.fill, {
            [sliderStyles.insetStart]: insetStart,
            [sliderStyles.insetEnd]: insetEnd,
            [sliderStyles.disabled]: disabled
        }),
        style: {
            [sliderCustomProperties.fillColor]: color,
            [sliderCustomProperties.fillStart]: `${startFill}px`,
            [sliderCustomProperties.fillEnd]: `${trackWidth - endFill}px`
        }
    });
};
const defaultHandle = ({ handleHovering, trackHovering, focused, disabled })=>{
    return _jsx("div", {
        className: classNames(sliderStyles.handle, {
            [sliderStyles.focused]: !disabled && focused,
            [sliderStyles.handleHovering]: !disabled && handleHovering,
            [sliderStyles.trackHovering]: !disabled && trackHovering,
            [sliderStyles.disabled]: disabled
        })
    });
};
