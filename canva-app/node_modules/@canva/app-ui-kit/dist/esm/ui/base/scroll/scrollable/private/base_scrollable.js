import { jsx as _jsx } from "react/jsx-runtime";
import { debounce } from '../../../../../base/debounce';
import { composeRefs } from '../../../../../base/react/compose_refs';
import classNames from 'classnames';
import * as React from 'react';
import ResizeObserver from 'resize-observer-polyfill';
import { usePrefersReducedMotion } from '../../../animation/supports_animation';
import { useDirection, useEnableAnimations } from '../../../provider/provider';
import * as scroll from '../../scroll';
import styles from './base_scrollable.css';
export function useScrollable(options) {
    const { onScroll, onScrollStateChange, debounceMs = 0 } = options;
    const rtl = useDirection() === 'RTL';
    const ref = React.useRef(null);
    const enableAnimations = useEnableAnimations();
    const prefersReducedMotion = usePrefersReducedMotion();
    const disableEasing = !enableAnimations || prefersReducedMotion;
    const handle = React.useMemo(()=>{
        return {
            getScrollState: ()=>{
                if (ref.current) return scroll.getScrollState(ref.current, {
                    rtl
                });
            },
            scrollTo: (options)=>{
                if (ref.current) {
                    const easing = disableEasing ? 'instant' : options.easing || 'smooth';
                    scroll.scrollTo(ref.current, {
                        rtl,
                        ...options,
                        easing
                    });
                }
            },
            scrollBy: (options)=>{
                if (ref.current) {
                    const easing = disableEasing ? 'instant' : options.easing || 'smooth';
                    scroll.scrollBy(ref.current, {
                        rtl,
                        ...options,
                        easing
                    });
                }
            },
            scrollToPage: (options)=>{
                if (ref.current) {
                    const easing = disableEasing ? 'instant' : options.easing || 'smooth';
                    scroll.scrollToPage(ref.current, {
                        rtl,
                        ...options,
                        easing
                    });
                }
            },
            scrollByPage: (options)=>{
                if (ref.current) {
                    const easing = disableEasing ? 'instant' : options.easing || 'smooth';
                    scroll.scrollByPage(ref.current, {
                        rtl,
                        ...options,
                        easing
                    });
                }
            }
        };
    }, [
        rtl,
        disableEasing
    ]);
    const debouncedOnScroll = React.useMemo(()=>{
        if (!onScroll && !onScrollStateChange) return;
        const onScrollWrapper = ()=>{
            const scrollState = handle.getScrollState();
            if (scrollState) {
                onScroll?.(scrollState);
                onScrollStateChange?.(scrollState);
            }
        };
        return debounceMs === 0 ? onScrollWrapper : debounce(onScrollWrapper, debounceMs, {
            leading: true
        });
    }, [
        onScroll,
        onScrollStateChange,
        debounceMs,
        handle
    ]);
    const debouncedOnScrollStateChange = React.useMemo(()=>{
        if (!onScrollStateChange) return;
        const onScrollStateChangeWrapper = ()=>{
            const scrollState = handle.getScrollState();
            if (scrollState) onScrollStateChange?.(scrollState);
        };
        return debounceMs === 0 ? onScrollStateChangeWrapper : debounce(onScrollStateChangeWrapper, debounceMs, {
            leading: true
        });
    }, [
        onScrollStateChange,
        debounceMs,
        handle
    ]);
    React.useEffect(()=>{
        if (!ref.current || !debouncedOnScrollStateChange) return;
        const resizeObserver = new ResizeObserver(()=>debouncedOnScrollStateChange());
        resizeObserver.observe(ref.current);
        const mutationObserver = new MutationObserver(()=>debouncedOnScrollStateChange());
        mutationObserver.observe(ref.current, {
            childList: true,
            subtree: true
        });
        return ()=>{
            resizeObserver.disconnect();
            mutationObserver.disconnect();
        };
    }, [
        debouncedOnScrollStateChange
    ]);
    const setRef = React.useCallback((element)=>{
        ref.current = element;
        if (element) debouncedOnScrollStateChange?.();
    }, [
        debouncedOnScrollStateChange
    ]);
    return {
        ref: setRef,
        handle,
        onScroll: debouncedOnScroll
    };
}
export const BaseScrollable = (props)=>{
    const { children, direction, onScroll: onScrollProp, onScrollStateChange, debounceMs = 0, className, ariaLabel, role = 'region', ref: forwardedRef } = props;
    const { ref, handle, onScroll } = useScrollable({
        onScroll: onScrollProp,
        onScrollStateChange,
        debounceMs
    });
    const localRef = React.useRef(null);
    React.useImperativeHandle(forwardedRef, ()=>({
            ...handle,
            getLegacyScrollState: ()=>getLegacyScrollState(localRef.current, direction)
        }));
    return _jsx("div", {
        tabIndex: 0,
        "aria-label": ariaLabel,
        role: ariaLabel ? role : undefined,
        className: classNames(styles.scrollContainer, className, {
            [styles.vertical]: direction === 'vertical',
            [styles.horizontal]: direction === 'horizontal'
        }),
        ref: composeRefs(localRef, ref),
        onScroll: onScroll,
        children: children
    });
};
function getLegacyScrollState(container, direction) {
    const state = scroll.getScrollState(container);
    if (!state.scrollable) return {
        scrollable: false
    };
    return {
        scrollable: state.scrollable,
        atStart: direction === 'vertical' ? state.atTop : state.atStart,
        atEnd: direction === 'vertical' ? state.atBottom : state.atEnd,
        raw: {
            scroll: {
                height: container.scrollHeight,
                width: container.scrollWidth,
                left: container.scrollLeft,
                top: container.scrollTop
            },
            client: {
                height: container.clientHeight,
                width: container.clientWidth,
                left: container.clientLeft,
                top: container.clientTop
            }
        }
    };
}
