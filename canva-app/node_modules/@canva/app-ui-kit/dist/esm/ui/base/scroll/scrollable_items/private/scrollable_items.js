import { jsx as _jsx } from "react/jsx-runtime";
import { composeRefs } from '../../../../../base/react/compose_refs';
import classNames from 'classnames';
import * as React from 'react';
import { useBox } from '../../../box/box';
import { getSpaceValue, unitSizeToNumber } from '../../../metrics/metrics';
import { useDirection } from '../../../provider/provider';
import { generateStyle } from '../../../responsive/responsive';
import { useResponsiveValue } from '../../../responsive/use_responsive_value';
import { useScrollableItems } from './behavior';
import styles, { customProperties } from './scrollable_items.css';
import { useVisibilityObserver, VisibilityRoot } from './visibility_observer';
export const scrollableItemsGaps = [
    '0',
    '1u',
    '2u',
    '3u'
];
const ScrollableItemsContext = React.createContext({
    snapAlign: 'start',
    focusScrollContainer: ()=>{}
});
export const ScrollableItems = ({ direction, fadeSize = '6u', gap = '2u', children, id, snap = 'proximity', snapAlign = 'start', padding, paddingX, paddingY, paddingTop, paddingBottom, paddingStart, paddingEnd, ref, scrollableRef, onScroll: onScrollProp, onScrollStateChange: onScrollStateChangeProp, itemSize = 'intrinsic', outOfViewItemBehavior = 'inert', role, ariaLabel, ariaLabelledBy, ariaDescribedBy, ariaSetSize, getItemWidth, itemCount, onFocus })=>{
    const [atStart, setAtStart] = React.useState(true);
    const [atEnd, setAtEnd] = React.useState(true);
    const [numberOfItems, setNumberOfItems] = React.useState(0);
    const localeDirection = useDirection();
    const isHorizontal = direction === 'horizontal';
    const isVertical = !isHorizontal;
    const onScrollStateChange = React.useCallback((state)=>{
        onScrollStateChangeProp?.(state);
        if (isHorizontal) {
            if (ariaSetSize == null) setNumberOfItems(state.itemX?.numberOfItems || 0);
            setAtStart(state.atStart);
            setAtEnd(state.atEnd);
        } else {
            if (ariaSetSize == null) setNumberOfItems(state.itemY?.numberOfItems || 0);
            setAtStart(state.atTop);
            setAtEnd(state.atBottom);
        }
    }, [
        onScrollStateChangeProp,
        isHorizontal,
        ariaSetSize
    ]);
    const responsiveGap = typeof gap === 'object' ? gap : {
        default: gap
    };
    const gapValue = useResponsiveValue(responsiveGap);
    const gapInPixel = unitSizeToNumber(gapValue);
    const { ref: scrollableItemRef, handle, onScroll } = useScrollableItems({
        onScroll: onScrollProp,
        onScrollStateChange,
        gap: gapInPixel,
        getItemWidth,
        itemCount
    });
    React.useImperativeHandle(ref, ()=>mapScrollHandle(handle, snapAlign === 'none' ? 'start' : snapAlign, localeDirection === 'RTL'));
    const { className: boxClassName, style: boxStyle } = useBox({
        display: 'flex',
        flexDirection: isHorizontal ? 'row' : 'column',
        flexWrap: 'noWrap',
        columnGap: isHorizontal ? gap : undefined,
        rowGap: isVertical ? gap : undefined
    });
    const responsiveItemSize = typeof itemSize === 'object' ? itemSize : {
        default: itemSize
    };
    const itemSizeValue = useResponsiveValue(responsiveItemSize);
    const numberOfItemsPerPage = itemSizeValue !== 'intrinsic' ? Math.floor(100 / parseFloat(itemSizeValue)) : 1;
    const className = classNames(styles.scrollableItems, boxClassName, getPaddingClassNames(padding, paddingX, paddingY, paddingTop, paddingBottom, paddingStart, paddingEnd), {
        [styles.horizontal]: isHorizontal,
        [styles.vertical]: isVertical,
        [styles.backwardFade]: fadeSize !== '0' && !atStart,
        [styles.forwardFade]: fadeSize !== '0' && !atEnd,
        [styles.mandatory]: snap === 'mandatory',
        [styles.proximity]: snap === 'proximity',
        [styles.fadeSizeThreeUnit]: fadeSize === '3u',
        [styles.fadeSizeSixUnit]: fadeSize === '6u',
        [styles.fadeSizeTwelveUnit]: fadeSize === '12u'
    });
    const focusRef = React.useRef(null);
    const focusScrollContainer = React.useCallback(()=>{
        focusRef.current?.focus({
            preventScroll: true
        });
    }, []);
    const contextValue = React.useMemo(()=>({
            snapAlign,
            itemSize,
            role,
            focusScrollContainer,
            numberOfItems: ariaSetSize ?? numberOfItems
        }), [
        snapAlign,
        itemSize,
        role,
        focusScrollContainer,
        numberOfItems,
        ariaSetSize
    ]);
    return _jsx(ScrollableItemsContext.Provider, {
        value: contextValue,
        children: _jsx(VisibilityRoot, {
            disable: outOfViewItemBehavior === 'none',
            children: ({ ref: visibilityRootRef })=>_jsx("div", {
                    id: id,
                    ref: composeRefs(scrollableItemRef, focusRef, scrollableRef, visibilityRootRef),
                    onScroll: onScroll,
                    className: className,
                    style: {
                        ...boxStyle,
                        ...getPaddingStyles(padding, paddingX, paddingY, paddingTop, paddingBottom, paddingStart, paddingEnd),
                        [customProperties.gapInPixel]: `${gapInPixel}px`,
                        [customProperties.numberOfItemsPerPage]: numberOfItemsPerPage
                    },
                    role: role,
                    "aria-label": ariaLabelledBy ? undefined : ariaLabel,
                    "aria-labelledby": ariaLabelledBy,
                    "aria-describedby": ariaDescribedBy,
                    onFocus: onFocus,
                    children: children
                })
        })
    });
};
const mapScrollHandle = (handle, defaultItemAlign, rtl)=>{
    return {
        getScrollState: ()=>handle.getScrollState(),
        scrollTo: (options)=>handle.scrollTo({
                rtl,
                ...options
            }),
        scrollBy: (options)=>handle.scrollBy({
                rtl,
                ...options
            }),
        scrollToPage: (options)=>handle.scrollToPage({
                rtl,
                ...options
            }),
        scrollByPage: (options)=>handle.scrollByPage({
                ...options
            }),
        scrollToItem: (options)=>handle.scrollToItem({
                itemAlign: defaultItemAlign,
                rtl,
                ...options
            }),
        scrollByItem: (options)=>handle.scrollByItem({
                rtl,
                itemAlign: defaultItemAlign,
                ...options
            })
    };
};
const getPaddingClassNames = (padding, paddingX, paddingY, paddingTop, paddingBottom, paddingStart, paddingEnd)=>[
        (padding || paddingX || paddingY || paddingTop || paddingBottom || paddingStart || paddingEnd) && styles.hasPadding
    ];
const paddingPropertyMap = {
    default: customProperties.paddingAll,
    smallUp: customProperties.smallUpPaddingAll,
    mediumUp: customProperties.mediumUpPaddingAll,
    largeUp: customProperties.largeUpPaddingAll,
    xLargeUp: customProperties.xLargeUpPaddingAll
};
const paddingXPropertyMap = {
    default: customProperties.paddingX,
    smallUp: customProperties.smallUpPaddingX,
    mediumUp: customProperties.mediumUpPaddingX,
    largeUp: customProperties.largeUpPaddingX,
    xLargeUp: customProperties.xLargeUpPaddingX
};
const paddingYPropertyMap = {
    default: customProperties.paddingY,
    smallUp: customProperties.smallUpPaddingY,
    mediumUp: customProperties.mediumUpPaddingY,
    largeUp: customProperties.largeUpPaddingY,
    xLargeUp: customProperties.xLargeUpPaddingY
};
const paddingTopPropertyMap = {
    default: customProperties.paddingTop,
    smallUp: customProperties.smallUpPaddingTop,
    mediumUp: customProperties.mediumUpPaddingTop,
    largeUp: customProperties.largeUpPaddingTop,
    xLargeUp: customProperties.xLargeUpPaddingTop
};
const paddingBottomPropertyMap = {
    default: customProperties.paddingBottom,
    smallUp: customProperties.smallUpPaddingBottom,
    mediumUp: customProperties.mediumUpPaddingBottom,
    largeUp: customProperties.largeUpPaddingBottom,
    xLargeUp: customProperties.xLargeUpPaddingBottom
};
const paddingStartPropertyMap = {
    default: customProperties.paddingStart,
    smallUp: customProperties.smallUpPaddingStart,
    mediumUp: customProperties.mediumUpPaddingStart,
    largeUp: customProperties.largeUpPaddingStart,
    xLargeUp: customProperties.xLargeUpPaddingStart
};
const paddingEndPropertyMap = {
    default: customProperties.paddingEnd,
    smallUp: customProperties.smallUpPaddingEnd,
    mediumUp: customProperties.mediumUpPaddingEnd,
    largeUp: customProperties.largeUpPaddingEnd,
    xLargeUp: customProperties.xLargeUpPaddingEnd
};
const getPaddingStyles = (padding, paddingX, paddingY, paddingTop, paddingBottom, paddingStart, paddingEnd)=>({
        ...(padding && generateStyle(paddingPropertyMap, padding, getSpaceValue)),
        ...(paddingX && generateStyle(paddingXPropertyMap, paddingX, getSpaceValue)),
        ...(paddingY && generateStyle(paddingYPropertyMap, paddingY, getSpaceValue)),
        ...(paddingTop && generateStyle(paddingTopPropertyMap, paddingTop, getSpaceValue)),
        ...(paddingBottom && generateStyle(paddingBottomPropertyMap, paddingBottom, getSpaceValue)),
        ...(paddingStart && generateStyle(paddingStartPropertyMap, paddingStart, getSpaceValue)),
        ...(paddingEnd && generateStyle(paddingEndPropertyMap, paddingEnd, getSpaceValue))
    });
const getItemSizeClassNames = (itemSize)=>itemSize !== 'intrinsic' ? styles.hasItemSize : undefined;
const itemSizePropertyMap = {
    default: customProperties.itemSize,
    smallUp: customProperties.smallUpItemSize,
    mediumUp: customProperties.mediumUpItemSize,
    largeUp: customProperties.largeUpItemSize,
    xLargeUp: customProperties.xLargeUpItemSize
};
const getItemSizeStyles = (itemSize)=>itemSize !== 'intrinsic' ? generateStyle(itemSizePropertyMap, itemSize, (value)=>value === 'intrinsic' ? 'auto' : value) : undefined;
export const ScrollableItem = React.memo(
    function ScrollableItem({ children, snapAlign: itemSnapAlign, size: itemSizeProp, role: roleProp, index }) {
        const { snapAlign: parentSnapAlign, role: carouselRole, itemSize: parentItemSize, focusScrollContainer, numberOfItems } = React.useContext(ScrollableItemsContext);
        const snapAlign = itemSnapAlign || parentSnapAlign;
        const itemSize = itemSizeProp || parentItemSize || 'intrinsic';
        const role = roleProp || (carouselRole === 'list' ? 'listitem' : undefined);
        const [inert, setInert] = React.useState(false);
        const itemRef = React.useRef(null);
        const itemClassName = classNames(styles.item, {
            [styles.snapItemCenter]: snapAlign === 'center',
            [styles.snapItemEnd]: snapAlign === 'end',
            [styles.snapItemNone]: snapAlign === 'none'
        }, getItemSizeClassNames(itemSize));
        const style = getItemSizeStyles(itemSize);
        const { ref: visibilityObserverRef } = useVisibilityObserver({
            onVisibilityChange: (isVisible)=>{
                setInert(!isVisible);
                const element = itemRef.current;
                if (!element || isVisible) return;
                if (element === document.activeElement || element.contains(document.activeElement))
                focusScrollContainer();
            }
        });
        return _jsx("div", {
            role: role,
            className: itemClassName,
            style: style,
            inert: inert,
            ref: composeRefs(itemRef, visibilityObserverRef),
            "aria-setsize": role === 'listitem' ? numberOfItems : undefined,
            "aria-posinset": role === 'listitem' && index != null ? index + 1 : undefined,
            children: children
        });
    }
);
export const ScrollableItemsCenterAlignSpacer = ()=>{
    const { itemSize } = React.useContext(ScrollableItemsContext);
    return _jsx("span", {
        className: classNames(styles.centerAlignSpacer, {
            [styles.hasItemSize]: itemSize != null
        }),
        style: itemSize != null ? getItemSizeStyles(itemSize) : undefined
    });
};
