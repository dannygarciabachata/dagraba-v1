import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { Preconditions } from '../../../../../base/preconditions';
import classNames from 'classnames';
import * as React from 'react';
import { useIsomorphicLayoutEffect } from '../../../hydration/use_isomorphic_layout_effect';
import { Layer, LayerLevel } from '../../../layer/layer';
import { isReferenceObject, ReferenceWrapper } from '../../internal/reference_wrapper';
import { useBackend } from './backend';
import styles from './pin.css';
export function Pin(
    { open, onOutsidePointerDown, blockOutsidePointerEvents = false, blockInsidePointerEvents = false, onOutsideContextMenu, onCalculateLayout, reference, placement = 'auto', enableFlip = true, enableShift = true, offset = {
        main: 0,
        cross: 0
    }, boundary = 'viewport', boundaryPadding = '1u', level = LayerLevel.PINS, parentLayer, children, ref }
) {
    const resolvedPlacement = useAutoPlacement(placement);
    const { placement: FixedPlacement, rtlAware } = typeof resolvedPlacement === 'string' ? {
        placement: resolvedPlacement,
        rtlAware: true
    } : resolvedPlacement;
    const { setReference: setBackendReference, contentProps: allContentProps, setArrow, update } = useBackend({
        placement: FixedPlacement,
        enableFlip,
        enableShift,
        rtlAware,
        offset,
        boundary,
        boundaryPadding,
        onCalculateLayout
    });
    const { className: contentClassName, ...contentProps } = allContentProps;
    React.useImperativeHandle(ref, ()=>({
            update
        }));
    const referenceWrapperRef = React.useRef(null);
    const referenceRef = React.useRef(null);
    const updateReferenceRefFromWrapperRef = React.useCallback(()=>{
        if (referenceWrapperRef.current == null)
            return;
        let children = referenceWrapperRef.current.children;
        while (children.length === 1 && window.getComputedStyle(children[0]).display === 'contents')
            children = children[0].children;
        Preconditions.checkState(children.length === 1, `ReactNode references must resolve to 1 DOM element, got ${children.length}. Consider using a ReferenceObject instead.`);
        referenceRef.current = children[0];
        setBackendReference(children[0]);
    }, [
        setBackendReference
    ]);
    useIsomorphicLayoutEffect(()=>{
        if (isReferenceObject(reference)) {
            referenceRef.current = reference;
            setBackendReference(reference);
        }
    }, [
        reference,
        setBackendReference
    ]);
    useIsomorphicLayoutEffect(()=>{
        if (!isReferenceObject(reference))
            updateReferenceRefFromWrapperRef();
    }, [
        reference,
        updateReferenceRefFromWrapperRef
    ]);
    React.useEffect(()=>{
        return ()=>{
            referenceRef.current = null;
            setBackendReference(null);
        };
    }, [
        setBackendReference
    ]);
    const onOutsideLayerPointerDown = React.useCallback(({ target })=>{
        onOutsidePointerDown?.({
            target: isTargetWithinOrRelatedToReference(target, referenceRef.current) ? 'reference' : 'other'
        });
    }, [
        onOutsidePointerDown
    ]);
    const maybeOnOutsidePointerDown = open && onOutsidePointerDown != null ? onOutsideLayerPointerDown : undefined;
    const onBackdropMouseDown = React.useCallback(()=>{
        if (!onOutsidePointerDown) return;
        window.setTimeout(()=>onOutsidePointerDown({
                target: 'other'
            }), 0);
    }, [
        onOutsidePointerDown
    ]);
    const onBackdropContextMenu = React.useCallback((e)=>{
        onOutsideContextMenu?.(e);
    }, [
        onOutsideContextMenu
    ]);
    const attachReferenceWrapperRef = React.useCallback((ref)=>{
        referenceWrapperRef.current = ref;
        updateReferenceRefFromWrapperRef();
    }, [
        updateReferenceRefFromWrapperRef
    ]);
    return _jsxs(_Fragment, {
        children: [
            _jsx(ReferenceWrapper, {
                ref: attachReferenceWrapperRef,
                content: reference
            }),
            open && _jsxs(Layer, {
                open: true,
                level: level,
                parentLayer: parentLayer,
                onOutsideLayerPointerDown: maybeOnOutsidePointerDown,
                children: [
                    blockOutsidePointerEvents &&
                    _jsx("div", {
                        className: styles.backdrop,
                        onMouseDown: onBackdropMouseDown,
                        onContextMenu: onBackdropContextMenu
                    }),
                    _jsx("div", {
                        className: classNames(contentClassName, {
                            [styles.blockInsidePointerEvents]: blockInsidePointerEvents
                        }),
                        ...contentProps,
                        children: typeof children === 'function' ? children({
                            setArrow
                        }) : children
                    })
                ]
            })
        ]
    });
}
function useAutoPlacement(placement) {
    if (placement !== 'auto') return placement;
    return 'bottom-start';
}
function isTargetWithinOrRelatedToReference(target, ref) {
    const Node = (ref?.ownerDocument?.defaultView ?? window).Node;
    if (!(target instanceof Node) || !(ref instanceof Node)) return false;
    if (ref.contains(target)) return true;
    if (!(target instanceof Element))
        return false;
    const label = target.closest('label');
    if (!label?.htmlFor) return false;
    const labeledElement = document.getElementById(label.htmlFor);
    return labeledElement != null && ref.contains(labeledElement);
}
