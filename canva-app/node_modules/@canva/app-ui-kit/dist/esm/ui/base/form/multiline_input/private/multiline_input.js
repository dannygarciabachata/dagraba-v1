import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { composeRefs } from '../../../../../base/react/compose_refs';
import classNames from 'classnames';
import { observer } from 'mobx-react-lite';
import * as React from 'react';
import ResizeObserver from 'resize-observer-polyfill';
import { useIsHoveringInput } from '../../../a11y/pointer_input_state/pointer_input_state';
import { useControllableValue } from '../../../controllable_value/controllable_value';
import { useFocusState, useOnWrapperClick } from '../../base_input/base_input';
import inputStyles from '../../base_input/temporary_exports.css';
import { BaseInputContextProvider, useCreateInputControls, usePropOverrides } from '../../internal/input';
import { useIsomorphicLayoutEffect } from '../../../hydration/use_isomorphic_layout_effect';
import styles from './multiline_input.css';
const DEFAULT_BUFFER_ROWS = 1;
const DEFAULT_MAX_ROWS = Number.POSITIVE_INFINITY;
function useAutoGrow(
    { bufferRows = DEFAULT_BUFFER_ROWS, maxRows = DEFAULT_MAX_ROWS, minRows = 1, value }
) {
    const innerRef = React.useRef(null);
    const [rows, setRows] = React.useState();
    const remeasure = React.useCallback(()=>{
        const refElement = innerRef.current;
        if (!refElement) return;
        const rowHeight = refElement.clientHeight;
        const contentRows = rowHeight === 0 ? 0 : Math.round(refElement.scrollHeight / rowHeight);
        const rows = Math.min(maxRows, Math.max(minRows + bufferRows, contentRows + bufferRows));
        setRows(rows);
    }, [
        bufferRows,
        maxRows,
        minRows
    ]);
    useIsomorphicLayoutEffect(remeasure, [
        remeasure,
        value
    ]);
    const stableRemeasure = React.useRef(remeasure);
    useIsomorphicLayoutEffect(()=>{
        stableRemeasure.current = remeasure;
    }, [
        remeasure
    ]);
    const observerRef = React.useRef(null);
    const setRef = React.useCallback((element)=>{
        if (observerRef.current == null)
            observerRef.current = new ResizeObserver(()=>stableRemeasure.current());
        if (innerRef.current != null)
            observerRef.current.unobserve(innerRef.current);
        innerRef.current = element;
        if (innerRef.current != null) observerRef.current.observe(innerRef.current);
    }, []);
    React.useEffect(()=>{
        return ()=>observerRef.current?.disconnect();
    }, []);
    return {
        ref: setRef,
        rows
    };
}
export const MultilineInput = observer(function MultilineInput({ ref, ...props_ }) {
    const { props, setPropOverrides } = usePropOverrides(props_);
    const { onChange: onChangeProp, onFocus: onFocusProp, onBlur: onBlurProp, onChangeComplete: onChangeCompleteProp, onKeyDown: onKeyDownProp, onRowsChange: onRowsChangeProp, dir = 'auto', autoGrow } = props;
    const { ref: inputRef, onClick: onWrapperClick } = useOnWrapperClick();
    const { isFocused, isKeyboardMode, setFocused } = useFocusState();
    const [value, setValue] = useControllableValue({
        value: props.value
    });
    const { ref: autoGrowRef, rows } = useAutoGrow({
        ...props,
        value
    });
    const controls = useCreateInputControls({
        focus: ()=>inputRef.current?.focus(),
        setDisabled: (disabled)=>setPropOverrides({
                disabled
            }),
        setValue: (value)=>{
            setValue(value);
            onChangeProp?.(value);
        }
    });
    const onChange = React.useCallback((e)=>{
        setValue(e.target.value);
        onChangeProp?.(e.target.value, e);
    }, [
        onChangeProp,
        setValue
    ]);
    const onFocus = React.useCallback((e)=>{
        onFocusProp?.(e);
        setFocused(true);
    }, [
        onFocusProp,
        setFocused
    ]);
    const onBlur = React.useCallback((e)=>{
        onBlurProp?.(e);
        onChangeCompleteProp?.(e.target.value);
        setFocused(false);
    }, [
        onBlurProp,
        onChangeCompleteProp,
        setFocused
    ]);
    const onKeyDown = React.useCallback((e)=>{
        if (e.keyCode === 229) {
            e.stopPropagation();
            return;
        }
        onKeyDownProp?.(e);
    }, [
        onKeyDownProp
    ]);
    React.useEffect(()=>{
        if (!autoGrow || onRowsChangeProp == null) return;
        rows !== undefined && onRowsChangeProp?.(rows);
    }, [
        rows,
        autoGrow,
        onRowsChangeProp
    ]);
    const hoverSupported = useIsHoveringInput();
    const wrapperClassName = classNames(inputStyles.wrapper, styles.multilineWrapper, {
        [inputStyles.hoverSupported]: hoverSupported,
        [inputStyles.focusOutline]: isFocused && isKeyboardMode,
        [inputStyles.borderless]: props.borderless
    }, props.disabled && inputStyles.disabled || isFocused && inputStyles.active || props.error && inputStyles.error, !props.autoGrow && props.resize && styles.resize, props.className);
    const inputClassName = classNames(inputStyles.textField, styles.multilineTextField, props.inputClassName);
    return (_jsx("div", {
            className: wrapperClassName,
            onMouseUp: onWrapperClick,
            children: _jsxs(BaseInputContextProvider, {
                controls: controls,
                value: value ?? '',
                children: [
                    _jsx("textarea", {
                        className: inputClassName,
                        value: value,
                        onChange: onChange,
                        onFocus: onFocus,
                        onBlur: onBlur,
                        onKeyPress: props.onKeyPress,
                        onKeyDown: onKeyDown,
                        onKeyUp: props.onKeyUp,
                        onPaste: props.onPaste,
                        onClick: props.onClick,
                        ref: composeRefs(inputRef, ref),
                        dir: dir,
                        autoComplete: props.autoComplete,
                        disabled: props.disabled,
                        placeholder: props.placeholder,
                        maxLength: props.maxLength,
                        lang: props.lang,
                        rows: rows ?? props.minRows,
                        id: props.id,
                        "aria-label": props.ariaLabel,
                        "aria-labelledby": props.ariaLabelledBy,
                        "aria-describedby": props.ariaDescribedBy,
                        "aria-invalid": props.error || undefined,
                        required: props.required,
                        readOnly: props.readOnly
                    }),
                    autoGrow && _jsx("textarea", {
                        "aria-hidden": "true",
                        className: classNames(inputClassName, styles.hiddenInput),
                        dir: dir,
                        ref: autoGrowRef,
                        readOnly: true,
                        rows: 1,
                        value: value
                    }),
                    props.footer
                ]
            })
        }));
});
MultilineInput.displayName = 'MultilineInput';
