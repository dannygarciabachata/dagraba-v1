import * as React from 'react';
import ResizeObserver from 'resize-observer-polyfill';
import { useIsomorphicLayoutEffect } from '../../hydration/use_isomorphic_layout_effect';
import { useRefEffect } from './ref_effect';
import styles, { customProperties } from './scroll_padding.css';
export function useScrollPaddingRefs() {
    const containerRef = React.useRef(null);
    useIsomorphicLayoutEffect(()=>{
        const container = containerRef.current;
        if (container == null) return;
        container.classList.add(styles.container);
        return ()=>container.classList.remove(styles.container);
    }, []);
    const setHeaderHeight = React.useCallback((height)=>{
        const container = containerRef.current;
        if (container == null) return;
        container.style.setProperty(customProperties.scrollPaddingTop, `${height}px`);
    }, []);
    const setFooterHeight = React.useCallback((height)=>{
        const container = containerRef.current;
        if (container == null) return;
        container.style.setProperty(customProperties.scrollPaddingBottom, `${height}px`);
    }, []);
    const headerRef = useElementScrollPadding(setHeaderHeight, styles.header);
    const footerRef = useElementScrollPadding(setFooterHeight, styles.footer);
    return {
        containerRef,
        headerRef,
        footerRef
    };
}
function useElementScrollPadding(callback, className) {
    const height = React.useRef(0);
    return useRefEffect((element)=>{
        element.classList.add(className);
        const observer = new ResizeObserver((entries)=>{
            const entry = entries[0];
            const currentHeight = entry.contentRect.height;
            if (currentHeight != null) {
                height.current = currentHeight;
                if (!element.contains(document.activeElement)) callback(currentHeight);
            }
        });
        observer.observe(element);
        function handleFocusChange() {
            callback(element.contains(document.activeElement) ? 0 : height.current);
        }
        element.addEventListener('focusin', handleFocusChange);
        element.addEventListener('focusout', handleFocusChange);
        return ()=>{
            element.classList.remove(className);
            observer.disconnect();
            element.removeEventListener('focusin', handleFocusChange);
            element.removeEventListener('focusout', handleFocusChange);
        };
    });
}
