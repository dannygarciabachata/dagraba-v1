import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { debounce } from '../../../../base/debounce';
import { composeRefs } from '../../../../base/react/compose_refs';
import * as React from 'react';
import { SkipLink, SkipTarget } from '../../a11y/skip_link/skip_link';
import { findFocusable } from '../../focus/focus';
import { unitSizeToNumber } from '../../metrics/metrics';
import { useResponsiveValue } from '../../responsive/use_responsive_value';
import { ProminentScrollButton as BaseProminentScrollButton, SubtleScrollButton as BaseSubtleScrollButton, useScrollButtonAriaLabel } from '../../scroll/scroll_button/scroll_button';
import { ScrollableItem, ScrollableItems, ScrollableItemsCenterAlignSpacer, scrollableItemsGaps } from '../../scroll/scrollable_items/scrollable_items';
import { ScrollWindow, WindowedList } from '../../scroll_controls/scroll_window';
import { useStableFunction } from '../../stable_function/stable_function';
import styles from './carousel.css';
import { CarouselMessages } from './carousel.messages';
export { useScrollButtonAriaLabel };
export const ProminentScrollButton = (props)=>{
    return _jsx(BaseProminentScrollButton, {
        position: "bounded",
        ...props
    });
};
export const SubtleScrollButton = (props)=>{
    return _jsx(BaseSubtleScrollButton, {
        position: "bounded",
        ...props
    });
};
export const carouselGaps = scrollableItemsGaps;
export const Carousel = React.memo(
    function Carousel({ role, ariaLabel, ariaLabelledBy, ariaDescribedBy, ariaSetSize, children, onScroll: onScrollProp, onScrollStateChange: onScrollStateChangeProp, scrollableRef, scrollHandleRef, padding, paddingX, paddingY, paddingTop, paddingBottom, paddingStart, paddingEnd, gap = '2u', snap = 'proximity', snapAlign = 'start', virtualization, skipLinksScrollMarginTop, disableSkipLinks = true, outOfViewItemBehavior = 'inert', fadeSize = '6u', itemWidth = 'intrinsic', scrollButton = (props)=> _jsx(ProminentScrollButton, {
            ...props
        }) }) {
        const prevButtonHandle = React.useRef(null);
        const nextButtonHandle = React.useRef(null);
        const carouselId = React.useId();
        const responsiveGap = typeof gap === 'object' ? gap : {
            default: gap
        };
        const gapValue = useResponsiveValue(responsiveGap);
        const gapInPixel = unitSizeToNumber(gapValue);
        const itemWidths = virtualization ? Array.isArray(virtualization.itemWidths) ? virtualization.itemWidths : new Array(React.Children.count(children)).fill(virtualization.itemWidths) : undefined;
        const getItemWidth = React.useCallback((index)=>{
            if (itemWidths) return itemWidths[index];
            return 0;
        }, [
            itemWidths
        ]);
        const scrollableItemsHandle = React.useRef(null);
        React.useImperativeHandle(scrollHandleRef, ()=>{
            return mapScrollHandle(scrollableItemsHandle);
        });
        const [atStart, setAtStart] = React.useState(true);
        const [atEnd, setAtEnd] = React.useState(true);
        const onScrollStateChange = useStableFunction((scrollableItemsState)=>{
            const state = mapScrollState(scrollableItemsState);
            onScrollStateChangeProp?.(state);
            setAtStart(state.atStart);
            setAtEnd(state.atEnd);
        });
        const onScroll = useStableFunction((state)=>{
            onScrollProp?.(mapScrollState(state));
        });
        const { ref: focusManagementRef, onFocus, focusNextItem, focusPreviousItem } = useCarouselFocusManagement();
        const scrollableItemsProps = {
            id: carouselId,
            onFocus,
            direction: 'horizontal',
            ref: scrollableItemsHandle,
            onScrollStateChange,
            onScroll,
            snap,
            snapAlign,
            padding,
            paddingX,
            paddingY,
            paddingTop,
            paddingBottom,
            paddingStart,
            paddingEnd,
            gap,
            fadeSize,
            role,
            ariaLabel,
            ariaLabelledBy,
            ariaDescribedBy,
            ariaSetSize,
            outOfViewItemBehavior
        };
        const scrollToPreviousPage = React.useCallback(()=>{
            scrollableItemsHandle.current?.scrollByPage({
                x: -1
            });
        }, [
            scrollableItemsHandle
        ]);
        const scrollToNextPage = React.useCallback(()=>{
            scrollableItemsHandle.current?.scrollByPage({
                x: 1
            });
        }, [
            scrollableItemsHandle
        ]);
        const containerRef = React.useRef(null);
        return _jsx("div", {
            className: styles.carouselContainer,
            ref: containerRef,
            tabIndex: -1,
            children: _jsxs(CarouselSkipLinks, {
                carouselName: ariaLabel,
                disableSkipLinks: disableSkipLinks,
                scrollMarginTop: skipLinksScrollMarginTop,
                children: [
                    scrollButton({
                        scrollableId: carouselId,
                        direction: 'backward',
                        onClick: ()=>{
                            if (outOfViewItemBehavior === 'inert') {
                                containerRef.current?.focus();
                                onScrollEnd(focusManagementRef.current, focusPreviousItem, {
                                    once: true
                                });
                            }
                            scrollToPreviousPage();
                        },
                        atStart,
                        atEnd,
                        buttonHandle: prevButtonHandle,
                        oppositeButtonHandle: nextButtonHandle,
                        ariaLabel,
                        ariaLabelledBy
                    }),
                    virtualization ? _jsx(ScrollWindow, {
                        innerRef: scrollableRef,
                        layout: "horizontal",
                        children: ({ scrollableRef: scrollWindowRef, scrollState: windowScrollState })=>_jsx(ScrollableItems, {
                                scrollableRef: composeRefs(scrollWindowRef, focusManagementRef),
                                getItemWidth: getItemWidth,
                                itemCount: itemWidths.length,
                                ...scrollableItemsProps,
                                children: _jsx(VirtualizedChildren, {
                                    virtualization: virtualization,
                                    scrollState: windowScrollState,
                                    itemWidths: itemWidths,
                                    itemGap: gapInPixel,
                                    children: children,
                                    snap: snap
                                })
                            })
                    }) : _jsx(ScrollableItems, {
                        scrollableRef: composeRefs(scrollableRef, focusManagementRef),
                        itemSize: itemWidth,
                        ...scrollableItemsProps,
                        children: children
                    }),
                    scrollButton({
                        scrollableId: carouselId,
                        direction: 'forward',
                        onClick: ()=>{
                            if (outOfViewItemBehavior === 'inert') {
                                containerRef.current?.focus();
                                onScrollEnd(focusManagementRef.current, focusNextItem, {
                                    once: true
                                });
                            }
                            scrollToNextPage();
                        },
                        atStart,
                        atEnd,
                        buttonHandle: nextButtonHandle,
                        oppositeButtonHandle: prevButtonHandle,
                        ariaLabel,
                        ariaLabelledBy
                    })
                ]
            })
        });
    }
);
const mapScrollState = (scrollableItemsState)=>{
    const itemState = scrollableItemsState.itemX;
    const pageState = scrollableItemsState.pageX;
    return {
        x: scrollableItemsState.x,
        currentItemIndex: itemState?.currentItemIndex,
        numberOfItems: itemState?.numberOfItems,
        currentPageIndex: pageState?.currentPageIndex,
        numberOfPages: pageState?.numberOfPages,
        scrollable: scrollableItemsState.scrollableX,
        containerWidth: scrollableItemsState.containerWidth,
        containerHeight: scrollableItemsState.containerHeight,
        scrollWidth: scrollableItemsState.scrollWidth,
        scrollHeight: scrollableItemsState.scrollHeight,
        atStart: scrollableItemsState.atStart,
        atEnd: scrollableItemsState.atEnd
    };
};
const mapScrollHandle = (scrollableItemsHandle)=>{
    const handle = scrollableItemsHandle?.current;
    return {
        getScrollState: ()=>{
            const state = handle?.getScrollState();
            return state ? mapScrollState(state) : undefined;
        },
        scrollTo: (to, options)=>handle?.scrollTo({
                x: to,
                ...options
            }),
        scrollBy: (by, options)=>handle?.scrollBy({
                x: by,
                ...options
            }),
        scrollToPage: (to, options)=>handle?.scrollToPage({
                x: to,
                ...options
            }),
        scrollByPage: (by, options)=>handle?.scrollByPage({
                x: by,
                ...options
            }),
        scrollToItem: (to, options)=>handle?.scrollToItem({
                x: to,
                ...options
            }),
        scrollByItem: (by, options)=>handle?.scrollByItem({
                x: by,
                ...options
            })
    };
};
export const CarouselItem = ({ width, ...props })=>{
    return _jsx(ScrollableItem, {
        ...props,
        size: width
    });
};
export const CarouselCenterAlignSpacer = ()=>{
    return _jsx(ScrollableItemsCenterAlignSpacer, {});
};
const Spacer = React.memo(function Spacer({ width }) {
    return _jsx("span", {
        className: styles.spacer,
        style: {
            width
        }
    });
});
export const CarouselSkipLinks = React.memo(
    function CarouselSkipLinks({ carouselName, children, scrollMarginTop, disableSkipLinks }) {
        const idStart = React.useId();
        const idEnd = React.useId();
        if (disableSkipLinks) return children;
        return _jsxs(_Fragment, {
            children: [
                _jsx(SkipTarget, {
                    id: idStart,
                    scrollMarginTop: scrollMarginTop,
                    label: carouselName ? CarouselMessages.namedListStart(carouselName) : CarouselMessages.listStart()
                }),
                _jsx(SkipLink, {
                    to: idEnd,
                    position: "top",
                    children: carouselName ? CarouselMessages.skipToNamedListEnd(carouselName) : CarouselMessages.skipToEnd()
                }),
                children,
                _jsx(SkipLink, {
                    to: idStart,
                    position: "bottom",
                    children: carouselName ? CarouselMessages.skipToNamedListStart(carouselName) : CarouselMessages.skipToStart()
                }),
                _jsx(SkipTarget, {
                    id: idEnd,
                    scrollMarginTop: scrollMarginTop,
                    label: carouselName ? CarouselMessages.namedListEnd(carouselName) : CarouselMessages.listEnd()
                })
            ]
        });
    }
);
const VirtualizedChildren = React.memo(
    function VirtualizedChildren({ scrollState, virtualization, itemWidths, itemGap = 0, children, snap }) {
        const itemWidthsWithGap = React.useMemo(()=>{
            const value = itemGap > 0 ? itemWidths.map((width)=>width + itemGap) : itemWidths;
            if (itemGap > 0 && value.length > 0) value[value.length - 1] -= itemGap;
            return value;
        }, [
            itemGap,
            itemWidths
        ]);
        return _jsx(WindowedList, {
            scrollState: scrollState,
            itemSizes: itemWidthsWithGap,
            overscan: virtualization.overscan,
            children: (windowedListState, itemPositions)=>{
                const { firstVisible, lastVisible } = windowedListState ?? {
                    firstVisible: 0,
                    lastVisible: Math.min(virtualization.initialRender ?? 1, itemPositions.length - 1)
                };
                if (snap !== 'none')
                return React.Children.map(children, (child, index)=>{
                    const width = Array.isArray(virtualization.itemWidths) ? virtualization.itemWidths[index] : virtualization.itemWidths;
                    return firstVisible <= index && index < lastVisible ? child : _jsx(CarouselItem, {
                        index: index,
                        children: _jsx(Spacer, {
                            width: width
                        })
                    });
                });
                const spaceBeforeWithTrailingGap = itemPositions[firstVisible];
                const spaceBefore = spaceBeforeWithTrailingGap === 0 ? 0 : spaceBeforeWithTrailingGap - itemGap;
                const spaceAfter = itemPositions[itemPositions.length - 1] - itemPositions[lastVisible];
                return _jsxs(_Fragment, {
                    children: [
                        spaceBefore !== 0 && _jsx(Spacer, {
                            width: spaceBefore
                        }),
                        React.Children.toArray(children).slice(firstVisible, lastVisible),
                        spaceAfter !== 0 && _jsx(Spacer, {
                            width: spaceAfter
                        })
                    ]
                });
            }
        });
    }
);
function onScrollEnd(element, listener, options = {}) {
    if (!element || !listener) return;
    const { once, debounceMs = 50 } = options;
    const wrappedCallback = ()=>{
        listener();
        once && element.removeEventListener('scroll', onScroll);
    };
    const onScroll = debounce(wrappedCallback, debounceMs);
    element.addEventListener('scroll', onScroll);
}
function useCarouselFocusManagement() {
    const scrollContainerRef = React.useRef(null);
    const lastFocusedItemRef = React.useRef(null);
    const onFocus = React.useEffectEvent((e)=>{
        let el = e.target;
        while(el?.parentElement != null && el.parentElement !== scrollContainerRef.current)el = el.parentElement;
        lastFocusedItemRef.current = el;
    });
    const focusNextItem = React.useEffectEvent(()=>{
        if (!lastFocusedItemRef.current || lastFocusedItemRef.current.inert) focusFirstVisibleItem(scrollContainerRef.current);
        else findFocusable(lastFocusedItemRef.current)?.focus({
            preventScroll: true
        });
    });
    const focusPreviousItem = React.useEffectEvent(()=>{
        if (!lastFocusedItemRef.current || lastFocusedItemRef.current.inert) focusLastVisibleItem(scrollContainerRef.current);
        else findFocusable(lastFocusedItemRef.current)?.focus({
            preventScroll: true
        });
    });
    return {
        ref: scrollContainerRef,
        onFocus,
        focusNextItem,
        focusPreviousItem
    };
}
function focusFirstVisibleItem(container) {
    if (container == null) return;
    let firstVisibleItem = null;
    for(let i = 0; i < container.children.length - 1; i++){
        const child = container.children.item(i);
        if (child?.getAttribute('inert') == null) {
            firstVisibleItem = child;
            break;
        }
    }
    firstVisibleItem && findFocusable(firstVisibleItem)?.focus({
        preventScroll: true
    });
}
function focusLastVisibleItem(container) {
    if (container == null) return;
    let lastVisibleItem = null;
    for(let i = container.children.length - 1; i > 0; i--){
        const child = container.children.item(i);
        if (child?.getAttribute('inert') == null) {
            lastVisibleItem = child;
            break;
        }
    }
    lastVisibleItem && findFocusable(lastVisibleItem)?.focus({
        preventScroll: true
    });
}
