import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { composeRefs } from '../../../../../base/react/compose_refs';
import classNames from 'classnames';
import * as React from 'react';
import { useAnnouncer } from '../../../a11y/announcer/announcer';
import { ScreenReaderContent } from '../../../a11y/screen_reader_content/screen_reader_content';
import { Box } from '../../../box/box';
import { BaseButton } from '../../../button/base_button/base_button';
import { Divider } from '../../../divider/divider';
import { FakeCheckbox } from '../../checkbox/checkbox';
import { CheckIcon } from '../../../icons/check/icon';
import { ChevronDownIcon } from '../../../icons/chevron_down/icon';
import { Rows, Spacer } from '../../../layout/layout';
import { DIVIDER_HEIGHT_MULTIPIER, ITEM_HEIGHT_MULTIPIER, Menu as BaseMenu, MenuDivider, MenuItem, TEXT_DIVIDER_HEIGHT_MULTIPIER } from '../../../menu/menu';
import { baseUnit, getRootFontSize, useTextZoomBaseUnit } from '../../../metrics/metrics';
import { isAboveView, isBelowView, scrollIntoView } from '../../../scroll/scroll';
import { ScrollWindow, WindowedList } from '../../../scroll_controls/scroll_window';
import { Popover } from '../../../surface/popover/popover';
import { Sheet, useTypicalSheetAdaptation } from '../../../surface/sheet/sheet';
import colorTokens from '../../../tokens/color.css';
import { InheritColor, Text } from '../../../typography/typography';
import styles from './base_select.css';
import { BaseSelectMessages } from './base_select.messages';
import { defaultAreEqual, defaultGetLabel, defaultIsSelected, deriveIdentifier, flattenOptions, joinLabels, normalizeOptionGroups, sliceOptionGroups } from './base_select_util';
import { TruncatedList } from './truncated_list';
const DEFAULT_FLYOUT_WIDTH_UNITS = '40u';
const DEFAULT_FLYOUT_WIDTH = parseInt(DEFAULT_FLYOUT_WIDTH_UNITS, 10) * baseUnit;
export function StatelessBaseSelect(props) {
    const { Trigger = BaseSelectTrigger, Menu = BaseSelectMenu, Item, Flyout = WrappedFlyout, trigger = (props)=> _jsx(Trigger, {
            ...props
        }), menu = (props)=> _jsx(Menu, {
            ...props
        }), item, value, placeholder, open, disabled, error, stretch, activeIndex, options, focusOnMenu = false, flyoutPlacement = 'bottom-start', flyoutWidth: flyoutWidthProp, blockOutsidePointerEvents, id, ariaLabelledBy, ariaDescribedBy, tooltipLabel, tooltipPlacement, tooltipDisabled, className, onRequestClose, onRequestOpen, onBlur, onFocus, onItemClick, onItemHover, areEqual = defaultAreEqual, isSelected = defaultIsSelected, getLabel = defaultGetLabel } = props;
    const menuId = React.useId();
    const labelId = React.useId();
    const sizingMode = useTypicalSheetAdaptation() ? 'fill' : 'fixed';
    const triggerContainerRef = React.useRef(null);
    const menuContainerRef = React.useRef(null);
    const flatOptions = React.useMemo(()=>props.flatOptions ?? flattenOptions(props.options), [
        props.options,
        props.flatOptions
    ]);
    const optionGroups = React.useMemo(()=>props.optionGroups ?? normalizeOptionGroups(props.options), [
        props.options,
        props.optionGroups
    ]);
    const selectedOptions = React.useMemo(()=>props.selectedOptions ?? flatOptions.filter((option)=>isSelected(option, value)), [
        flatOptions,
        props.selectedOptions,
        isSelected,
        value
    ]);
    const activeDescendantId = deriveIdentifier(menuId, activeIndex);
    const ariaLabel = props.ariaLabel ?? (!ariaLabelledBy && typeof props.title === 'string' ? props.title : undefined);
    const [flyoutWidth, setFlyoutWidth] = React.useState(flyoutWidthProp ?? DEFAULT_FLYOUT_WIDTH_UNITS);
    const onRequestToggle = React.useCallback(()=>{
        if (open) onRequestClose();
        else onRequestOpen();
    }, [
        open,
        onRequestClose,
        onRequestOpen
    ]);
    React.useEffect(()=>{
        if (!stretch || flyoutWidthProp != null) {
            setFlyoutWidth(flyoutWidthProp ?? DEFAULT_FLYOUT_WIDTH_UNITS);
            return;
        }
        const triggerWidth = triggerContainerRef.current?.getBoundingClientRect().width ?? 0;
        const width = triggerWidth < DEFAULT_FLYOUT_WIDTH ? DEFAULT_FLYOUT_WIDTH_UNITS : 'trigger';
        setFlyoutWidth(width);
    }, [
        flyoutWidthProp,
        stretch
    ]);
    return _jsx(Flyout, {
        placement: flyoutPlacement,
        open: open ?? false,
        onRequestClose: onRequestClose,
        captureFocus: focusOnMenu,
        width: flyoutWidth,
        title: props.title,
        headerEnd: props.headerEnd,
        headerDivider: "always",
        blockOutsidePointerEvents: blockOutsidePointerEvents,
        trigger: _jsx("div", {
            ref: composeRefs(triggerContainerRef, props.triggerContainerRef),
            className: classNames(styles.triggerContainer, className, {
                [styles.triggerStretch]: stretch
            }),
            children: trigger({
                value,
                options,
                flatOptions,
                optionGroups,
                selectedOptions,
                placeholder,
                disabled,
                error,
                open,
                id,
                ariaLabel,
                ariaLabelledBy,
                ariaDescribedBy,
                activeIndex,
                onBlur,
                onFocus,
                role: 'combobox',
                disclosure: true,
                labelId,
                active: open,
                ariaActiveDescendant: activeDescendantId,
                ariaControls: menuId,
                onRequestToggle,
                getLabel,
                isSelected,
                tooltipLabel,
                tooltipPlacement,
                tooltipDisabled
            })
        }),
        children: _jsx("div", {
            className: styles.menuContainer,
            ref: composeRefs(menuContainerRef, props.menuContainerRef),
            children: menu({
                Item,
                item,
                id: menuId,
                options,
                flatOptions,
                optionGroups,
                selectedOptions,
                value,
                activeIndex,
                activeOption: flatOptions[activeIndex ?? -1],
                onItemClick,
                onItemHover,
                areEqual,
                isSelected,
                getLabel,
                sizingMode,
                menuContainerRef,
                ariaLabel,
                ariaLabelledBy,
                children: options.length === 0 ? renderEmptyMenuContent() : undefined
            })
        })
    });
}
export function BaseSelectTrigger(props) {
    const { selectedOptions } = props;
    const noSelection = !selectedOptions.length;
    const Icon = getIcon(props.Icon ?? 'auto', selectedOptions[0]?.Icon);
    const ariaLabelledBy = props.ariaLabelledBy || (props.ariaLabel ? undefined : props.labelId);
    const ariaDescribedBy = getTriggerAriaDescribedBy(props);
    return _jsxs(BaseButton, {
        onClick: props.onRequestToggle,
        onBlur: props.onBlur,
        onFocus: props.onFocus,
        disclosure: true,
        pressed: props.open,
        disabled: props.disabled,
        className: classNames(styles.triggerButton, props.className),
        id: props.id,
        role: props.role,
        tooltipLabel: props.tooltipLabel,
        tooltipPlacement: props.tooltipPlacement,
        tooltipDisabled: props.tooltipDisabled,
        ariaLabel: props.ariaLabel,
        ariaLabelledBy: ariaLabelledBy,
        ariaDescribedBy: ariaDescribedBy,
        ariaControls: props.ariaControls,
        ariaHasPopup: "listbox",
        ariaActiveDescendant: props.ariaActiveDescendant,
        ariaInvalid: props.error,
        borderRadius: "element",
        paddingX: "1.5u",
        alignItems: "center",
        width: "full",
        border: "standard",
        tone: "secondary",
        backgroundColor: {
            default: colorTokens.colorControlBg,
            pressed: colorTokens.colorControlBg,
            hovered: colorTokens.colorControlBg,
            disabled: colorTokens.colorControlBgDisabled
        },
        borderColor: {
            default: props.error ? colorTokens.colorControlCriticalBorder : colorTokens.colorControlBorder,
            pressed: colorTokens.colorControlBorderFocused,
            hovered: colorTokens.colorControlBorderHovered,
            disabled: colorTokens.colorControlBorderDisabled
        },
        children: [
            Icon && _jsxs(_Fragment, {
                children: [
                    _jsx(Icon, {
                        size: "medium"
                    }),
                    _jsx(Spacer, {
                        size: "1u"
                    })
                ]
            }),
            _jsx(Text, {
                id: props.labelId,
                tagName: "span",
                lineClamp: 1,
                tone: InheritColor,
                className: classNames(styles.label, {
                    [styles.placeholder]: noSelection || props.disabled
                }),
                children: getTriggerContent(props)
            }),
            _jsx(ChevronDownIcon, {
                size: "medium"
            })
        ]
    });
}
function getIcon(Icon, FallbackIcon) {
    if (Icon === 'none') return undefined;
    if (Icon === 'auto') return FallbackIcon;
    return Icon;
}
function getTriggerContent(props) {
    if (props.children) return props.children;
    const hasSelection = props.selectedOptions.length > 0;
    if (!hasSelection && props.disabled)
    return _jsxs(_Fragment, {
        children: [
            _jsx(ScreenReaderContent, {
                tagName: "span",
                children: BaseSelectMessages.defaultDisabledMessage()
            }),
            _jsx("span", {
                "aria-hidden": true,
                children: props.placeholder ?? BaseSelectMessages.defaultPlaceholder()
            })
        ]
    });
    if (!hasSelection)
    return _jsxs(_Fragment, {
        children: [
            _jsx(ScreenReaderContent, {
                tagName: "span",
                children: BaseSelectMessages.defaultNoSelectionMessage()
            }),
            _jsx("span", {
                "aria-hidden": true,
                id: `${props.labelId}--placeholder`,
                children: props.placeholder ?? BaseSelectMessages.defaultPlaceholder()
            })
        ]
    });
    const items = props.selectedOptions.map(props.getLabel);
    if (items.length > 1 && items.every((item)=>typeof item === 'string')) return _jsx(TruncatedList, {
        tagName: "span",
        items: items
    });
    return joinLabels(items);
}
function getTriggerAriaDescribedBy(props) {
    if (props.children)
    return props.ariaDescribedBy;
    const hasSelection = props.selectedOptions.length > 0;
    if (!hasSelection) return `${props.ariaDescribedBy ?? ''} ${props.labelId}--placeholder`.trim();
    return props.ariaDescribedBy;
}
function useScrollToActiveItem({ activeIndex }) {
    const scrollRef = React.useRef(null);
    const activeItemRef = React.useRef(null);
    React.useEffect(()=>{
        if (!scrollRef.current || !activeItemRef.current) return;
        if (isAboveView(scrollRef.current, activeItemRef.current)) scrollIntoView(scrollRef.current, activeItemRef.current, {
            align: 'start'
        });
        if (isBelowView(scrollRef.current, activeItemRef.current)) scrollIntoView(scrollRef.current, activeItemRef.current, {
            align: 'end'
        });
    }, [
        activeIndex,
        scrollRef
    ]);
    return {
        scrollRef,
        activeItemRef
    };
}
export function BaseSelectMenu(props) {
    const { Item = BaseSelectItem, item = (props)=> _jsx(Item, {
            ...props
        }), flatOptions, optionGroups, value, activeIndex, id, ariaLabel, ariaLabelledBy, header, footer, isSelected, getLabel, onItemClick, onItemHover, className, children, sizingMode } = props;
    const { scrollRef, activeItemRef } = useScrollToActiveItem({
        activeIndex
    });
    const hasMultipleGroups = optionGroups.length > 1;
    const announcer = useAnnouncer();
    const announcerRef = React.useRef(null);
    const announcedContent = React.useRef('');
    const shouldAnnounce = !!children;
    React.useEffect(()=>{
        if (!shouldAnnounce) return;
        const textContent = announcerRef.current?.textContent ?? '';
        if (textContent === announcedContent.current) return;
        announcedContent.current = textContent;
        announcer.announce(textContent);
    }, [
        announcer,
        shouldAnnounce,
        children
    ]);
    return _jsx(WithHeaderAndFooter, {
        header: header,
        footer: footer,
        children: _jsx("div", {
            className: classNames(styles.scrollContainer, sizingMode === 'fixed' && styles.popover, className),
            ref: scrollRef,
            id: hasMultipleGroups ? id : undefined,
            role: hasMultipleGroups ? 'listbox' : undefined,
            "aria-label": hasMultipleGroups ? ariaLabel : undefined,
            "aria-labelledby": hasMultipleGroups ? ariaLabelledBy : undefined,
            children: children ? _jsx("div", {
                ref: announcerRef,
                children: children
            }) : optionGroups.map((optionGroup, groupIndex)=>_jsxs(React.Fragment, {
                    children: [
                        groupIndex > 0 && _jsx("div", {
                            className: styles.groupDivider,
                            children: _jsx(Divider, {})
                        }),
                        _jsx(OptionGroup, {
                            item: item,
                            menuId: id,
                            id: hasMultipleGroups ? undefined : id,
                            role: hasMultipleGroups ? 'group' : 'listbox',
                            ariaLabel: hasMultipleGroups ? undefined : ariaLabel,
                            ariaLabelledBy: hasMultipleGroups ? undefined : ariaLabelledBy,
                            activeItemRef: activeItemRef,
                            value: value,
                            optionIndexOffset: flatOptions.findIndex((o)=>o === optionGroup.options[0]),
                            activeIndex: activeIndex,
                            label: optionGroup.label,
                            options: optionGroup.options,
                            isSelected: isSelected,
                            onItemClick: onItemClick,
                            onItemHover: onItemHover,
                            getLabel: getLabel
                        })
                    ]
                }, groupIndex))
        })
    });
}
function OptionGroup({ item = (props)=> _jsx(BaseSelectItem, {
        ...props
    }), id, menuId, role, ariaLabel, ariaLabelledBy, value, optionIndexOffset = 0, activeIndex, label, options, isSelected, activeItemRef, onItemClick, onItemHover, getLabel }) {
    const headingId = React.useId();
    const multiSelectable = Array.isArray(value);
    return _jsxs(BaseMenu, {
        id: id,
        role: role,
        ariaMultiSelectable: multiSelectable,
        ariaLabel: ariaLabel,
        ariaLabelledBy: label ? headingId : ariaLabelledBy,
        children: [
            label != null && _jsx(MenuDivider, {
                id: headingId,
                children: label
            }),
            options.map((option, i)=>{
                const selected = isSelected(option, value);
                const itemIndex = optionIndexOffset + i;
                const active = activeIndex === itemIndex;
                const id = deriveIdentifier(menuId, itemIndex);
                return _jsx(React.Fragment, {
                    children: item({
                        id,
                        selected,
                        active,
                        forwardedRef: active ? activeItemRef : undefined,
                        onItemClick,
                        onItemHover,
                        getLabel,
                        option,
                        multiSelectable
                    })
                }, id);
            })
        ]
    });
}
export function WindowedSelectMenu(props) {
    const { Item = BaseSelectItem, item = (props)=> _jsx(Item, {
            ...props
        }), optionGroups, flatOptions, value, activeIndex, id, ariaLabel, ariaLabelledBy, header, footer, isSelected, getLabel, onItemClick, onItemHover, className, children, sizingMode, itemHeightMultiplier = ITEM_HEIGHT_MULTIPIER } = props;
    const rootFontSize = React.useMemo(()=>{
        return getRootFontSize();
    }, []);
    const textZoomBaseUnit = useTextZoomBaseUnit(rootFontSize);
    const itemSizes = React.useMemo(()=>{
        const itemSizes = [];
        optionGroups.forEach((optionGroup, groupIndex)=>{
            optionGroup.options.forEach((option, optionIndex)=>{
                let height = itemHeightMultiplier * textZoomBaseUnit;
                if (optionIndex === 0 && groupIndex > 0)
                    height += DIVIDER_HEIGHT_MULTIPIER * textZoomBaseUnit;
                if (optionIndex === 0 && optionGroup.label != null)
                    height += TEXT_DIVIDER_HEIGHT_MULTIPIER * textZoomBaseUnit;
                itemSizes.push(height);
            });
        });
        return itemSizes;
    }, [
        itemHeightMultiplier,
        optionGroups,
        textZoomBaseUnit
    ]);
    const { scrollRef, activeItemRef } = useScrollToActiveItem({
        activeIndex
    });
    React.useEffect(()=>{
        if (!scrollRef.current || activeIndex == null || activeIndex < 5)
            return;
        const activeOptionHeight = itemSizes[activeIndex];
        const activeOptionPosition = itemSizes.slice(0, activeIndex).reduce((a, h)=>a + h);
        const paddingTop = parseInt(window.getComputedStyle(scrollRef.current).paddingTop, 10);
        const scrollOffset = scrollRef.current.offsetHeight - paddingTop - activeOptionHeight;
        scrollRef.current.scrollTop = activeOptionPosition - scrollOffset;
    }, []);
    const hasMultipleGroups = optionGroups.length > 1;
    return _jsx(WithHeaderAndFooter, {
        header: header,
        footer: footer,
        children: _jsx(ScrollWindow, {
            layout: "vertical",
            children: ({ scrollableRef, scrollState })=>_jsx("div", {
                    className: classNames(styles.scrollContainer, sizingMode === 'fixed' && styles.popover, className),
                    ref: composeRefs(scrollableRef, scrollRef),
                    id: hasMultipleGroups ? id : undefined,
                    role: hasMultipleGroups ? 'listbox' : undefined,
                    "aria-label": hasMultipleGroups ? ariaLabel : undefined,
                    "aria-labelledby": hasMultipleGroups ? ariaLabelledBy : undefined,
                    children: children ? _jsx("div", {
                        role: "alert",
                        children: children
                    }) : _jsx(WindowedList, {
                        scrollState: scrollState,
                        itemSizes: itemSizes,
                        overscan: 2,
                        children: (state, itemPositions)=>{
                            if (!state) return _jsx("div", {
                                role: "none",
                                style: {
                                    height: itemPositions[itemPositions.length - 1]
                                }
                            });
                            const { firstVisible, lastVisible } = state;
                            const spaceBefore = itemPositions[firstVisible];
                            const spaceAfter = itemPositions[itemPositions.length - 1] - itemPositions[lastVisible];
                            const visibleGroups = sliceOptionGroups(optionGroups, firstVisible, lastVisible);
                            return _jsxs(_Fragment, {
                                children: [
                                    _jsx("div", {
                                        role: "none",
                                        style: {
                                            height: spaceBefore
                                        }
                                    }),
                                    visibleGroups.map((optionGroup)=>{
                                        const isFirstItemVisible = optionGroup.slice[0] === 0;
                                        return _jsxs(React.Fragment, {
                                            children: [
                                                optionGroup.originalIndex > 0 && isFirstItemVisible && _jsx("div", {
                                                    className: styles.groupDivider,
                                                    children: _jsx(Divider, {})
                                                }),
                                                _jsx(OptionGroup, {
                                                    item: item,
                                                    menuId: id,
                                                    id: hasMultipleGroups ? undefined : id,
                                                    role: hasMultipleGroups ? 'group' : 'listbox',
                                                    ariaLabel: hasMultipleGroups ? optionGroup.label : ariaLabel,
                                                    ariaLabelledBy: hasMultipleGroups ? undefined : ariaLabelledBy,
                                                    activeItemRef: activeItemRef,
                                                    value: value,
                                                    optionIndexOffset: flatOptions.findIndex((o)=>o === optionGroup.options[0]),
                                                    activeIndex: activeIndex,
                                                    label: isFirstItemVisible ? optionGroup.label : undefined,
                                                    options: optionGroup.options,
                                                    isSelected: isSelected,
                                                    onItemClick: onItemClick,
                                                    onItemHover: onItemHover,
                                                    getLabel: getLabel
                                                })
                                            ]
                                        }, optionGroup.originalIndex);
                                    }),
                                    _jsx("div", {
                                        role: "none",
                                        style: {
                                            height: spaceAfter
                                        }
                                    })
                                ]
                            });
                        }
                    })
                })
        })
    });
}
function WithHeaderAndFooter(props) {
    const { header, footer, children } = props;
    return _jsxs(_Fragment, {
        children: [
            header && _jsx("header", {
                className: styles.menuHeader,
                children: typeof header === 'string' ? _jsx(Text, {
                    children: header
                }) : header
            }),
            children,
            footer && _jsx("footer", {
                className: styles.menuFooter,
                children: typeof footer === 'string' ? _jsx(Text, {
                    children: footer
                }) : footer
            })
        ]
    });
}
export function renderEmptyMenuContent() {
    return _jsx(Box, {
        padding: "3u",
        children: _jsx(Text, {
            children: BaseSelectMessages.defaultEmptyMessage()
        })
    });
}
export const BaseSelectItem = React.memo(BaseSelectItem_);
function BaseSelectItem_(props) {
    const { onItemClick, onItemHover, option, multiSelectable } = props;
    const onClick = React.useCallback((event)=>{
        onItemClick?.(option, event);
    }, [
        onItemClick,
        option
    ]);
    const onMouseEnter = React.useCallback((event)=>{
        onItemHover?.(option, event);
    }, [
        onItemHover,
        option
    ]);
    const OptionIcon = option.Icon && _jsx(option.Icon, {
        size: "medium"
    });
    const SelectedIcon = !multiSelectable && props.selected ? _jsx(CheckIcon, {
        size: "medium"
    }) : undefined;
    const CheckboxIcon = _jsx(FakeCheckbox, {
        checked: props.selected,
        disabled: props.option.disabled
    });
    const start = multiSelectable ? _jsxs(_Fragment, {
        children: [
            CheckboxIcon,
            props.start ?? OptionIcon
        ]
    }) : props.start ?? OptionIcon;
    const end = props.end ?? SelectedIcon;
    const content = props.children ?? (props.option.description != null ? _jsxs(Rows, {
        tagName: "span",
        spacing: "0",
        children: [
            _jsx(Text, {
                tagName: "span",
                lineClamp: 1,
                tone: InheritColor,
                children: props.getLabel(props.option)
            }),
            _jsx(Text, {
                tagName: "span",
                size: "small",
                tone: option.disabled ? InheritColor : 'tertiary',
                children: props.option.description
            })
        ]
    }) : props.getLabel(props.option));
    return _jsx(MenuItem, {
        id: props.id,
        ariaSelected: props.selected,
        buttonRef: props.forwardedRef,
        tabIndex: -1,
        onClick: onClick,
        onMouseEnter: onMouseEnter,
        start: start,
        end: end,
        className: classNames(props.className, {
            [styles.active]: props.active,
            [styles.disabled]: props.option.disabled
        }),
        disabled: props.option.disabled,
        children: content
    });
}
const WrappedFlyout = (props)=>{
    return _jsx("div", {
        children: useTypicalSheetAdaptation() ? _jsx(Sheet, {
            markOutsideInert: false,
            ...props
        }) : _jsx(Popover, {
            ...props
        })
    });
};
