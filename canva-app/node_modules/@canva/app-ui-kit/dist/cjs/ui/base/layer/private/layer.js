"use strict"

Object.defineProperty(exports, "__esModule", {
  value: true
});
function _export(target, all) {
  for (var name in all) Object.defineProperty(target, name, {
    enumerable: true,
    get: Object.getOwnPropertyDescriptor(all, name).get
  });
}
_export(exports, {
  get Layer() {
    return Layer;
  },
  get LayerError() {
    return LayerError;
  },
  get LayerLevel() {
    return LayerLevel;
  },
  get WithLayerParent() {
    return WithLayerParent;
  }
});
const _jsxruntime = require("react/jsx-runtime");
const _react = _interop_require_wildcard(require("react"));
const _reactdom = _interop_require_wildcard(require("react-dom"));
const _interaction_manager = require('../../a11y/interaction_manager/interaction_manager');
const _use_isomorphic_layout_effect = require('../../hydration/use_isomorphic_layout_effect');
const _theme = require('../../theme/theme');
const _internal = require("./internal");
const _layercss = _interop_require_default(require("./layer.css"));
function _interop_require_default(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {
    __proto__: null
  };
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
const LayerLevel = {
  CONTENT: 0,
  PINS: 1,
  LIGHTBOXES: 2,
  MODALS: 3,
  COMPLIANCE_NOTICES: 4,
  TOASTS: 5,
  TOOLTIPS: 6
};
class LayerError extends Error {}
const LayerContext = _react.createContext({});
function WithLayerParent({
  parentLayer,
  children
}) {
  return (0, _jsxruntime.jsx)(LayerContext.Provider, {
    value: {
      parentLayer
    },
    children: children
  });
}
const Layer = _react.memo(function Layer({
  ...props
}) {
  const ownWindow = typeof window !== 'undefined' ? window : undefined;
  return ownWindow ? (0, _jsxruntime.jsx)(LayerImpl, {
    ...props,
    ownWindow: ownWindow
  }) : null;
});
const LayerImpl = _react.memo(function LayerImpl({
  ownWindow,
  open,
  level = 1,
  onOutsideLayerPointerDown,
  parentLayer: propsParentLayer,
  markOutsideInert = false,
  children
}) {
  const interactionLayerRef = (0, _interaction_manager.useInteractionLayer)({
    level,
    markOutsideInert
  });
  const context = _react.useContext(LayerContext);
  const parentLayer = propsParentLayer || context.parentLayer || ownWindow.document.body;
  const parentDocument = parentLayer?.ownerDocument || ownWindow.document;
  const {
    layerRoot,
    layerContent
  } = _react.useMemo(() => {
    if (!open) return {
      layerRoot: undefined,
      layerContent: undefined
    };
    const layerContent = parentDocument.createElement('div');
    layerContent.classList.add(_layercss.default.layerContent);
    const layerRoot = parentDocument.createElement('div');
    layerRoot.classList.add(_internal.LAYER_MARKER_CLASS_NAME);
    layerRoot.classList.add(_layercss.default.layerRoot);
    layerRoot.appendChild(layerContent);
    return {
      layerRoot,
      layerContent
    };
  }, [open, parentDocument]);
  _react.useEffect(() => {
    if (layerRoot && parentLayer === parentDocument.body) {
      const noop = () => 0;
      layerRoot.addEventListener('click', noop);
      return () => {
        layerRoot?.removeEventListener('click', noop);
      };
    }
  }, [layerRoot, parentDocument, parentLayer]);
  const [mounted, setMounted] = _react.useState(false);
  (0, _use_isomorphic_layout_effect.useIsomorphicLayoutEffect)(() => {
    if (layerRoot && layerContent) {
      (0, _internal.insertLayerIntoParent)(layerRoot, parentLayer);
      interactionLayerRef(layerContent);
      setMounted(true);
      return () => {
        const parentGlobal = parentDocument?.defaultView || ownWindow;
        interactionLayerRef(null);
        parentLayer.removeChild(layerRoot);
        parentDocument?.dispatchEvent(new parentGlobal.CustomEvent('layerclose'));
        setMounted(false);
      };
    }
  }, [interactionLayerRef, layerContent, layerRoot, parentDocument, parentLayer, ownWindow]);
  (0, _use_isomorphic_layout_effect.useIsomorphicLayoutEffect)(() => {
    if (layerRoot) layerRoot.style.zIndex = String(level);
  }, [layerRoot, level]);
  _react.useEffect(() => {
    if (onOutsideLayerPointerDown == null || parentDocument == null) return;
    const handleDocumentMouseDown = event => {
      if (layerRoot == null)
        return;
      const parentGlobal = parentDocument?.defaultView || ownWindow;
      if (!(event.target instanceof parentGlobal.Node))
        return;
      if (!layerRoot.contains(event.target)) onOutsideLayerPointerDown(event);
    };
    parentDocument.addEventListener('mousedown', handleDocumentMouseDown);
    parentDocument.addEventListener('touchstart', handleDocumentMouseDown);
    return () => {
      parentDocument.removeEventListener('mousedown', handleDocumentMouseDown);
      parentDocument.removeEventListener('touchstart', handleDocumentMouseDown);
    };
  }, [layerRoot, onOutsideLayerPointerDown, parentDocument, ownWindow]);
  if (layerContent && mounted) return _reactdom.createPortal((0, _jsxruntime.jsx)(LayerContext.Provider, {
    value: {
      parentLayer: layerRoot
    },
    children: (0, _jsxruntime.jsx)(_theme.WithThemeData, {
      children: data => (0, _jsxruntime.jsx)("div", {
        className: data.className,
        children: children
      })
    })
  }), layerContent);
  return null;
});