"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useFloatingUiBackend", {
    enumerable: true,
    get: function() {
        return useFloatingUiBackend;
    }
});
const _react = require("@floating-ui/react");
const _compose_refs = require('../../../../../base/react/compose_refs');
const _react1 = _interop_require_wildcard(require("react"));
const _visual_viewport = require('../../../device_capabilities/visual_viewport');
const _use_isomorphic_layout_effect = require('../../../hydration/use_isomorphic_layout_effect');
const _metrics = require('../../../metrics/metrics');
const _get_safe_area_insets = require('../../../platform_quirks/get_safe_area_insets');
const _provider = require('../../../provider/provider');
const _stable_function = require('../../../stable_function/stable_function');
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const BOUNDARY_PADDING_MAP = {
    ['0']: 0,
    ['1u']: _metrics.baseUnit
};
function useFloatingUiBackend({ placement: backendPlacement, enableFlip, enableShift, rtlAware, offset: backendOffset, boundary, boundaryPadding: backendBoundaryPadding, onCalculateLayout }) {
    const arrowRef = _react1.useRef(null);
    const contentRef = _react1.useRef(null);
    const bootstrapDirection = (0, _provider.useDirection)();
    const isRtl = _react1.useCallback(()=>{
        if (!rtlAware) return false;
        return bootstrapDirection === 'RTL';
    }, [
        bootstrapDirection,
        rtlAware
    ]);
    const includeSafeAreaInsets = boundary === 'viewport' && window.frameElement == null;
    const boundaryPadding = resolveBoundaryPadding({
        backendBoundaryPadding,
        includeSafeAreaInsets
    });
    const { stickyPlacement, store, enableStickyPlacementRef, cachedPlacementRef } = useStickyPlacement(boundaryPadding);
    const isRtlDirection = isRtl();
    let floatingUiPlacement = getFloatingUiPlacement(backendPlacement, isRtlDirection);
    if (enableStickyPlacementRef.current && cachedPlacementRef.current != null) floatingUiPlacement = cachedPlacementRef.current;
    const calculateLayout = (0, _stable_function.useStableFunction)(({ placement, reference, content })=>{
        if (onCalculateLayout == null)
            return;
        const visualViewport = (0, _visual_viewport.getVisualViewport)();
        const viewportWidth = visualViewport?.width ?? window.innerWidth;
        const viewportHeight = visualViewport?.height ?? window.innerHeight;
        const availableWidth = viewportWidth - boundaryPadding.left - boundaryPadding.right;
        const availableHeight = calculateAvailableHeight(placement, reference, viewportHeight, enableFlip, boundaryPadding, backendOffset.main);
        onCalculateLayout({
            reference,
            content,
            available: {
                width: availableWidth,
                height: availableHeight
            }
        });
    });
    const { refs: { setReference, setFloating }, floatingStyles, update, middlewareData, placement } = (0, _react.useFloating)({
        platform: {
            ..._react.platform,
            isRTL: isRtl
        },
        strategy: 'fixed',
        placement: floatingUiPlacement,
        whileElementsMounted: (reference, floating, update)=>{
            const onUpdate = ()=>{
                calculateLayout({
                    placement: floatingUiPlacement,
                    reference: reference.getBoundingClientRect(),
                    content: floating.getBoundingClientRect()
                });
                update();
            };
            return (0, _react.autoUpdate)(reference, floating, onUpdate);
        },
        middleware: [
            enableFlip && stickyPlacement({
                backendOffset
            }),
            (0, _react.offset)({
                mainAxis: backendOffset.main,
                crossAxis: backendOffset.cross
            }),
            enableFlip && !enableStickyPlacementRef.current && (0, _react.flip)({
                flipAlignment: false,
                padding: boundaryPadding,
                boundary: boundary === 'viewport' ? 'clippingAncestors' : boundary,
                rootBoundary: typeof window !== 'undefined' ? getViewportRect() : undefined
            }),
            enableShift && (0, _react.shift)({
                padding: boundaryPadding,
                crossAxis: true,
                boundary: boundary === 'viewport' ? 'clippingAncestors' : boundary
            }),
            enableFlip && store(),
            (0, _react.arrow)({
                element: arrowRef
            }),
            {
                name: 'hide',
                fn: (state)=>{
                    const { rects: { reference: referenceRect }, elements: { reference: referenceEl } } = state;
                    const focusdElement = window.document.activeElement;
                    const Node = (focusdElement?.ownerDocument?.defaultView ?? window).Node;
                    const focusedElementMayOpenVirtualKB = focusdElement instanceof Node && (focusdElement.tagName === 'INPUT' || focusdElement.tagName === 'TEXTAREA');
                    const isFocusInInputInContent = focusedElementMayOpenVirtualKB && contentRef.current instanceof Node && contentRef.current.contains(focusdElement);
                    const isFocusInReference = focusedElementMayOpenVirtualKB && referenceEl instanceof Node && referenceEl.contains(focusdElement);
                    const enabled = !isFocusInInputInContent && !isFocusInReference && !(referenceRect.width === 0 && referenceRect.height === 0 && referenceRect.x === 0 && referenceRect.y === 0);
                    if (!enabled) return {};
                    return (0, _react.hide)({
                        boundary: boundary === 'viewport' ? getViewportRect() : boundary
                    }).fn(state);
                }
            }
        ]
    });
    (0, _use_isomorphic_layout_effect.useIsomorphicLayoutEffect)(()=>{
        const arrow = arrowRef.current;
        if (arrow != null) updateArrow(arrow, middlewareData, placement);
    }, [
        middlewareData,
        placement
    ]);
    return {
        setReference,
        contentProps: {
            ref: (0, _compose_refs.composeRefs)(setFloating, contentRef),
            style: {
                ...floatingStyles,
                visibility: middlewareData.hide?.referenceHidden ? 'hidden' : 'visible'
            }
        },
        setArrow: (0, _stable_function.useStableFunction)((arrow)=>{
            arrowRef.current = arrow;
            if (arrow != null) updateArrow(arrow, middlewareData, placement);
        }),
        update
    };
}
const ARROW_ROTATION_MAP = {
    ['left']: '90deg',
    ['right']: '-90deg',
    ['top']: '180deg',
    ['bottom']: '0deg'
};
function updateArrow(arrow, middlewareData, placement) {
    const x = middlewareData.arrow?.x;
    const y = middlewareData.arrow?.y;
    const side = placement.split('-')[0];
    arrow.style.setProperty('position', 'absolute');
    arrow.style.setProperty('left', x != null ? `${x}px` : '');
    arrow.style.setProperty('top', y != null ? `${y}px` : '');
    arrow.style.setProperty('right', '');
    arrow.style.setProperty('bottom', '');
    arrow.style.setProperty(side, '100%');
    arrow.style.setProperty('transform', `rotate(${ARROW_ROTATION_MAP[side]})`);
}
const FLOATING_UI_PLACEMENT_MAP = {
    ['start-top']: {
        ltr: 'left-start',
        rtl: 'right-start'
    },
    ['start-center']: {
        ltr: 'left',
        rtl: 'right'
    },
    ['start-bottom']: {
        ltr: 'left-end',
        rtl: 'right-end'
    },
    ['end-top']: {
        ltr: 'right-start',
        rtl: 'left-start'
    },
    ['end-center']: {
        ltr: 'right',
        rtl: 'left'
    },
    ['end-bottom']: {
        ltr: 'right-end',
        rtl: 'left-end'
    },
    ['top-start']: {
        ltr: 'top-start',
        rtl: 'top-start'
    },
    ['top-center']: {
        ltr: 'top',
        rtl: 'top'
    },
    ['top-end']: {
        ltr: 'top-end',
        rtl: 'top-end'
    },
    ['bottom-start']: {
        ltr: 'bottom-start',
        rtl: 'bottom-start'
    },
    ['bottom-center']: {
        ltr: 'bottom',
        rtl: 'bottom'
    },
    ['bottom-end']: {
        ltr: 'bottom-end',
        rtl: 'bottom-end'
    }
};
function getFloatingUiPlacement(placement, isRtl) {
    const mapping = FLOATING_UI_PLACEMENT_MAP[placement];
    return isRtl ? mapping.rtl : mapping.ltr;
}
function getAvailableVerticalSpace({ viewportHeight, boundaryPadding, offset, reference }) {
    const visibleSpaceTop = Math.min(viewportHeight, reference.top);
    const visibleSpaceBottom = Math.min(viewportHeight, viewportHeight - reference.bottom);
    return {
        top: visibleSpaceTop - boundaryPadding.top - offset,
        bottom: visibleSpaceBottom - boundaryPadding.bottom - offset
    };
}
function calculateAvailableHeight(placement, reference, viewportHeight, enableFlip, boundaryPadding, offset) {
    const isVerticalPlacement = placement.startsWith('bottom') || placement.startsWith('top');
    if (!isVerticalPlacement) return viewportHeight - boundaryPadding.top - boundaryPadding.bottom;
    const availableSpace = getAvailableVerticalSpace({
        viewportHeight,
        boundaryPadding,
        offset,
        reference
    });
    if (enableFlip)
        return Math.max(availableSpace.top, availableSpace.bottom);
    else
        return placement.startsWith('top') ? availableSpace.top : availableSpace.bottom;
}
function useStickyPlacement(boundaryPadding) {
    const contentHeightRef = _react1.useRef(undefined);
    const cachedPlacementRef = _react1.useRef(undefined);
    const enableStickyPlacementRef = _react1.useRef(false);
    const stickyPlacement = (0, _stable_function.useStableFunction)(({ backendOffset })=>({
            name: 'stickyPlacement',
            options: [
                backendOffset
            ],
            fn: ({ rects: { floating }, elements: { reference: referenceEl } })=>{
                if (cachedPlacementRef.current == null)
                    return {};
                const availableSpace = getAvailableVerticalSpace({
                    viewportHeight: window.innerHeight,
                    boundaryPadding,
                    offset: backendOffset.main,
                    reference: referenceEl.getBoundingClientRect()
                });
                const cachedPlacement = cachedPlacementRef.current;
                const contentHeight = floating.height;
                let hasEnoughSpaceInCurrentPlacement = false;
                if (cachedPlacement.startsWith('top'))
                    hasEnoughSpaceInCurrentPlacement = contentHeight <= availableSpace.top;
                else if (cachedPlacement.startsWith('bottom')) hasEnoughSpaceInCurrentPlacement = contentHeight <= availableSpace.bottom;
                else return {};
                if (!enableStickyPlacementRef.current && contentHeightRef.current !== contentHeight && hasEnoughSpaceInCurrentPlacement)
                    enableStickyPlacementRef.current = true;
                if (enableStickyPlacementRef.current && !hasEnoughSpaceInCurrentPlacement) {
                    enableStickyPlacementRef.current = false;
                    cachedPlacementRef.current = undefined;
                }
                return {};
            }
        }));
    const store = (0, _stable_function.useStableFunction)(()=>({
            name: 'store',
            fn: ({ placement: currentPlacement, rects: { floating } })=>{
                contentHeightRef.current = floating.height;
                if (!enableStickyPlacementRef.current) cachedPlacementRef.current = currentPlacement;
                return {};
            }
        }));
    return {
        stickyPlacement,
        store,
        enableStickyPlacementRef,
        cachedPlacementRef
    };
}
function getViewportRect() {
    let width = document.documentElement.clientWidth;
    let height = document.documentElement.clientHeight;
    let x = 0;
    let y = 0;
    const visualViewport = (0, _visual_viewport.getVisualViewport)();
    if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height;
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
        const iframe = window.frameElement;
        if (iframe) {
            const iframeRect = iframe.getBoundingClientRect();
            x = visualViewport.offsetLeft - iframeRect.left;
            y = visualViewport.offsetTop - iframeRect.top;
        }
    }
    return {
        x,
        y,
        width,
        height
    };
}
const DEFAULT_INSETS = {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
};
function resolveBoundaryPadding({ backendBoundaryPadding, includeSafeAreaInsets }) {
    const desiredPaddingPx = BOUNDARY_PADDING_MAP[backendBoundaryPadding];
    const insets = includeSafeAreaInsets ? (0, _get_safe_area_insets.getSafeAreaInsets)() : DEFAULT_INSETS;
    return {
        top: Math.max(desiredPaddingPx, insets.top),
        right: Math.max(desiredPaddingPx, insets.right),
        bottom: Math.max(desiredPaddingPx, insets.bottom),
        left: Math.max(desiredPaddingPx, insets.left)
    };
}
