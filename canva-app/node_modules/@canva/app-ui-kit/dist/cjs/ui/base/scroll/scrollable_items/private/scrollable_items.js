"use strict"
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get ScrollableItem () {
        return ScrollableItem;
    },
    get ScrollableItems () {
        return ScrollableItems;
    },
    get ScrollableItemsCenterAlignSpacer () {
        return ScrollableItemsCenterAlignSpacer;
    },
    get scrollableItemsGaps () {
        return scrollableItemsGaps;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _compose_refs = require('../../../../../base/react/compose_refs');
const _classnames = _interop_require_default(require("classnames"));
const _react = _interop_require_wildcard(require("react"));
const _box = require('../../../box/box');
const _metrics = require('../../../metrics/metrics');
const _provider = require('../../../provider/provider');
const _responsive = require('../../../responsive/responsive');
const _use_responsive_value = require('../../../responsive/use_responsive_value');
const _behavior = require("./behavior");
const _scrollable_itemscss = _interop_require_wildcard(require("./scrollable_items.css"));
const _visibility_observer = require("./visibility_observer");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const scrollableItemsGaps = [
    '0',
    '1u',
    '2u',
    '3u'
];
const ScrollableItemsContext = _react.createContext({
    snapAlign: 'start',
    focusScrollContainer: ()=>{}
});
const ScrollableItems = ({ direction, fadeSize = '6u', gap = '2u', children, id, snap = 'proximity', snapAlign = 'start', padding, paddingX, paddingY, paddingTop, paddingBottom, paddingStart, paddingEnd, ref, scrollableRef, onScroll: onScrollProp, onScrollStateChange: onScrollStateChangeProp, itemSize = 'intrinsic', outOfViewItemBehavior = 'inert', role, ariaLabel, ariaLabelledBy, ariaDescribedBy, ariaSetSize, getItemWidth, itemCount, onFocus })=>{
    const [atStart, setAtStart] = _react.useState(true);
    const [atEnd, setAtEnd] = _react.useState(true);
    const [numberOfItems, setNumberOfItems] = _react.useState(0);
    const localeDirection = (0, _provider.useDirection)();
    const isHorizontal = direction === 'horizontal';
    const isVertical = !isHorizontal;
    const onScrollStateChange = _react.useCallback((state)=>{
        onScrollStateChangeProp?.(state);
        if (isHorizontal) {
            if (ariaSetSize == null) setNumberOfItems(state.itemX?.numberOfItems || 0);
            setAtStart(state.atStart);
            setAtEnd(state.atEnd);
        } else {
            if (ariaSetSize == null) setNumberOfItems(state.itemY?.numberOfItems || 0);
            setAtStart(state.atTop);
            setAtEnd(state.atBottom);
        }
    }, [
        onScrollStateChangeProp,
        isHorizontal,
        ariaSetSize
    ]);
    const responsiveGap = typeof gap === 'object' ? gap : {
        default: gap
    };
    const gapValue = (0, _use_responsive_value.useResponsiveValue)(responsiveGap);
    const gapInPixel = (0, _metrics.unitSizeToNumber)(gapValue);
    const { ref: scrollableItemRef, handle, onScroll } = (0, _behavior.useScrollableItems)({
        onScroll: onScrollProp,
        onScrollStateChange,
        gap: gapInPixel,
        getItemWidth,
        itemCount
    });
    _react.useImperativeHandle(ref, ()=>mapScrollHandle(handle, snapAlign === 'none' ? 'start' : snapAlign, localeDirection === 'RTL'));
    const { className: boxClassName, style: boxStyle } = (0, _box.useBox)({
        display: 'flex',
        flexDirection: isHorizontal ? 'row' : 'column',
        flexWrap: 'noWrap',
        columnGap: isHorizontal ? gap : undefined,
        rowGap: isVertical ? gap : undefined
    });
    const responsiveItemSize = typeof itemSize === 'object' ? itemSize : {
        default: itemSize
    };
    const itemSizeValue = (0, _use_responsive_value.useResponsiveValue)(responsiveItemSize);
    const numberOfItemsPerPage = itemSizeValue !== 'intrinsic' ? Math.floor(100 / parseFloat(itemSizeValue)) : 1;
    const className = (0, _classnames.default)(_scrollable_itemscss.default.scrollableItems, boxClassName, getPaddingClassNames(padding, paddingX, paddingY, paddingTop, paddingBottom, paddingStart, paddingEnd), {
        [_scrollable_itemscss.default.horizontal]: isHorizontal,
        [_scrollable_itemscss.default.vertical]: isVertical,
        [_scrollable_itemscss.default.backwardFade]: fadeSize !== '0' && !atStart,
        [_scrollable_itemscss.default.forwardFade]: fadeSize !== '0' && !atEnd,
        [_scrollable_itemscss.default.mandatory]: snap === 'mandatory',
        [_scrollable_itemscss.default.proximity]: snap === 'proximity',
        [_scrollable_itemscss.default.fadeSizeThreeUnit]: fadeSize === '3u',
        [_scrollable_itemscss.default.fadeSizeSixUnit]: fadeSize === '6u',
        [_scrollable_itemscss.default.fadeSizeTwelveUnit]: fadeSize === '12u'
    });
    const focusRef = _react.useRef(null);
    const focusScrollContainer = _react.useCallback(()=>{
        focusRef.current?.focus({
            preventScroll: true
        });
    }, []);
    const contextValue = _react.useMemo(()=>({
            snapAlign,
            itemSize,
            role,
            focusScrollContainer,
            numberOfItems: ariaSetSize ?? numberOfItems
        }), [
        snapAlign,
        itemSize,
        role,
        focusScrollContainer,
        numberOfItems,
        ariaSetSize
    ]);
    return (0, _jsxruntime.jsx)(ScrollableItemsContext.Provider, {
        value: contextValue,
        children: (0, _jsxruntime.jsx)(_visibility_observer.VisibilityRoot, {
            disable: outOfViewItemBehavior === 'none',
            children: ({ ref: visibilityRootRef })=>(0, _jsxruntime.jsx)("div", {
                    id: id,
                    ref: (0, _compose_refs.composeRefs)(scrollableItemRef, focusRef, scrollableRef, visibilityRootRef),
                    onScroll: onScroll,
                    className: className,
                    style: {
                        ...boxStyle,
                        ...getPaddingStyles(padding, paddingX, paddingY, paddingTop, paddingBottom, paddingStart, paddingEnd),
                        [_scrollable_itemscss.customProperties.gapInPixel]: `${gapInPixel}px`,
                        [_scrollable_itemscss.customProperties.numberOfItemsPerPage]: numberOfItemsPerPage
                    },
                    role: role,
                    "aria-label": ariaLabelledBy ? undefined : ariaLabel,
                    "aria-labelledby": ariaLabelledBy,
                    "aria-describedby": ariaDescribedBy,
                    onFocus: onFocus,
                    children: children
                })
        })
    });
};
const mapScrollHandle = (handle, defaultItemAlign, rtl)=>{
    return {
        getScrollState: ()=>handle.getScrollState(),
        scrollTo: (options)=>handle.scrollTo({
                rtl,
                ...options
            }),
        scrollBy: (options)=>handle.scrollBy({
                rtl,
                ...options
            }),
        scrollToPage: (options)=>handle.scrollToPage({
                rtl,
                ...options
            }),
        scrollByPage: (options)=>handle.scrollByPage({
                ...options
            }),
        scrollToItem: (options)=>handle.scrollToItem({
                itemAlign: defaultItemAlign,
                rtl,
                ...options
            }),
        scrollByItem: (options)=>handle.scrollByItem({
                rtl,
                itemAlign: defaultItemAlign,
                ...options
            })
    };
};
const getPaddingClassNames = (padding, paddingX, paddingY, paddingTop, paddingBottom, paddingStart, paddingEnd)=>[
        (padding || paddingX || paddingY || paddingTop || paddingBottom || paddingStart || paddingEnd) && _scrollable_itemscss.default.hasPadding
    ];
const paddingPropertyMap = {
    default: _scrollable_itemscss.customProperties.paddingAll,
    smallUp: _scrollable_itemscss.customProperties.smallUpPaddingAll,
    mediumUp: _scrollable_itemscss.customProperties.mediumUpPaddingAll,
    largeUp: _scrollable_itemscss.customProperties.largeUpPaddingAll,
    xLargeUp: _scrollable_itemscss.customProperties.xLargeUpPaddingAll
};
const paddingXPropertyMap = {
    default: _scrollable_itemscss.customProperties.paddingX,
    smallUp: _scrollable_itemscss.customProperties.smallUpPaddingX,
    mediumUp: _scrollable_itemscss.customProperties.mediumUpPaddingX,
    largeUp: _scrollable_itemscss.customProperties.largeUpPaddingX,
    xLargeUp: _scrollable_itemscss.customProperties.xLargeUpPaddingX
};
const paddingYPropertyMap = {
    default: _scrollable_itemscss.customProperties.paddingY,
    smallUp: _scrollable_itemscss.customProperties.smallUpPaddingY,
    mediumUp: _scrollable_itemscss.customProperties.mediumUpPaddingY,
    largeUp: _scrollable_itemscss.customProperties.largeUpPaddingY,
    xLargeUp: _scrollable_itemscss.customProperties.xLargeUpPaddingY
};
const paddingTopPropertyMap = {
    default: _scrollable_itemscss.customProperties.paddingTop,
    smallUp: _scrollable_itemscss.customProperties.smallUpPaddingTop,
    mediumUp: _scrollable_itemscss.customProperties.mediumUpPaddingTop,
    largeUp: _scrollable_itemscss.customProperties.largeUpPaddingTop,
    xLargeUp: _scrollable_itemscss.customProperties.xLargeUpPaddingTop
};
const paddingBottomPropertyMap = {
    default: _scrollable_itemscss.customProperties.paddingBottom,
    smallUp: _scrollable_itemscss.customProperties.smallUpPaddingBottom,
    mediumUp: _scrollable_itemscss.customProperties.mediumUpPaddingBottom,
    largeUp: _scrollable_itemscss.customProperties.largeUpPaddingBottom,
    xLargeUp: _scrollable_itemscss.customProperties.xLargeUpPaddingBottom
};
const paddingStartPropertyMap = {
    default: _scrollable_itemscss.customProperties.paddingStart,
    smallUp: _scrollable_itemscss.customProperties.smallUpPaddingStart,
    mediumUp: _scrollable_itemscss.customProperties.mediumUpPaddingStart,
    largeUp: _scrollable_itemscss.customProperties.largeUpPaddingStart,
    xLargeUp: _scrollable_itemscss.customProperties.xLargeUpPaddingStart
};
const paddingEndPropertyMap = {
    default: _scrollable_itemscss.customProperties.paddingEnd,
    smallUp: _scrollable_itemscss.customProperties.smallUpPaddingEnd,
    mediumUp: _scrollable_itemscss.customProperties.mediumUpPaddingEnd,
    largeUp: _scrollable_itemscss.customProperties.largeUpPaddingEnd,
    xLargeUp: _scrollable_itemscss.customProperties.xLargeUpPaddingEnd
};
const getPaddingStyles = (padding, paddingX, paddingY, paddingTop, paddingBottom, paddingStart, paddingEnd)=>({
        ...(padding && (0, _responsive.generateStyle)(paddingPropertyMap, padding, _metrics.getSpaceValue)),
        ...(paddingX && (0, _responsive.generateStyle)(paddingXPropertyMap, paddingX, _metrics.getSpaceValue)),
        ...(paddingY && (0, _responsive.generateStyle)(paddingYPropertyMap, paddingY, _metrics.getSpaceValue)),
        ...(paddingTop && (0, _responsive.generateStyle)(paddingTopPropertyMap, paddingTop, _metrics.getSpaceValue)),
        ...(paddingBottom && (0, _responsive.generateStyle)(paddingBottomPropertyMap, paddingBottom, _metrics.getSpaceValue)),
        ...(paddingStart && (0, _responsive.generateStyle)(paddingStartPropertyMap, paddingStart, _metrics.getSpaceValue)),
        ...(paddingEnd && (0, _responsive.generateStyle)(paddingEndPropertyMap, paddingEnd, _metrics.getSpaceValue))
    });
const getItemSizeClassNames = (itemSize)=>itemSize !== 'intrinsic' ? _scrollable_itemscss.default.hasItemSize : undefined;
const itemSizePropertyMap = {
    default: _scrollable_itemscss.customProperties.itemSize,
    smallUp: _scrollable_itemscss.customProperties.smallUpItemSize,
    mediumUp: _scrollable_itemscss.customProperties.mediumUpItemSize,
    largeUp: _scrollable_itemscss.customProperties.largeUpItemSize,
    xLargeUp: _scrollable_itemscss.customProperties.xLargeUpItemSize
};
const getItemSizeStyles = (itemSize)=>itemSize !== 'intrinsic' ? (0, _responsive.generateStyle)(itemSizePropertyMap, itemSize, (value)=>value === 'intrinsic' ? 'auto' : value) : undefined;
const ScrollableItem = _react.memo(
    function ScrollableItem({ children, snapAlign: itemSnapAlign, size: itemSizeProp, role: roleProp, index }) {
        const { snapAlign: parentSnapAlign, role: carouselRole, itemSize: parentItemSize, focusScrollContainer, numberOfItems } = _react.useContext(ScrollableItemsContext);
        const snapAlign = itemSnapAlign || parentSnapAlign;
        const itemSize = itemSizeProp || parentItemSize || 'intrinsic';
        const role = roleProp || (carouselRole === 'list' ? 'listitem' : undefined);
        const [inert, setInert] = _react.useState(false);
        const itemRef = _react.useRef(null);
        const itemClassName = (0, _classnames.default)(_scrollable_itemscss.default.item, {
            [_scrollable_itemscss.default.snapItemCenter]: snapAlign === 'center',
            [_scrollable_itemscss.default.snapItemEnd]: snapAlign === 'end',
            [_scrollable_itemscss.default.snapItemNone]: snapAlign === 'none'
        }, getItemSizeClassNames(itemSize));
        const style = getItemSizeStyles(itemSize);
        const { ref: visibilityObserverRef } = (0, _visibility_observer.useVisibilityObserver)({
            onVisibilityChange: (isVisible)=>{
                setInert(!isVisible);
                const element = itemRef.current;
                if (!element || isVisible) return;
                if (element === document.activeElement || element.contains(document.activeElement))
                focusScrollContainer();
            }
        });
        return (0, _jsxruntime.jsx)("div", {
            role: role,
            className: itemClassName,
            style: style,
            inert: inert,
            ref: (0, _compose_refs.composeRefs)(itemRef, visibilityObserverRef),
            "aria-setsize": role === 'listitem' ? numberOfItems : undefined,
            "aria-posinset": role === 'listitem' && index != null ? index + 1 : undefined,
            children: children
        });
    }
);
const ScrollableItemsCenterAlignSpacer = ()=>{
    const { itemSize } = _react.useContext(ScrollableItemsContext);
    return (0, _jsxruntime.jsx)("span", {
        className: (0, _classnames.default)(_scrollable_itemscss.default.centerAlignSpacer, {
            [_scrollable_itemscss.default.hasItemSize]: itemSize != null
        }),
        style: itemSize != null ? getItemSizeStyles(itemSize) : undefined
    });
};
