"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get BaseSelectItem () {
        return BaseSelectItem;
    },
    get BaseSelectMenu () {
        return BaseSelectMenu;
    },
    get BaseSelectTrigger () {
        return BaseSelectTrigger;
    },
    get StatelessBaseSelect () {
        return StatelessBaseSelect;
    },
    get WindowedSelectMenu () {
        return WindowedSelectMenu;
    },
    get renderEmptyMenuContent () {
        return renderEmptyMenuContent;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _compose_refs = require('../../../../../base/react/compose_refs');
const _classnames = _interop_require_default(require("classnames"));
const _react = _interop_require_wildcard(require("react"));
const _announcer = require('../../../a11y/announcer/announcer');
const _screen_reader_content = require('../../../a11y/screen_reader_content/screen_reader_content');
const _box = require('../../../box/box');
const _base_button = require('../../../button/base_button/base_button');
const _divider = require('../../../divider/divider');
const _checkbox = require('../../checkbox/checkbox');
const _icon = require('../../../icons/check/icon');
const _icon1 = require('../../../icons/chevron_down/icon');
const _layout = require('../../../layout/layout');
const _menu = require('../../../menu/menu');
const _metrics = require('../../../metrics/metrics');
const _scroll = require('../../../scroll/scroll');
const _scroll_window = require('../../../scroll_controls/scroll_window');
const _popover = require('../../../surface/popover/popover');
const _sheet = require('../../../surface/sheet/sheet');
const _colorcss = _interop_require_default(require('../../../tokens/color.css'));
const _typography = require('../../../typography/typography');
const _base_selectcss = _interop_require_default(require("./base_select.css"));
const _base_selectmessages = require("./base_select.messages");
const _base_select_util = require("./base_select_util");
const _truncated_list = require("./truncated_list");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const DEFAULT_FLYOUT_WIDTH_UNITS = '40u';
const DEFAULT_FLYOUT_WIDTH = parseInt(DEFAULT_FLYOUT_WIDTH_UNITS, 10) * _metrics.baseUnit;
function StatelessBaseSelect(props) {
    const { Trigger = BaseSelectTrigger, Menu = BaseSelectMenu, Item, Flyout = WrappedFlyout, trigger = (props)=> (0, _jsxruntime.jsx)(Trigger, {
            ...props
        }), menu = (props)=> (0, _jsxruntime.jsx)(Menu, {
            ...props
        }), item, value, placeholder, open, disabled, error, stretch, activeIndex, options, focusOnMenu = false, flyoutPlacement = 'bottom-start', flyoutWidth: flyoutWidthProp, blockOutsidePointerEvents, id, ariaLabelledBy, ariaDescribedBy, tooltipLabel, tooltipPlacement, tooltipDisabled, className, onRequestClose, onRequestOpen, onBlur, onFocus, onItemClick, onItemHover, areEqual = _base_select_util.defaultAreEqual, isSelected = _base_select_util.defaultIsSelected, getLabel = _base_select_util.defaultGetLabel } = props;
    const menuId = _react.useId();
    const labelId = _react.useId();
    const sizingMode = (0, _sheet.useTypicalSheetAdaptation)() ? 'fill' : 'fixed';
    const triggerContainerRef = _react.useRef(null);
    const menuContainerRef = _react.useRef(null);
    const flatOptions = _react.useMemo(()=>props.flatOptions ?? (0, _base_select_util.flattenOptions)(props.options), [
        props.options,
        props.flatOptions
    ]);
    const optionGroups = _react.useMemo(()=>props.optionGroups ?? (0, _base_select_util.normalizeOptionGroups)(props.options), [
        props.options,
        props.optionGroups
    ]);
    const selectedOptions = _react.useMemo(()=>props.selectedOptions ?? flatOptions.filter((option)=>isSelected(option, value)), [
        flatOptions,
        props.selectedOptions,
        isSelected,
        value
    ]);
    const activeDescendantId = (0, _base_select_util.deriveIdentifier)(menuId, activeIndex);
    const ariaLabel = props.ariaLabel ?? (!ariaLabelledBy && typeof props.title === 'string' ? props.title : undefined);
    const [flyoutWidth, setFlyoutWidth] = _react.useState(flyoutWidthProp ?? DEFAULT_FLYOUT_WIDTH_UNITS);
    const onRequestToggle = _react.useCallback(()=>{
        if (open) onRequestClose();
        else onRequestOpen();
    }, [
        open,
        onRequestClose,
        onRequestOpen
    ]);
    _react.useEffect(()=>{
        if (!stretch || flyoutWidthProp != null) {
            setFlyoutWidth(flyoutWidthProp ?? DEFAULT_FLYOUT_WIDTH_UNITS);
            return;
        }
        const triggerWidth = triggerContainerRef.current?.getBoundingClientRect().width ?? 0;
        const width = triggerWidth < DEFAULT_FLYOUT_WIDTH ? DEFAULT_FLYOUT_WIDTH_UNITS : 'trigger';
        setFlyoutWidth(width);
    }, [
        flyoutWidthProp,
        stretch
    ]);
    return (0, _jsxruntime.jsx)(Flyout, {
        placement: flyoutPlacement,
        open: open ?? false,
        onRequestClose: onRequestClose,
        captureFocus: focusOnMenu,
        width: flyoutWidth,
        title: props.title,
        headerEnd: props.headerEnd,
        headerDivider: "always",
        blockOutsidePointerEvents: blockOutsidePointerEvents,
        trigger: (0, _jsxruntime.jsx)("div", {
            ref: (0, _compose_refs.composeRefs)(triggerContainerRef, props.triggerContainerRef),
            className: (0, _classnames.default)(_base_selectcss.default.triggerContainer, className, {
                [_base_selectcss.default.triggerStretch]: stretch
            }),
            children: trigger({
                value,
                options,
                flatOptions,
                optionGroups,
                selectedOptions,
                placeholder,
                disabled,
                error,
                open,
                id,
                ariaLabel,
                ariaLabelledBy,
                ariaDescribedBy,
                activeIndex,
                onBlur,
                onFocus,
                role: 'combobox',
                disclosure: true,
                labelId,
                active: open,
                ariaActiveDescendant: activeDescendantId,
                ariaControls: menuId,
                onRequestToggle,
                getLabel,
                isSelected,
                tooltipLabel,
                tooltipPlacement,
                tooltipDisabled
            })
        }),
        children: (0, _jsxruntime.jsx)("div", {
            className: _base_selectcss.default.menuContainer,
            ref: (0, _compose_refs.composeRefs)(menuContainerRef, props.menuContainerRef),
            children: menu({
                Item,
                item,
                id: menuId,
                options,
                flatOptions,
                optionGroups,
                selectedOptions,
                value,
                activeIndex,
                activeOption: flatOptions[activeIndex ?? -1],
                onItemClick,
                onItemHover,
                areEqual,
                isSelected,
                getLabel,
                sizingMode,
                menuContainerRef,
                ariaLabel,
                ariaLabelledBy,
                children: options.length === 0 ? renderEmptyMenuContent() : undefined
            })
        })
    });
}
function BaseSelectTrigger(props) {
    const { selectedOptions } = props;
    const noSelection = !selectedOptions.length;
    const Icon = getIcon(props.Icon ?? 'auto', selectedOptions[0]?.Icon);
    const ariaLabelledBy = props.ariaLabelledBy || (props.ariaLabel ? undefined : props.labelId);
    const ariaDescribedBy = getTriggerAriaDescribedBy(props);
    return (0, _jsxruntime.jsxs)(_base_button.BaseButton, {
        onClick: props.onRequestToggle,
        onBlur: props.onBlur,
        onFocus: props.onFocus,
        disclosure: true,
        pressed: props.open,
        disabled: props.disabled,
        className: (0, _classnames.default)(_base_selectcss.default.triggerButton, props.className),
        id: props.id,
        role: props.role,
        tooltipLabel: props.tooltipLabel,
        tooltipPlacement: props.tooltipPlacement,
        tooltipDisabled: props.tooltipDisabled,
        ariaLabel: props.ariaLabel,
        ariaLabelledBy: ariaLabelledBy,
        ariaDescribedBy: ariaDescribedBy,
        ariaControls: props.ariaControls,
        ariaHasPopup: "listbox",
        ariaActiveDescendant: props.ariaActiveDescendant,
        ariaInvalid: props.error,
        borderRadius: "element",
        paddingX: "1.5u",
        alignItems: "center",
        width: "full",
        border: "standard",
        tone: "secondary",
        backgroundColor: {
            default: _colorcss.default.colorControlBg,
            pressed: _colorcss.default.colorControlBg,
            hovered: _colorcss.default.colorControlBg,
            disabled: _colorcss.default.colorControlBgDisabled
        },
        borderColor: {
            default: props.error ? _colorcss.default.colorControlCriticalBorder : _colorcss.default.colorControlBorder,
            pressed: _colorcss.default.colorControlBorderFocused,
            hovered: _colorcss.default.colorControlBorderHovered,
            disabled: _colorcss.default.colorControlBorderDisabled
        },
        children: [
            Icon && (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
                children: [
                    (0, _jsxruntime.jsx)(Icon, {
                        size: "medium"
                    }),
                    (0, _jsxruntime.jsx)(_layout.Spacer, {
                        size: "1u"
                    })
                ]
            }),
            (0, _jsxruntime.jsx)(_typography.Text, {
                id: props.labelId,
                tagName: "span",
                lineClamp: 1,
                tone: _typography.InheritColor,
                className: (0, _classnames.default)(_base_selectcss.default.label, {
                    [_base_selectcss.default.placeholder]: noSelection || props.disabled
                }),
                children: getTriggerContent(props)
            }),
            (0, _jsxruntime.jsx)(_icon1.ChevronDownIcon, {
                size: "medium"
            })
        ]
    });
}
function getIcon(Icon, FallbackIcon) {
    if (Icon === 'none') return undefined;
    if (Icon === 'auto') return FallbackIcon;
    return Icon;
}
function getTriggerContent(props) {
    if (props.children) return props.children;
    const hasSelection = props.selectedOptions.length > 0;
    if (!hasSelection && props.disabled)
    return (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
        children: [
            (0, _jsxruntime.jsx)(_screen_reader_content.ScreenReaderContent, {
                tagName: "span",
                children: _base_selectmessages.BaseSelectMessages.defaultDisabledMessage()
            }),
            (0, _jsxruntime.jsx)("span", {
                "aria-hidden": true,
                children: props.placeholder ?? _base_selectmessages.BaseSelectMessages.defaultPlaceholder()
            })
        ]
    });
    if (!hasSelection)
    return (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
        children: [
            (0, _jsxruntime.jsx)(_screen_reader_content.ScreenReaderContent, {
                tagName: "span",
                children: _base_selectmessages.BaseSelectMessages.defaultNoSelectionMessage()
            }),
            (0, _jsxruntime.jsx)("span", {
                "aria-hidden": true,
                id: `${props.labelId}--placeholder`,
                children: props.placeholder ?? _base_selectmessages.BaseSelectMessages.defaultPlaceholder()
            })
        ]
    });
    const items = props.selectedOptions.map(props.getLabel);
    if (items.length > 1 && items.every((item)=>typeof item === 'string')) return (0, _jsxruntime.jsx)(_truncated_list.TruncatedList, {
        tagName: "span",
        items: items
    });
    return (0, _base_select_util.joinLabels)(items);
}
function getTriggerAriaDescribedBy(props) {
    if (props.children)
    return props.ariaDescribedBy;
    const hasSelection = props.selectedOptions.length > 0;
    if (!hasSelection) return `${props.ariaDescribedBy ?? ''} ${props.labelId}--placeholder`.trim();
    return props.ariaDescribedBy;
}
function useScrollToActiveItem({ activeIndex }) {
    const scrollRef = _react.useRef(null);
    const activeItemRef = _react.useRef(null);
    _react.useEffect(()=>{
        if (!scrollRef.current || !activeItemRef.current) return;
        if ((0, _scroll.isAboveView)(scrollRef.current, activeItemRef.current)) (0, _scroll.scrollIntoView)(scrollRef.current, activeItemRef.current, {
            align: 'start'
        });
        if ((0, _scroll.isBelowView)(scrollRef.current, activeItemRef.current)) (0, _scroll.scrollIntoView)(scrollRef.current, activeItemRef.current, {
            align: 'end'
        });
    }, [
        activeIndex,
        scrollRef
    ]);
    return {
        scrollRef,
        activeItemRef
    };
}
function BaseSelectMenu(props) {
    const { Item = BaseSelectItem, item = (props)=> (0, _jsxruntime.jsx)(Item, {
            ...props
        }), flatOptions, optionGroups, value, activeIndex, id, ariaLabel, ariaLabelledBy, header, footer, isSelected, getLabel, onItemClick, onItemHover, className, children, sizingMode } = props;
    const { scrollRef, activeItemRef } = useScrollToActiveItem({
        activeIndex
    });
    const hasMultipleGroups = optionGroups.length > 1;
    const announcer = (0, _announcer.useAnnouncer)();
    const announcerRef = _react.useRef(null);
    const announcedContent = _react.useRef('');
    const shouldAnnounce = !!children;
    _react.useEffect(()=>{
        if (!shouldAnnounce) return;
        const textContent = announcerRef.current?.textContent ?? '';
        if (textContent === announcedContent.current) return;
        announcedContent.current = textContent;
        announcer.announce(textContent);
    }, [
        announcer,
        shouldAnnounce,
        children
    ]);
    return (0, _jsxruntime.jsx)(WithHeaderAndFooter, {
        header: header,
        footer: footer,
        children: (0, _jsxruntime.jsx)("div", {
            className: (0, _classnames.default)(_base_selectcss.default.scrollContainer, sizingMode === 'fixed' && _base_selectcss.default.popover, className),
            ref: scrollRef,
            id: hasMultipleGroups ? id : undefined,
            role: hasMultipleGroups ? 'listbox' : undefined,
            "aria-label": hasMultipleGroups ? ariaLabel : undefined,
            "aria-labelledby": hasMultipleGroups ? ariaLabelledBy : undefined,
            children: children ? (0, _jsxruntime.jsx)("div", {
                ref: announcerRef,
                children: children
            }) : optionGroups.map((optionGroup, groupIndex)=>(0, _jsxruntime.jsxs)(_react.Fragment, {
                    children: [
                        groupIndex > 0 && (0, _jsxruntime.jsx)("div", {
                            className: _base_selectcss.default.groupDivider,
                            children: (0, _jsxruntime.jsx)(_divider.Divider, {})
                        }),
                        (0, _jsxruntime.jsx)(OptionGroup, {
                            item: item,
                            menuId: id,
                            id: hasMultipleGroups ? undefined : id,
                            role: hasMultipleGroups ? 'group' : 'listbox',
                            ariaLabel: hasMultipleGroups ? undefined : ariaLabel,
                            ariaLabelledBy: hasMultipleGroups ? undefined : ariaLabelledBy,
                            activeItemRef: activeItemRef,
                            value: value,
                            optionIndexOffset: flatOptions.findIndex((o)=>o === optionGroup.options[0]),
                            activeIndex: activeIndex,
                            label: optionGroup.label,
                            options: optionGroup.options,
                            isSelected: isSelected,
                            onItemClick: onItemClick,
                            onItemHover: onItemHover,
                            getLabel: getLabel
                        })
                    ]
                }, groupIndex))
        })
    });
}
function OptionGroup({ item = (props)=> (0, _jsxruntime.jsx)(BaseSelectItem, {
        ...props
    }), id, menuId, role, ariaLabel, ariaLabelledBy, value, optionIndexOffset = 0, activeIndex, label, options, isSelected, activeItemRef, onItemClick, onItemHover, getLabel }) {
    const headingId = _react.useId();
    const multiSelectable = Array.isArray(value);
    return (0, _jsxruntime.jsxs)(_menu.Menu, {
        id: id,
        role: role,
        ariaMultiSelectable: multiSelectable,
        ariaLabel: ariaLabel,
        ariaLabelledBy: label ? headingId : ariaLabelledBy,
        children: [
            label != null && (0, _jsxruntime.jsx)(_menu.MenuDivider, {
                id: headingId,
                children: label
            }),
            options.map((option, i)=>{
                const selected = isSelected(option, value);
                const itemIndex = optionIndexOffset + i;
                const active = activeIndex === itemIndex;
                const id = (0, _base_select_util.deriveIdentifier)(menuId, itemIndex);
                return (0, _jsxruntime.jsx)(_react.Fragment, {
                    children: item({
                        id,
                        selected,
                        active,
                        forwardedRef: active ? activeItemRef : undefined,
                        onItemClick,
                        onItemHover,
                        getLabel,
                        option,
                        multiSelectable
                    })
                }, id);
            })
        ]
    });
}
function WindowedSelectMenu(props) {
    const { Item = BaseSelectItem, item = (props)=> (0, _jsxruntime.jsx)(Item, {
            ...props
        }), optionGroups, flatOptions, value, activeIndex, id, ariaLabel, ariaLabelledBy, header, footer, isSelected, getLabel, onItemClick, onItemHover, className, children, sizingMode, itemHeightMultiplier = _menu.ITEM_HEIGHT_MULTIPIER } = props;
    const rootFontSize = _react.useMemo(()=>{
        return (0, _metrics.getRootFontSize)();
    }, []);
    const textZoomBaseUnit = (0, _metrics.useTextZoomBaseUnit)(rootFontSize);
    const itemSizes = _react.useMemo(()=>{
        const itemSizes = [];
        optionGroups.forEach((optionGroup, groupIndex)=>{
            optionGroup.options.forEach((option, optionIndex)=>{
                let height = itemHeightMultiplier * textZoomBaseUnit;
                if (optionIndex === 0 && groupIndex > 0)
                    height += _menu.DIVIDER_HEIGHT_MULTIPIER * textZoomBaseUnit;
                if (optionIndex === 0 && optionGroup.label != null)
                    height += _menu.TEXT_DIVIDER_HEIGHT_MULTIPIER * textZoomBaseUnit;
                itemSizes.push(height);
            });
        });
        return itemSizes;
    }, [
        itemHeightMultiplier,
        optionGroups,
        textZoomBaseUnit
    ]);
    const { scrollRef, activeItemRef } = useScrollToActiveItem({
        activeIndex
    });
    _react.useEffect(()=>{
        if (!scrollRef.current || activeIndex == null || activeIndex < 5)
            return;
        const activeOptionHeight = itemSizes[activeIndex];
        const activeOptionPosition = itemSizes.slice(0, activeIndex).reduce((a, h)=>a + h);
        const paddingTop = parseInt(window.getComputedStyle(scrollRef.current).paddingTop, 10);
        const scrollOffset = scrollRef.current.offsetHeight - paddingTop - activeOptionHeight;
        scrollRef.current.scrollTop = activeOptionPosition - scrollOffset;
    }, []);
    const hasMultipleGroups = optionGroups.length > 1;
    return (0, _jsxruntime.jsx)(WithHeaderAndFooter, {
        header: header,
        footer: footer,
        children: (0, _jsxruntime.jsx)(_scroll_window.ScrollWindow, {
            layout: "vertical",
            children: ({ scrollableRef, scrollState })=>(0, _jsxruntime.jsx)("div", {
                    className: (0, _classnames.default)(_base_selectcss.default.scrollContainer, sizingMode === 'fixed' && _base_selectcss.default.popover, className),
                    ref: (0, _compose_refs.composeRefs)(scrollableRef, scrollRef),
                    id: hasMultipleGroups ? id : undefined,
                    role: hasMultipleGroups ? 'listbox' : undefined,
                    "aria-label": hasMultipleGroups ? ariaLabel : undefined,
                    "aria-labelledby": hasMultipleGroups ? ariaLabelledBy : undefined,
                    children: children ? (0, _jsxruntime.jsx)("div", {
                        role: "alert",
                        children: children
                    }) : (0, _jsxruntime.jsx)(_scroll_window.WindowedList, {
                        scrollState: scrollState,
                        itemSizes: itemSizes,
                        overscan: 2,
                        children: (state, itemPositions)=>{
                            if (!state) return (0, _jsxruntime.jsx)("div", {
                                role: "none",
                                style: {
                                    height: itemPositions[itemPositions.length - 1]
                                }
                            });
                            const { firstVisible, lastVisible } = state;
                            const spaceBefore = itemPositions[firstVisible];
                            const spaceAfter = itemPositions[itemPositions.length - 1] - itemPositions[lastVisible];
                            const visibleGroups = (0, _base_select_util.sliceOptionGroups)(optionGroups, firstVisible, lastVisible);
                            return (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
                                children: [
                                    (0, _jsxruntime.jsx)("div", {
                                        role: "none",
                                        style: {
                                            height: spaceBefore
                                        }
                                    }),
                                    visibleGroups.map((optionGroup)=>{
                                        const isFirstItemVisible = optionGroup.slice[0] === 0;
                                        return (0, _jsxruntime.jsxs)(_react.Fragment, {
                                            children: [
                                                optionGroup.originalIndex > 0 && isFirstItemVisible && (0, _jsxruntime.jsx)("div", {
                                                    className: _base_selectcss.default.groupDivider,
                                                    children: (0, _jsxruntime.jsx)(_divider.Divider, {})
                                                }),
                                                (0, _jsxruntime.jsx)(OptionGroup, {
                                                    item: item,
                                                    menuId: id,
                                                    id: hasMultipleGroups ? undefined : id,
                                                    role: hasMultipleGroups ? 'group' : 'listbox',
                                                    ariaLabel: hasMultipleGroups ? optionGroup.label : ariaLabel,
                                                    ariaLabelledBy: hasMultipleGroups ? undefined : ariaLabelledBy,
                                                    activeItemRef: activeItemRef,
                                                    value: value,
                                                    optionIndexOffset: flatOptions.findIndex((o)=>o === optionGroup.options[0]),
                                                    activeIndex: activeIndex,
                                                    label: isFirstItemVisible ? optionGroup.label : undefined,
                                                    options: optionGroup.options,
                                                    isSelected: isSelected,
                                                    onItemClick: onItemClick,
                                                    onItemHover: onItemHover,
                                                    getLabel: getLabel
                                                })
                                            ]
                                        }, optionGroup.originalIndex);
                                    }),
                                    (0, _jsxruntime.jsx)("div", {
                                        role: "none",
                                        style: {
                                            height: spaceAfter
                                        }
                                    })
                                ]
                            });
                        }
                    })
                })
        })
    });
}
function WithHeaderAndFooter(props) {
    const { header, footer, children } = props;
    return (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
        children: [
            header && (0, _jsxruntime.jsx)("header", {
                className: _base_selectcss.default.menuHeader,
                children: typeof header === 'string' ? (0, _jsxruntime.jsx)(_typography.Text, {
                    children: header
                }) : header
            }),
            children,
            footer && (0, _jsxruntime.jsx)("footer", {
                className: _base_selectcss.default.menuFooter,
                children: typeof footer === 'string' ? (0, _jsxruntime.jsx)(_typography.Text, {
                    children: footer
                }) : footer
            })
        ]
    });
}
function renderEmptyMenuContent() {
    return (0, _jsxruntime.jsx)(_box.Box, {
        padding: "3u",
        children: (0, _jsxruntime.jsx)(_typography.Text, {
            children: _base_selectmessages.BaseSelectMessages.defaultEmptyMessage()
        })
    });
}
const BaseSelectItem = _react.memo(BaseSelectItem_);
function BaseSelectItem_(props) {
    const { onItemClick, onItemHover, option, multiSelectable } = props;
    const onClick = _react.useCallback((event)=>{
        onItemClick?.(option, event);
    }, [
        onItemClick,
        option
    ]);
    const onMouseEnter = _react.useCallback((event)=>{
        onItemHover?.(option, event);
    }, [
        onItemHover,
        option
    ]);
    const OptionIcon = option.Icon && (0, _jsxruntime.jsx)(option.Icon, {
        size: "medium"
    });
    const SelectedIcon = !multiSelectable && props.selected ? (0, _jsxruntime.jsx)(_icon.CheckIcon, {
        size: "medium"
    }) : undefined;
    const CheckboxIcon = (0, _jsxruntime.jsx)(_checkbox.FakeCheckbox, {
        checked: props.selected,
        disabled: props.option.disabled
    });
    const start = multiSelectable ? (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
        children: [
            CheckboxIcon,
            props.start ?? OptionIcon
        ]
    }) : props.start ?? OptionIcon;
    const end = props.end ?? SelectedIcon;
    const content = props.children ?? (props.option.description != null ? (0, _jsxruntime.jsxs)(_layout.Rows, {
        tagName: "span",
        spacing: "0",
        children: [
            (0, _jsxruntime.jsx)(_typography.Text, {
                tagName: "span",
                lineClamp: 1,
                tone: _typography.InheritColor,
                children: props.getLabel(props.option)
            }),
            (0, _jsxruntime.jsx)(_typography.Text, {
                tagName: "span",
                size: "small",
                tone: option.disabled ? _typography.InheritColor : 'tertiary',
                children: props.option.description
            })
        ]
    }) : props.getLabel(props.option));
    return (0, _jsxruntime.jsx)(_menu.MenuItem, {
        id: props.id,
        ariaSelected: props.selected,
        buttonRef: props.forwardedRef,
        tabIndex: -1,
        onClick: onClick,
        onMouseEnter: onMouseEnter,
        start: start,
        end: end,
        className: (0, _classnames.default)(props.className, {
            [_base_selectcss.default.active]: props.active,
            [_base_selectcss.default.disabled]: props.option.disabled
        }),
        disabled: props.option.disabled,
        children: content
    });
}
const WrappedFlyout = (props)=>{
    return (0, _jsxruntime.jsx)("div", {
        children: (0, _sheet.useTypicalSheetAdaptation)() ? (0, _jsxruntime.jsx)(_sheet.Sheet, {
            markOutsideInert: false,
            ...props
        }) : (0, _jsxruntime.jsx)(_popover.Popover, {
            ...props
        })
    });
};
