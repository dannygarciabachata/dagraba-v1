"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get AnchorInner () {
        return AnchorInner;
    },
    get AnchorWithTooltip () {
        return AnchorWithTooltip;
    },
    get ButtonInner () {
        return ButtonInner;
    },
    get CircleButtonWithLabel () {
        return CircleButtonWithLabel;
    },
    get CircleButtonWithoutLabel () {
        return CircleButtonWithoutLabel;
    },
    get InternalAnchor () {
        return InternalAnchor;
    },
    get InternalButton () {
        return InternalButton;
    },
    get renderButtonOrAnchor () {
        return renderButtonOrAnchor;
    },
    get useShouldDisableSubmit () {
        return useShouldDisableSubmit;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _compose_refs = require('../../../../base/react/compose_refs');
const _classnames = _interop_require_default(require("classnames"));
const _mobxreactlite = require("mobx-react-lite");
const _react = _interop_require_wildcard(require("react"));
const _access_mode_state = require('../../a11y/access_mode_state/access_mode_state');
const _announcer = require('../../a11y/announcer/announcer');
const _button_aria_attributes = require('../../a11y/button_aria_attributes/button_aria_attributes');
const _pointer_input_state = require('../../a11y/pointer_input_state/pointer_input_state');
const _screen_reader_content = require('../../a11y/screen_reader_content/screen_reader_content');
const _handle = require('../../handle/handle');
const _skip_render_on_client = require('../../hydration/skip_render_on_client');
const _use_isomorphic_layout_effect = require('../../hydration/use_isomorphic_layout_effect');
const _icon = require('../../icons/animated_spinner/icon');
const _provider = require('../../provider/provider');
const _tooltip = require('../../tooltip/tooltip');
const _truncated = require('../../typography/truncated/truncated');
const _typography = require('../../typography/typography');
const _buttoncss = _interop_require_wildcard(require("./button.css"));
const _buttonmessages = require("./button.messages");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const getButtonContent = (props)=>{
    const { children, iconPosition = 'start', noChildWrapper, icon: Icon, LoadingIcon = _icon.AnimatedSpinnerIcon, isTruncatedRef } = props;
    const content = [];
    let displayIcon = null;
    const hiddenAttrs = {
        ['aria-hidden']: props.loading || undefined
    };
    if (Icon) displayIcon = (0, _jsxruntime.jsx)("span", {
        className: _buttoncss.default.iconWrapper,
        ...hiddenAttrs,
        children: (0, _jsxruntime.jsx)(Icon, {
            size: props.iconSize || 'medium'
        })
    }, "icon");
    if (iconPosition === 'start' || iconPosition === 'top') content.push(displayIcon);
    if (children) content.push(noChildWrapper ? children : (0, _jsxruntime.jsx)("span", {
        className: _buttoncss.default.text,
        ref: isTruncatedRef,
        ...hiddenAttrs,
        children: children
    }, "content"));
    if (iconPosition === 'end') content.push(displayIcon);
    if (props.loading) {
        const loadingIconSize = props.iconSize || 'medium';
        content.push((0, _jsxruntime.jsxs)("span", {
            className: _buttoncss.default.loadingIconWrapper,
            children: [
                (0, _jsxruntime.jsx)(LoadingIcon, {
                    size: loadingIconSize
                }),
                (0, _jsxruntime.jsx)(_screen_reader_content.ScreenReaderContent, {
                    children: props.loadingMessage || _buttonmessages.ButtonMessages.loading()
                })
            ]
        }, "loading"));
    }
    return content;
};
const useClassName = (isAnchor, { children, alignment = 'center', active, selected, pressed, disableActiveStyle, disclosure, loading, loadingVariant, disabled, stretch, variant, hideOutline, iconPosition, shape, size, expandClickableArea, icon, iconSize })=>{
    const trueSize = getSize({
        children,
        iconSize,
        size,
        variant
    });
    const squareSizing = allowSquareSizing({
        children,
        variant,
        stretch,
        icon
    });
    const iconOnly = icon != null && !children;
    const enableButtonLoadingScan = (0, _provider.useEnableButtonLoadingScan)();
    loadingVariant ?? (loadingVariant = enableButtonLoadingScan ? 'scan' : 'spinner');
    return (0, _classnames.default)(_buttoncss.default.base, {
        [_buttoncss.default.anchor]: isAnchor,
        [_buttoncss.default.button]: variant !== 'basic',
        [_buttoncss.default.hideOutline]: hideOutline,
        [_buttoncss.default.topIcon]: iconPosition === 'top',
        [_buttoncss.default.startIcon]: !iconOnly && icon && (!iconPosition || iconPosition === 'start'),
        [_buttoncss.default.endIcon]: !iconOnly && icon && iconPosition === 'end',
        [_buttoncss.default.noMinWidth]: squareSizing,
        [_buttoncss.default.circleShape]: shape === 'circle',
        [_buttoncss.default.expandClickableArea]: expandClickableArea
    }, (0, _buttoncss.getStyle)(variant), !disableActiveStyle && getStateStyle({
        active,
        disclosure,
        selected,
        pressed
    }), trueSize && (0, _buttoncss.getStyle)(trueSize), {
        [_buttoncss.default.stretch]: stretch,
        [_buttoncss.default.spinner]: loading && loadingVariant === 'spinner',
        [_buttoncss.default.scanning]: loading && loadingVariant === 'scan',
        [_buttoncss.default.disabled]: disabled,
        [_buttoncss.default.startAlign]: alignment === 'start',
        [_buttoncss.default.centerAlign]: iconOnly || alignment === 'center',
        [_buttoncss.default.endAlign]: alignment === 'end',
        [_buttoncss.default.hoverSupported]: (0, _pointer_input_state.useIsHoveringInput)(),
        [_buttoncss.default.animate]: (0, _provider.useEnableAnimations)(),
        [_buttoncss.default.tinyWidth]: trueSize === 'tiny' && squareSizing,
        [_buttoncss.default.xsmallWidth]: trueSize === 'xsmall' && squareSizing,
        [_buttoncss.default.smallWidth]: trueSize === 'small' && squareSizing,
        [_buttoncss.default.mediumWidth]: trueSize === 'medium' && squareSizing,
        [_buttoncss.default.largeWidth]: trueSize === 'large' && squareSizing
    });
};
function getStateStyle(props) {
    const selected = props.selected ?? (props.disclosure ? undefined : props.active);
    const pressed = props.pressed ?? (props.disclosure ? props.active : undefined);
    return {
        [_buttoncss.default.selected]: selected,
        [_buttoncss.default.activeDisclosure]: pressed
    };
}
const useShouldDisableSubmit = (initialShouldDisableSubmit)=>{
    const [disableSubmit, setDisableSubmit] = _react.useState(initialShouldDisableSubmit);
    (0, _use_isomorphic_layout_effect.useIsomorphicLayoutEffect)(()=>{
        setDisableSubmit(false);
    }, []);
    return disableSubmit;
};
const ButtonInner = (0, _mobxreactlite.observer)(function ButtonInner({ ref, ...props }) {
    const buttonRef = _react.useRef(null);
    _react.useImperativeHandle(ref, ()=>(0, _handle.createBasicHTMLHandle)(buttonRef), [
        buttonRef
    ]);
    const composedRef = (0, _compose_refs.composeRefs)(buttonRef, props.buttonRef, ref);
    const isSubmitButton = props.type === 'submit';
    const disabledAttribute = useShouldDisableSubmit(isSubmitButton);
    const disabledStyle = disabledAttribute || props.disabled;
    const disabled = disabledAttribute || props.disabled || props.loading;
    const className = useClassName(false, {
        ...props,
        hideOutline: _access_mode_state.accessModeState.isMouseMode,
        disabled: disabledStyle
    });
    const elevationEnabled = props.elevated && props.shape === 'circle' && props.variant !== 'contrast';
    const loadingMessage = props.loadingMessage ?? _buttonmessages.ButtonMessages.loading();
    const loadingFinishedMessage = props.loadingFinishedMessage ?? _buttonmessages.ButtonMessages.loadingFinished();
    (0, _announcer.useAnnounceWhen)(loadingMessage, !!props.loading, {
        priority: 'high'
    });
    (0, _announcer.useAnnounceWhen)(loadingFinishedMessage, !props.loading, {
        priority: 'high',
        skipInitialRender: true
    });
    const children = getButtonContent({
        ...props,
        loadingMessage
    });
    const onClickImpl = props.onClick;
    const onClick = _react.useCallback((e)=>{
        if (disabled) e.preventDefault();
        else onClickImpl?.(e);
    }, [
        disabled,
        onClickImpl
    ]);
    const stopPropagationWhenDisabled = disabled ? (e)=>{
        const shouldPrevent = [
            'click',
            'mousedown',
            'mouseup',
            'submit'
        ].includes(e.type) || !('code' in e) || [
            'Enter',
            'Space'
        ].includes(e.code);
        if (shouldPrevent) {
            e.stopPropagation();
            e.preventDefault();
        }
    } : undefined;
    return (0, _jsxruntime.jsx)(ElevatedWrapper, {
        containerClassName: props.containerClassName,
        enabled: elevationEnabled,
        children: (0, _jsxruntime.jsxs)("button", {
            ref: composedRef,
            id: props.id,
            onMouseDown: (e)=>_access_mode_state.accessModeState.setAccessMode('mouse') && props.onMouseDown?.(e),
            className: (0, _classnames.default)(className, props.className),
            form: props.form,
            onMouseUp: props.onMouseUp,
            onMouseEnter: props.onMouseEnter,
            onMouseLeave: props.onMouseLeave,
            onPointerDown: props.onPointerDown,
            onPointerUp: props.onPointerUp,
            onPointerLeave: props.onPointerLeave,
            onContextMenu: props.onContextMenu,
            onBlur: props.onBlur,
            onFocus: props.onFocus,
            onDragStart: props.onDragStart,
            onDragEnd: props.onDragEnd,
            draggable: props.draggable,
            onClick: onClick,
            onClickCapture: stopPropagationWhenDisabled,
            onMouseDownCapture: stopPropagationWhenDisabled,
            onKeyDownCapture: stopPropagationWhenDisabled,
            onMouseUpCapture: stopPropagationWhenDisabled,
            disabled: disabledAttribute,
            type: props.type || 'button',
            ...(0, _button_aria_attributes.getButtonAriaAttributes)({
                ...props,
                tagName: 'button',
                selected: props.ariaPressed ?? props.selected,
                disabled
            }),
            children: [
                (0, _jsxruntime.jsx)(LoadingScan, {
                    loading: props.loading,
                    buttonRef: buttonRef
                }),
                children
            ]
        })
    });
});
function LoadingScan({ loading, buttonRef }) {
    const [width, setWidth] = _react.useState(undefined);
    _react.useEffect(()=>{
        setWidth(loading ? buttonRef.current?.offsetWidth : undefined);
    }, [
        loading,
        buttonRef
    ]);
    if (!loading || !width) return null;
    return (0, _jsxruntime.jsx)("span", {
        style: {
            [_buttoncss.customProperties.buttonWidth]: `${width}px`
        },
        className: _buttoncss.default.oval
    });
}
const AnchorInner = (0, _mobxreactlite.observer)(function AnchorInner({ ref, ...props }) {
    const anchorRef = _react.useRef(null);
    _react.useImperativeHandle(ref, ()=>(0, _handle.createBasicHTMLHandle)(anchorRef), [
        anchorRef
    ]);
    const composedRef = (0, _compose_refs.composeRefs)(anchorRef, props.buttonRef, ref);
    const semanticallyDisabled = props.disabled || props.loading;
    const targetBlank = props.target === '_blank';
    const rel = targetBlank && !props.rel ? 'noopener' : props.rel;
    const className = useClassName(true, {
        ...props,
        hideOutline: _access_mode_state.accessModeState.isMouseMode
    });
    const loadingMessage = props.loadingMessage ?? _buttonmessages.ButtonMessages.loading();
    const loadingFinishedMessage = props.loadingFinishedMessage ?? _buttonmessages.ButtonMessages.loadingFinished();
    (0, _announcer.useAnnounceWhen)(loadingMessage, !!props.loading, {
        priority: 'high'
    });
    (0, _announcer.useAnnounceWhen)(loadingFinishedMessage, !props.loading, {
        priority: 'high',
        skipInitialRender: true
    });
    const children = getButtonContent({
        ...props,
        loadingMessage
    });
    let linkProps;
    if (!semanticallyDisabled) linkProps = {
        onClick: props.onClick,
        onDragStart: props.onDragStart,
        onDragEnd: props.onDragEnd,
        onFocus: props.onFocus,
        onBlur: props.onBlur,
        onContextMenu: props.onContextMenu,
        onMouseEnter: props.onMouseEnter,
        onMouseLeave: props.onMouseLeave,
        href: props.href,
        target: props.target,
        rel,
        download: props.download,
        draggable: props.draggable
    };
    else
    linkProps = {
        onClick: (e)=>e.preventDefault(),
        onFocus: props.onFocus,
        onBlur: props.onBlur,
        onMouseEnter: props.onMouseEnter,
        onMouseLeave: props.onMouseLeave,
        href: props.href,
        target: props.target,
        download: props.download
    };
    return (0, _jsxruntime.jsxs)("a", {
        id: props.id,
        ref: composedRef,
        ...linkProps,
        className: (0, _classnames.default)(className, props.className),
        ...(0, _button_aria_attributes.getButtonAriaAttributes)({
            tagName: 'a',
            disabled: semanticallyDisabled,
            ...props
        }),
        children: [
            children,
            props.target != null && (0, _jsxruntime.jsx)(_skip_render_on_client.SkipRenderOnClient, {
                tagName: "span",
                shouldRenderOnClient: ()=>targetBlank,
                children: (0, _jsxruntime.jsx)(_screen_reader_content.ScreenReaderContent, {
                    tagName: "span",
                    children: _buttonmessages.ButtonMessages.opensInNewWindow()
                })
            })
        ]
    });
});
function ButtonWithTooltipInner({ buttonProps, tooltipTriggerProps, ref }) {
    const ariaProps = getAriaProps({
        props: buttonProps,
        tooltipTriggerProps
    });
    const onMouseEnter = (event)=>{
        buttonProps.onMouseEnter?.(event);
        tooltipTriggerProps.onMouseEnter?.();
    };
    const onMouseLeave = (event)=>{
        buttonProps.onMouseLeave?.(event);
        tooltipTriggerProps.onMouseLeave?.();
    };
    const onMouseDown = (event)=>{
        buttonProps.onMouseDown?.(event);
        tooltipTriggerProps.onMouseDown?.();
    };
    const onFocus = (event)=>{
        buttonProps.onFocus?.(event);
        tooltipTriggerProps.onFocus?.();
    };
    const onBlur = (event)=>{
        buttonProps.onBlur?.(event);
        tooltipTriggerProps.onBlur?.();
    };
    return (0, _jsxruntime.jsx)(ButtonInner, {
        ...buttonProps,
        ref: ref,
        ...ariaProps,
        onFocus: onFocus,
        onBlur: onBlur,
        onMouseEnter: onMouseEnter,
        onMouseLeave: onMouseLeave,
        onMouseDown: onMouseDown,
        tooltipLabel: undefined
    });
}
const ButtonWithTooltip = (0, _mobxreactlite.observer)(function ButtonWithTooltip({ ref, ...props }) {
    return (0, _jsxruntime.jsx)(_tooltip.Tooltip, {
        label: props.tooltipLabel,
        description: props.tooltipDescription,
        shortcut: props.tooltipShortcut,
        disabled: props.tooltipDisabled,
        placement: props.tooltipPlacement,
        lineClamp: props.tooltipLineClamp,
        closeOnClick: props.tooltipCloseOnClick,
        children: (triggerProps)=>{
            return (0, _jsxruntime.jsx)(ButtonWithTooltipInner, {
                ref: ref,
                buttonProps: props,
                tooltipTriggerProps: triggerProps
            });
        }
    });
});
function AnchorWithTooltipInner({ anchorProps, tooltipTriggerProps, ref }) {
    const ariaProps = getAriaProps({
        props: anchorProps,
        tooltipTriggerProps
    });
    const onMouseEnter = (event)=>{
        anchorProps.onMouseEnter?.(event);
        tooltipTriggerProps.onMouseEnter?.();
    };
    const onMouseLeave = (event)=>{
        anchorProps.onMouseLeave?.(event);
        tooltipTriggerProps.onMouseLeave?.();
    };
    const onMouseDown = (event)=>{
        anchorProps.onMouseDown?.(event);
        tooltipTriggerProps.onMouseDown?.();
    };
    const onFocus = (event)=>{
        anchorProps.onFocus?.(event);
        tooltipTriggerProps.onFocus?.();
    };
    const onBlur = (event)=>{
        anchorProps.onBlur?.(event);
        tooltipTriggerProps.onBlur?.();
    };
    return (0, _jsxruntime.jsx)(AnchorInner, {
        ...anchorProps,
        ref: ref,
        ...ariaProps,
        onFocus: onFocus,
        onBlur: onBlur,
        onMouseEnter: onMouseEnter,
        onMouseLeave: onMouseLeave,
        onMouseDown: onMouseDown,
        tooltipLabel: undefined
    });
}
const AnchorWithTooltip = (0, _mobxreactlite.observer)(function AnchorWithTooltip({ ref, ...props }) {
    return (0, _jsxruntime.jsx)(_tooltip.Tooltip, {
        label: props.tooltipLabel,
        description: props.tooltipDescription,
        shortcut: props.tooltipShortcut,
        disabled: props.tooltipDisabled,
        placement: props.tooltipPlacement,
        lineClamp: props.tooltipLineClamp,
        closeOnClick: props.tooltipCloseOnClick,
        children: (triggerProps)=>(0, _jsxruntime.jsx)(AnchorWithTooltipInner, {
                ref: ref,
                anchorProps: props,
                tooltipTriggerProps: triggerProps
            })
    });
});
function CircleButtonWithoutLabel({ ref, ...props }) {
    return (0, _jsxruntime.jsx)(InternalButton, {
        ...props,
        shape: "circle",
        ref: ref
    });
}
function CircleButtonWithLabel({ variant, children, tooltipLabel: tooltipLabelProp, ref, ...props }) {
    const labelId = _react.useId();
    const size = getSize({
        ...props,
        variant
    });
    const textChildren = typeof children === 'string' ? children : undefined;
    const { isTruncated, ref: isTruncatedRef } = (0, _truncated.useIsTruncated)(textChildren);
    const tooltipLabel = tooltipLabelProp || (isTruncated ? textChildren : undefined);
    return (0, _jsxruntime.jsxs)("div", {
        className: (0, _classnames.default)(_buttoncss.default.circleShapeWrapper, {
            [_buttoncss.default.circleShapeWrapperXsmall]: size === 'xsmall',
            [_buttoncss.default.circleShapeWrapperSmall]: size === 'small',
            [_buttoncss.default.circleShapeWrapperMedium]: size === 'medium',
            [_buttoncss.default.circleShapeWrapperLarge]: size === 'large'
        }),
        children: [
            (0, _jsxruntime.jsx)(InternalButton, {
                ...props,
                tooltipPlacement: props.tooltipPlacement || 'top',
                shape: "circle",
                ref: ref,
                variant: variant,
                ariaLabelledBy: labelId,
                tooltipLabel: tooltipLabel
            }),
            (0, _jsxruntime.jsx)("label", {
                className: _buttoncss.default.circleButtonLabel,
                children: (0, _jsxruntime.jsx)(_typography.Text, {
                    size: "small",
                    id: labelId,
                    tagName: "span",
                    alignment: "center",
                    tone: "secondary",
                    lineClamp: 2,
                    ref: typeof children !== 'object' ? isTruncatedRef : undefined,
                    children: children
                })
            })
        ]
    });
}
function getAriaProps({ props, tooltipTriggerProps }) {
    const ariaProps = {
        ariaLabel: props.ariaLabel
    };
    if ((props.children == null || typeof props.children !== 'string') && props.ariaLabelledBy == null && props.ariaLabel == null)
    ariaProps.ariaLabel = props.tooltipDescription != null ? `${props.tooltipLabel}: ${props.tooltipDescription}` : props.tooltipLabel;
    else {
        const hasRedundantTooltip = typeof props.children !== 'object' && props.children === props.tooltipLabel || props.ariaLabel === props.tooltipLabel;
        if (!hasRedundantTooltip && props.ariaDescribedBy == null) ariaProps.ariaDescribedBy = tooltipTriggerProps.tooltipId;
    }
    return ariaProps;
}
function allowSquareSizing({ children, stretch, variant, icon }) {
    return !children && !!icon && !stretch && [
        'subtleLinkButton'
    ].indexOf(variant) === -1;
}
function getSize({ children, iconSize, size, variant }) {
    if ([
        'subtleLinkButton'
    ].indexOf(variant) !== -1) return;
    if (size && size !== 'default') return size;
    if (variant === 'basic')
    return;
    if (!children && iconSize && [
        'tiny',
        'small',
        'large'
    ].indexOf(iconSize) !== -1) return iconSize;
    return 'medium';
}
const ElevatedWrapper = (0, _mobxreactlite.observer)(function ElevatedWrapper(props) {
    if (props.enabled) return (0, _jsxruntime.jsx)("span", {
        className: (0, _classnames.default)(_buttoncss.default.elevatedWrapper, props.containerClassName, props.isInsideButton && _buttoncss.default.elevatedWrapperInsideButton),
        children: props.children
    });
    return props.children;
});
function InternalButton({ tooltipLabel: tooltipLabelProp, ref, ...props }) {
    const textChildren = typeof props.children === 'string' ? props.children : undefined;
    const { isTruncated, ref: isTruncatedRef } = (0, _truncated.useIsTruncated)(textChildren);
    const trackTruncation = typeof props.children !== 'object' && props.variant !== 'basic';
    const tooltipLabel = tooltipLabelProp || (isTruncated && trackTruncation ? textChildren : undefined);
    if (tooltipLabel != null && tooltipLabel.length > 0) return (0, _jsxruntime.jsx)(ButtonWithTooltip, {
        ...props,
        ref: ref,
        isTruncatedRef: trackTruncation ? isTruncatedRef : undefined,
        tooltipLabel: tooltipLabel
    });
    return (0, _jsxruntime.jsx)(ButtonInner, {
        ...props,
        ref: ref,
        isTruncatedRef: trackTruncation ? isTruncatedRef : undefined,
        tooltipLabel: undefined,
        tooltipDescription: undefined
    });
}
function InternalAnchor({ tooltipLabel: tooltipLabelProp, ref, ...props }) {
    const textChildren = typeof props.children === 'string' ? props.children : undefined;
    const { isTruncated, ref: isTruncatedRef } = (0, _truncated.useIsTruncated)(textChildren);
    const trackTruncation = typeof props.children !== 'object' && props.variant !== 'basic';
    const tooltipLabel = tooltipLabelProp || (isTruncated ? textChildren : undefined);
    if (tooltipLabel != null && tooltipLabel.length > 0) return (0, _jsxruntime.jsx)(AnchorWithTooltip, {
        ref: ref,
        ...props,
        tooltipLabel: tooltipLabel,
        isTruncatedRef: trackTruncation ? isTruncatedRef : undefined
    });
    return (0, _jsxruntime.jsx)(AnchorInner, {
        ref: ref,
        ...props,
        tooltipLabel: undefined,
        tooltipDescription: undefined,
        isTruncatedRef: trackTruncation ? isTruncatedRef : undefined
    });
}
const renderButtonOrAnchor = ({ ...props }, ref)=>{
    if (props.type === 'link') return (0, _jsxruntime.jsx)(InternalAnchor, {
        ...props,
        ref: ref
    });
    return (0, _jsxruntime.jsx)(InternalButton, {
        ...props,
        ref: ref
    });
};
