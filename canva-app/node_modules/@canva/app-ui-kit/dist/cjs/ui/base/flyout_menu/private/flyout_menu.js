"use strict"
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get FlyoutMenu () {
        return FlyoutMenu;
    },
    get FlyoutMenuContent () {
        return FlyoutMenuContent;
    },
    get FlyoutMenuDivider () {
        return _menu.MenuDivider;
    },
    get FlyoutMenuItem () {
        return FlyoutMenuItem;
    },
    get FlyoutMenuStore () {
        return _flyout_menu_util.FlyoutMenuStore;
    },
    get StatelessFlyoutMenu () {
        return StatelessFlyoutMenu;
    },
    get useNavigableRef () {
        return _flyout_menu_util.useNavigableRef;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _callback_ref = require('../../../../base/react/callback_ref');
const _compose_refs = require('../../../../base/react/compose_refs');
const _classnames = _interop_require_default(require("classnames"));
const _mobx = require("mobx");
const _mobxreactlite = require("mobx-react-lite");
const _react = _interop_require_wildcard(require("react"));
const _button = require('../../button/button');
const _handle = require('../../handle/handle');
const _icon = require('../../icons/chevron_right/icon');
const _layout = require('../../layout/layout');
const _menu = require('../../menu/menu');
const _metrics = require('../../metrics/metrics');
const _flyout = require('../../surface/flyout/flyout');
const _flyout_menucss = _interop_require_default(require("./flyout_menu.css"));
const _flyout_menu_util = require("./flyout_menu_util");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function StatelessFlyoutMenu(props) {
    const { trigger = (props)=> (0, _jsxruntime.jsx)(_button.Button, {
            ...props,
            ref: props.focusRef
        }), label, disabled, open, flyoutPlacement = 'bottom-start', flyoutOffset, blockOutsidePointerEvents, captureFocus = false, id, role, ariaLabel, ariaLabelledBy, tagName: TagName = 'div', triggerFocusRef, triggerContainerRef, tone = 'secondary', size, icon, iconSize, iconPosition, onRequestClose, onRequestOpen, onClose, tooltipLabel, tooltipDisabled, tooltipPlacement, title, description, headerStart, headerEnd, headerAlignment, headerDivider = 'always', header, footer } = props;
    const className = (0, _classnames.default)(_flyout_menucss.default.triggerContainer, props.className);
    const onRequestToggle = _react.useCallback(()=>{
        if (!open) onRequestOpen();
        else onRequestClose();
    }, [
        open,
        onRequestClose,
        onRequestOpen
    ]);
    return (0, _jsxruntime.jsx)(TagName, {
        ref: (0, _callback_ref.toCallbackRef)(triggerContainerRef),
        className: className,
        role: role,
        children: (0, _jsxruntime.jsx)("div", {
            children: (0, _jsxruntime.jsx)(_flyout.Flyout, {
                open: open,
                captureFocus: captureFocus,
                onRequestClose: onRequestClose,
                onCloseComplete: onClose,
                blockOutsidePointerEvents: blockOutsidePointerEvents,
                placement: flyoutPlacement,
                offset: flyoutOffset,
                width: "52u",
                widthMode: "maximum",
                title: title,
                description: description,
                headerStart: headerStart,
                headerEnd: headerEnd,
                headerAlignment: headerAlignment,
                headerDivider: headerDivider,
                header: header,
                footer: footer,
                trigger: ({ ariaControls, disclosure, active, pressed })=>{
                    return trigger({
                        id,
                        disabled,
                        ariaHasPopup: 'menu',
                        variant: tone,
                        size,
                        icon,
                        iconSize,
                        iconPosition,
                        ariaLabel,
                        ariaLabelledBy,
                        focusRef: triggerFocusRef,
                        onClick: onRequestToggle,
                        onRequestToggle,
                        tooltipLabel,
                        tooltipDisabled,
                        tooltipPlacement,
                        ariaControls,
                        disclosure,
                        active,
                        pressed,
                        children: label
                    });
                },
                children: (0, _jsxruntime.jsx)(_menu.Menu, {
                    role: "menu",
                    ref: props.menuContainerRef,
                    className: (0, _classnames.default)(_flyout_menucss.default.flyoutMenuContent),
                    ariaLabelledBy: id,
                    children: props.children
                })
            })
        })
    });
}
const FlyoutMenu = (0, _mobxreactlite.observer)((props)=>{
    const FlyoutMenuContext = (0, _flyout_menu_util.useFlyoutMenuContext)(props.store);
    const parentFlyoutMenuStore = (0, _flyout_menu_util.useFlyoutMenuStore)();
    const navigableRef = (0, _flyout_menu_util.useNavigableRef)();
    const isControlled = props.open != null;
    const isNested = parentFlyoutMenuStore != null;
    const { store } = FlyoutMenuContext;
    store.parentStore = parentFlyoutMenuStore;
    const isOpen = props.open ?? store.open;
    const openRef = _react.useRef(isOpen);
    openRef.current = isOpen;
    const onRequestOpen = _react.useMemo(()=>{
        return props.onRequestOpen ?? (0, _mobx.action)(()=>{
            store.open = true;
        });
    }, [
        store,
        props.onRequestOpen
    ]);
    const onRequestClose = _react.useMemo(()=>{
        return props.onRequestClose ?? (0, _mobx.action)(()=>{
            store.open = false;
        });
    }, [
        store,
        props.onRequestClose
    ]);
    const open = _react.useCallback(()=>{
        if (!openRef.current) onRequestOpen();
    }, [
        onRequestOpen
    ]);
    const close = _react.useCallback(()=>{
        if (openRef.current) onRequestClose();
    }, [
        onRequestClose
    ]);
    const keyboardNavigation = (0, _flyout_menu_util.useFlyoutMenuKeyboardNavigation)({
        store,
        onExit: props.captureFocus ? undefined : onRequestClose
    });
    const { triggerRef: triggerKeyCombinationRef, menuRef: menuKeyCombinationRef } = (0, _flyout_menu_util.useFlyoutMenuKeyCombinations)({
        isNested,
        isControlled,
        open,
        close,
        moveToFirst: keyboardNavigation.moveToFirst,
        moveToLast: keyboardNavigation.moveToLast
    });
    const { ref: triggerFocusRef } = (0, _flyout_menu_util.useFlyoutMenuAutoFocus)(isOpen);
    const { ref: menuHoverRef } = (0, _flyout_menu_util.useFlyoutMenuHover)({
        store,
        isOpen,
        close
    });
    const { onOpen } = props;
    _react.useEffect(()=>{
        return (0, _mobx.reaction)(()=>store.open, (open)=>{
            if (open == null) return;
            if (open) onOpen?.();
        });
    }, [
        store,
        onOpen
    ]);
    const end = props.end;
    const { trigger = isNested ? (triggerProps)=> (0, _jsxruntime.jsx)(NestedFlyoutMenuButton, {
            ref: triggerProps.focusRef,
            ...triggerProps,
            end: end
        }) : (triggerProps)=> (0, _jsxruntime.jsx)(_button.Button, {
            ref: triggerProps.focusRef,
            ...triggerProps
        }) } = props;
    const triggerId = _react.useId();
    const captureFocus = props.captureFocus || isOpen;
    return (0, _jsxruntime.jsx)(FlyoutMenuContext.Provider, {
        value: store,
        children: (0, _jsxruntime.jsx)(StatelessFlyoutMenu, {
            trigger: trigger,
            open: isOpen,
            disabled: props.disabled,
            triggerContainerRef: (0, _compose_refs.composeRefs)(triggerKeyCombinationRef, props.triggerContainerRef),
            triggerFocusRef: (0, _compose_refs.composeRefs)(triggerFocusRef, navigableRef, props.triggerFocusRef),
            menuContainerRef: (0, _compose_refs.composeRefs)(menuKeyCombinationRef, menuHoverRef, props.menuContainerRef, keyboardNavigation.ref),
            onRequestClose: onRequestClose,
            onRequestOpen: onRequestOpen,
            onClose: props.onClose,
            blockOutsidePointerEvents: props.blockOutsidePointerEvents,
            flyoutPlacement: isNested ? 'end-top' : props.flyoutPlacement,
            flyoutOffset: isNested ? {
                main: -_metrics.baseUnit / 4,
                cross: -_metrics.baseUnit
            } : undefined,
            label: props.label,
            tone: props.tone,
            size: props.size,
            icon: props.icon,
            iconSize: props.iconSize,
            tagName: isNested ? 'li' : 'div',
            className: props.className,
            iconPosition: props.iconPosition,
            captureFocus: captureFocus,
            id: props.id ?? triggerId,
            role: isNested ? 'none' : undefined,
            ariaLabel: props.ariaLabel,
            ariaLabelledBy: props.ariaLabelledBy,
            tooltipLabel: props.tooltipLabel,
            tooltipDisabled: props.tooltipDisabled,
            tooltipPlacement: props.tooltipPlacement,
            title: props.title,
            description: props.description,
            headerStart: props.headerStart,
            headerEnd: props.headerEnd,
            headerAlignment: props.headerAlignment,
            header: props.header,
            headerDivider: props.headerDivider,
            footer: props.footer,
            children: props.children
        })
    });
});
function FlyoutMenuContent(props) {
    const FlyoutMenuContext = (0, _flyout_menu_util.useFlyoutMenuContext)(props.store);
    const keyboardNavigation = (0, _flyout_menu_util.useFlyoutMenuKeyboardNavigation)({
        store: FlyoutMenuContext.store,
        onExit: props.onRequestClose
    });
    const className = (0, _classnames.default)(_flyout_menucss.default.flyoutMenuContent, props.className);
    const { ref: menuHoverRef } = (0, _flyout_menu_util.useFlyoutMenuHover)({
        store: FlyoutMenuContext.store
    });
    _react.useEffect(keyboardNavigation.moveToFirst, []);
    return (0, _jsxruntime.jsx)(FlyoutMenuContext.Provider, {
        value: FlyoutMenuContext.store,
        children: (0, _jsxruntime.jsx)(_menu.Menu, {
            role: "menu",
            className: className,
            ref: (0, _compose_refs.composeRefs)(props.ref, menuHoverRef, keyboardNavigation.ref),
            children: props.children
        })
    });
}
const NestedFlyoutMenuButton = _react.memo((props)=>{
    const store = (0, _flyout_menu_util.useFlyoutMenuStore)();
    const timeout = _react.useRef(undefined);
    const { onRequestToggle, ref: handleRef } = props;
    const open = props.pressed ?? props.active;
    const onMouseEnter = _react.useCallback(()=>{
        clearTimeout(timeout.current);
        if (!open) timeout.current = setTimeout(()=>{
            if (store?.parentStore?.currentlyOpenMenu == null) onRequestToggle();
        }, 400);
    }, [
        store,
        open,
        onRequestToggle
    ]);
    const onMouseLeave = _react.useCallback(()=>{
        clearTimeout(timeout.current);
    }, []);
    const onClick = _react.useCallback(()=>{
        if (!open) {
            clearTimeout(timeout.current);
            onRequestToggle();
        }
    }, [
        open,
        onRequestToggle
    ]);
    const { ref: hoverRef } = (0, _flyout_menu_util.useNestedTriggerHover)({
        isOpen: open
    });
    const buttonRef = (0, _handle.useHandleRef)(handleRef, _handle.createBasicHTMLHandle);
    return (0, _jsxruntime.jsx)(_menu.MenuItemButton, {
        onClick: props.disabled ? undefined : onClick,
        onMouseEnter: props.disabled ? undefined : onMouseEnter,
        onMouseLeave: props.disabled ? undefined : onMouseLeave,
        buttonRef: (0, _compose_refs.composeRefs)(hoverRef, buttonRef),
        pressed: open,
        selected: props.selected,
        disabled: props.disabled,
        disclosure: true,
        ariaHasPopup: "menu",
        id: props.id,
        role: "menuitem",
        ariaControls: props.ariaControls,
        ariaLabel: props.ariaLabel,
        ariaLabelledBy: props.ariaLabelledBy,
        tabIndex: -1,
        start: props.iconPosition !== 'end' && props.icon && (0, _jsxruntime.jsx)(props.icon, {
            size: "medium"
        }),
        end: (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
            children: [
                (0, _jsxruntime.jsx)(_layout.Spacer, {
                    direction: "horizontal",
                    size: "6u"
                }),
                typeof props.end === 'function' ? props.end() : props.end,
                props.iconPosition === 'end' && props.icon && (0, _jsxruntime.jsx)(props.icon, {
                    size: "medium"
                }),
                (0, _jsxruntime.jsx)(_icon.ChevronRightIcon, {
                    size: "medium"
                })
            ]
        }),
        children: props.children
    });
});
function FlyoutMenuItem(props) {
    const navigableRef = (0, _flyout_menu_util.useNavigableRef)({
        disabled: props.disabled
    });
    return (0, _jsxruntime.jsx)(_menu.MenuItem, {
        tabIndex: -1,
        buttonRef: (0, _compose_refs.composeRefs)(navigableRef, props.ref),
        className: props.className,
        label: props.label,
        description: props.description,
        disabled: props.disabled,
        onFocus: props.onFocus,
        onBlur: props.onBlur,
        onMouseEnter: props.onMouseEnter,
        onMouseLeave: props.onMouseLeave,
        start: props.start,
        end: (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
            children: [
                (0, _jsxruntime.jsx)(_layout.Spacer, {
                    direction: "horizontal",
                    size: "6u"
                }),
                typeof props.end === 'function' ? props.end() : props.end
            ]
        }),
        href: props.href,
        target: props.target,
        onClick: props.onClick,
        active: props.active,
        selected: props.selected,
        tooltipDisabled: props.tooltipDisabled,
        tooltipLabel: props.tooltipLabel,
        tooltipLineClamp: props.tooltipLineClamp,
        tooltipPlacement: props.tooltipPlacement,
        tooltipShortcut: props.tooltipShortcut,
        ariaLabel: props.ariaLabel,
        children: props.children
    });
}
