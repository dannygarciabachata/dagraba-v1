"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "Sheet", {
    enumerable: true,
    get: function() {
        return Sheet;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _preconditions = require('../../../../../base/preconditions');
const _compose_refs = require('../../../../../base/react/compose_refs');
const _classnames = _interop_require_default(require("classnames"));
const _react = _interop_require_wildcard(require("react"));
const _keyboard = require('../../../device_capabilities/keyboard');
const _viewport_variance = require('../../../device_capabilities/viewport_variance');
const _visual_viewport = require('../../../device_capabilities/visual_viewport');
const _use_isomorphic_layout_effect = require('../../../hydration/use_isomorphic_layout_effect');
const _layout = require('../../../layout/layout');
const _metrics = require('../../../metrics/metrics');
const _mobile_event_handler = require('../../../mobile_event_handler/mobile_event_handler');
const _get_safe_area_insets = require('../../../platform_quirks/get_safe_area_insets');
const _scroll = require('../../../scroll/scroll');
const _stable_function = require('../../../stable_function/stable_function');
const _backgroundcss = _interop_require_default(require('../../background/background.css'));
const _header = require('../../header/header');
const _content_container = require('../../internal/content_container');
const _reference_wrapper = require('../../internal/reference_wrapper');
const _scroll_padding = require('../../internal/scroll_padding');
const _trigger = require('../../internal/trigger');
const _behavior = require('../behavior/behavior');
const _content_scrollable = require("./content_scrollable");
const _sheetcss = _interop_require_wildcard(require("./sheet.css"));
const _sheet_wrapper = require("./sheet_wrapper");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function Sheet({ open, id: idProp, onOpenComplete, onCloseComplete, onBackButton, backdropVisible = true, markOutsideInert = backdropVisible, trigger, ref, ...inner }) {
    const defaultId = _react.useId();
    const id = idProp || defaultId;
    const handleBackButton = _react.useCallback((event)=>{
        if (!open || onBackButton == null && inner.onRequestClose == null) return;
        event.stopPropagation();
        if (onBackButton) {
            onBackButton(event);
            return;
        }
        inner.onRequestClose?.({
            action: 'backButton'
        });
    }, [
        open,
        onBackButton,
        inner
    ]);
    const resolvedTrigger = (0, _trigger.resolveTrigger)({
        open,
        id,
        role: inner.role,
        trigger
    });
    return (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
        children: [
            (0, _jsxruntime.jsx)(_reference_wrapper.ReferenceWrapper, {
                content: resolvedTrigger
            }),
            (0, _jsxruntime.jsx)(_sheet_wrapper.SheetWrapper, {
                open: open,
                onOpenComplete: onOpenComplete,
                onCloseComplete: onCloseComplete,
                markOutsideInert: markOutsideInert,
                children: (0, _jsxruntime.jsx)(_mobile_event_handler.MobileEventHandler, {
                    onBackButton: handleBackButton,
                    children: (0, _jsxruntime.jsx)(SheetInner, {
                        ...inner,
                        id: id,
                        backdropVisible: backdropVisible,
                        handleRef: ref
                    })
                })
            })
        ]
    });
}
const heightMap = {
    ['half']: 50,
    ['full']: 100
};
const dismissPoint = {
    type: 'fixed',
    height: 0
};
function resolveHeight(height) {
    if (height === 'auto') height = {
        autoUpTo: 'full'
    };
    return typeof height === 'string' ? {
        type: 'fixed',
        height: heightMap[height]
    } : {
        type: 'auto',
        height: heightMap[height.autoUpTo]
    };
}
const VIEWPORT_DEBOUNCE_DURATION = 600;
function SheetInner({ handleRef, height = 'auto', scrollToResizeBelow, onHeightChange, onRequestClose, onScroll, backdropVisible, handleSafeAreaInsetBottom = true, id, children, title, description, header, headerStart, headerEnd, headerAlignment = 'center', headerDivider = 'always', footer, handleVisible = 'auto', _tempVideoOnlyIgnoreVirtualKeyboardOffset = false, ...contentContainerProps }) {
    const heights = ensureArray(height);
    _preconditions.Preconditions.checkArgument(heights.length > 0, 'Sheets require at least one height value');
    const snapPoints = [
        ...heights.map(resolveHeight),
        ...(onRequestClose != null ? [
            dismissPoint
        ] : [])
    ];
    const [snapPointIndex, setSnapPointIndex] = useStabilizedSnapPoint({
        snapPoints,
        onSnapPointChange: (index)=>onHeightChange?.(heights[index])
    });
    const containerRef = _react.useRef(null);
    const footerRef = _react.useRef(null);
    const contentRef = _react.useRef(null);
    const endMarkerRef = _react.useRef(null);
    _react.useImperativeHandle(handleRef, ()=>({
            getScrollState: ()=>contentRef.current?.getScrollState(),
            setHeight: (height)=>{
                const newPoint = resolveHeight(height);
                const newIndex = snapPoints.findIndex((point)=>pointsEqual(point, newPoint));
                _preconditions.Preconditions.checkArgument(newIndex !== -1);
                setSnapPointIndex(newIndex);
            },
            scrollTo: (options)=>contentRef.current?.scrollTo(options),
            getBoundingClientRect: ()=>contentRef.current?.getBoundingClientRect(),
            get scrollTop () {
                return contentRef.current?.scrollTop;
            },
            get scrollLeft () {
                return contentRef.current?.scrollLeft;
            },
            get scrollHeight () {
                return contentRef.current?.scrollHeight;
            },
            get scrollWidth () {
                return contentRef.current?.scrollWidth;
            },
            get clientHeight () {
                return contentRef.current?.clientHeight;
            },
            get clientWidth () {
                return contentRef.current?.clientWidth;
            },
            get offsetHeight () {
                return contentRef.current?.offsetHeight;
            },
            get offsetWidth () {
                return contentRef.current?.offsetWidth;
            }
        }));
    const { resizing, controls } = (0, _behavior.useSheetControls)({
        snapPoints,
        snapPointIndex,
        setSnapPointIndex: (index)=>{
            if (onRequestClose != null && snapPoints[index] === dismissPoint) {
                onRequestClose({
                    action: 'resize'
                });
                return;
            }
            setSnapPointIndex(index);
        },
        getScrollHeight: ()=>{
            const endMarkerTop = endMarkerRef.current?.offsetTop ?? 0;
            const footerHeight = footerRef.current?.clientHeight ?? 0;
            const dragHandleContainerHeight = _metrics.baseUnit;
            return dragHandleContainerHeight + endMarkerTop + footerHeight + (0, _get_safe_area_insets.getSafeAreaInsets)().bottom;
        },
        setOffset: (offset, snapPointHeight)=>requestAnimationFrame(()=>{
                const el = containerRef.current;
                if (el == null) return;
                let finalOffset = offset;
                if (offset != null && offset > 0) {
                    if (el.clientHeight === snapPointHeight) finalOffset = undefined;
                }
                el.style.transform = finalOffset != null ? `translateY(${-finalOffset}px)` : '';
                const footerEl = footerRef.current;
                if (footerEl == null) return;
                const footerDisplacementY = el.clientHeight - (snapPointHeight ?? 0);
                footerEl.style.transform = finalOffset != null ? `translateY(${finalOffset - footerDisplacementY}px)` : '';
            })
    });
    const viewportDifferenceHeight = (0, _viewport_variance.useViewportHeightVariance)();
    const customPropertyRef = _react.useRef(null);
    const previousContainer = _react.useRef(undefined);
    (0, _visual_viewport.useViewportContainerSizeEffect)((maybeViewportContainer)=>{
        if (maybeViewportContainer == null || customPropertyRef.current == null) return;
        const viewportContainer = maybeViewportContainer;
        const customPropertyEl = customPropertyRef.current;
        const virtualKeyboardHeight = _tempVideoOnlyIgnoreVirtualKeyboardOffset ? 0 : (0, _keyboard.getVirtualKeyboardOverlayHeight)();
        const visualViewportHeight = viewportContainer.height - (virtualKeyboardHeight > 0 ? (0, _keyboard.getNonInteractiveHeight)() : 0);
        const { scrollHeight = 0, clientHeight = 0, scrollTop = 0 } = contentRef.current || {};
        function updateCustomProperties(viewportIsExpanding) {
            const virtualKeyboardHeight = (0, _keyboard.getVirtualKeyboardOverlayHeight)();
            const style = customPropertyEl.style;
            style.setProperty(_sheetcss.customProperties.visualViewportOffsetTop, `${viewportContainer.offsetTop}px`);
            style.setProperty(_sheetcss.customProperties.visualViewportHeight, `${visualViewportHeight}px`);
            style.setProperty(_sheetcss.customProperties.virtualKeyboardHeight, `${virtualKeyboardHeight}px`);
            const needScrollPositionAdjustment = !viewportIsExpanding && viewportContainer.offsetTop !== 0;
            const contentScrollBottom = scrollHeight - clientHeight - scrollTop;
            if (needScrollPositionAdjustment) {
                const { scrollHeight: newScrollHeight = 0, clientHeight: newClientHeight = 0 } = contentRef.current || {};
                const viewportTopDisplacement = viewportContainer.offsetTop - virtualKeyboardHeight;
                contentRef.current?.scrollTo({
                    top: viewportTopDisplacement + newScrollHeight - newClientHeight - contentScrollBottom
                });
            }
        }
        const previousHeight = previousContainer.current?.height ?? 0;
        previousContainer.current = viewportContainer;
        if (viewportContainer.height > previousHeight) {
            updateCustomProperties(true);
            return;
        }
        const id = setTimeout(updateCustomProperties, VIEWPORT_DEBOUNCE_DURATION);
        return ()=>clearTimeout(id);
    });
    const hasHandle = handleVisible === 'auto' && snapPoints.length > 1;
    const snapPoint = snapPoints[snapPointIndex];
    const snapHeight = calculateSnapHeight(snapPoint, resizing, containerRef);
    const onRequestCloseByBackdrop = _react.useCallback(()=>{
        onRequestClose?.({
            action: 'backdrop'
        });
    }, [
        onRequestClose
    ]);
    const [isScrolled, setIsScrolled] = _react.useState(false);
    const scrollTopRef = _react.useRef(0);
    const handleScroll = _react.useCallback(({ scrollTop })=>{
        onScroll?.({
            scrollTop
        });
        if (headerDivider !== 'when-scrolled') return;
        if (scrollTopRef.current === 0 && scrollTop > 0 || scrollTopRef.current > 0 && scrollTop === 0) {
            scrollTopRef.current = scrollTop;
            setIsScrolled(scrollTop > 0);
        }
    }, [
        onScroll,
        headerDivider,
        setIsScrolled,
        scrollTopRef
    ]);
    const { containerRef: scrollPaddingContainerRef, headerRef: scrollPaddingHeaderRef, footerRef: scrollPaddingFooterRef } = (0, _scroll_padding.useScrollPaddingRefs)();
    let content = (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
        children: [
            children,
            (0, _jsxruntime.jsx)("div", {
                ref: endMarkerRef
            })
        ]
    });
    const showHeaderDivider = headerDivider === 'always' || headerDivider === 'when-scrolled' && isScrolled;
    let endDecorator;
    if (headerEnd == null && onRequestClose != null) endDecorator = (0, _jsxruntime.jsx)(_header.SurfaceHeaderCloseButton, {
        onClick: ()=>onRequestClose()
    });
    else endDecorator = headerEnd === 'none' ? undefined : headerEnd;
    const standardHeader = title != null ? (0, _jsxruntime.jsx)(_header.SurfaceHeader, {
        title: title,
        description: description,
        start: headerStart,
        end: endDecorator,
        alignment: headerAlignment,
        divider: false
    }) : undefined;
    const hasDecorations = standardHeader != null || header != null || footer != null;
    if (hasDecorations) content = (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
        children: [
            (standardHeader != null || header != null) && (0, _jsxruntime.jsxs)("div", {
                ref: scrollPaddingHeaderRef,
                className: (0, _classnames.default)(_sheetcss.default.header, {
                    [_sheetcss.default.headerBorder]: showHeaderDivider
                }),
                children: [
                    standardHeader,
                    header
                ]
            }),
            (0, _jsxruntime.jsx)("div", {
                className: _sheetcss.default.content,
                children: content
            }),
            footer != null && (0, _jsxruntime.jsx)("div", {
                className: _sheetcss.default.footer,
                ref: (0, _compose_refs.composeRefs)(footerRef, scrollPaddingFooterRef),
                children: footer
            })
        ]
    });
    const isIos26OrAbove = getIsIos26OrAbove();
    const isFullHeight = snapPoint.height === heightMap['full'];
    return (0, _jsxruntime.jsxs)("div", {
        ref: customPropertyRef,
        className: (0, _classnames.default)(_sheetcss.default.sheetContainer, backdropVisible && _sheetcss.default.backdrop, hasDecorations && _sheetcss.default.hasDecorations, !isFullHeight && _sheetcss.default.sheetContainerTransition),
        style: {
            [_sheetcss.customProperties.viewportDifferenceHeight]: viewportDifferenceHeight,
            [_sheetcss.customProperties.snapHeight]: snapHeight
        },
        children: [
            (0, _jsxruntime.jsx)("div", {
                className: _sheetcss.default.safeAreaHandler,
                children: (0, _jsxruntime.jsxs)("div", {
                    className: (0, _classnames.default)(_sheetcss.default.sheet, snapPoint.type === 'auto' && _sheetcss.default.auto, resizing && _sheetcss.default.resizing),
                    ref: containerRef,
                    children: [
                        backdropVisible && onRequestClose != null && (0, _jsxruntime.jsx)("div", {
                            role: "none",
                            className: _sheetcss.default.dismissArea,
                            onClick: onRequestCloseByBackdrop
                        }),
                        hasHandle ? (0, _jsxruntime.jsx)(SheetDragHandle, {
                            controls: controls
                        }) : (0, _jsxruntime.jsx)(_layout.Spacer, {
                            size: "1u"
                        }),
                        (0, _jsxruntime.jsx)(SheetContent, {
                            ref: contentRef,
                            scrollPaddingRef: scrollPaddingContainerRef,
                            scrollToResizeBelow: scrollToResizeBelow && resolveHeight(scrollToResizeBelow),
                            controls: controls,
                            handleSafeAreaInsetBottom: handleSafeAreaInsetBottom,
                            id: id,
                            onScroll: handleScroll,
                            ...contentContainerProps,
                            children: content
                        })
                    ]
                })
            }),
            isIos26OrAbove && (0, _jsxruntime.jsx)("div", {
                className: _sheetcss.default.safari26ControlsBackground
            }),
            isIos26OrAbove && (0, _jsxruntime.jsx)("div", {
                className: _sheetcss.default.safari26KeyboardBackground
            })
        ]
    });
}
function ensureArray(argument) {
    if (Array.isArray(argument)) return argument;
    return [
        argument
    ];
}
function useStabilizedSnapPoint({ snapPoints, onSnapPointChange }) {
    const [index, setRawIndex] = _react.useState(0);
    const previousSnapPoints = _react.useRef(snapPoints);
    const setIndex = (0, _stable_function.useStableFunction)((newIndex)=>{
        setRawIndex(newIndex);
        if (!pointsEqual(snapPoints[newIndex], previousSnapPoints.current[index]))
            onSnapPointChange(newIndex);
    });
    (0, _use_isomorphic_layout_effect.useIsomorphicLayoutEffect)(()=>{
        const previousPoint = previousSnapPoints.current[index];
        if (!pointsEqual(snapPoints[index], previousPoint)) {
            let newIndex = snapPoints.findIndex((point)=>pointsEqual(point, previousPoint));
            if (newIndex === -1) newIndex = 0;
            setIndex(newIndex);
        }
        previousSnapPoints.current = snapPoints;
    }, [
        snapPoints,
        index,
        setIndex
    ]);
    return [
        Math.min(index, snapPoints.length - 1),
        setIndex
    ];
}
const pointsEqual = (a, b)=>a != null && b != null && a.type === b.type && a.height === b.height;
function calculateSnapHeight(snapPoint, resizing, containerRef) {
    switch(snapPoint.type){
        case 'fixed':
            return snapPoint.height + '%';
        case 'auto':
            if (!resizing)
                return snapPoint.height + '%';
            return (containerRef.current?.clientHeight ?? 0) - (0, _get_safe_area_insets.getSafeAreaInsets)().bottom + 'px';
        default:
            throw new _preconditions.UnreachableError(snapPoint);
    }
}
function SheetDragHandle({ controls }) {
    const { dragRef } = (0, _behavior.useSheetDrag)({
        controls
    });
    return (0, _jsxruntime.jsx)("div", {
        className: _sheetcss.default.dragHandleContainer,
        ref: dragRef,
        children: (0, _jsxruntime.jsx)("div", {
            className: _sheetcss.default.dragHandle
        })
    });
}
function SheetContent(
    { controls, scrollToResizeBelow, handleSafeAreaInsetBottom, onScroll, id, children, scrollPaddingRef, ref, ...contentContainerProps }
) {
    const { contentRef } = (0, _behavior.useSheetScroll)({
        controls,
        scrollToResizeBelow
    });
    const { hasScroll, contentScrollRef } = (0, _content_scrollable.useContentScrollable)();
    const imperativeScrollRef = useImperativeScrollRef(ref);
    const handleScroll = _react.useCallback((e)=>{
        const scrollTop = e.target?.scrollTop ?? 0;
        onScroll?.({
            scrollTop
        });
    }, [
        onScroll
    ]);
    return (0, _jsxruntime.jsx)(_content_container.ContentContainer, {
        ref: (0, _compose_refs.composeRefs)(contentRef, contentScrollRef, imperativeScrollRef, scrollPaddingRef),
        id: id,
        className: (0, _classnames.default)(_sheetcss.default.contentContainer, _backgroundcss.default.elevationSurfaceRaisedBackground, {
            [_sheetcss.default.handleSafeAreaInsetBottom]: handleSafeAreaInsetBottom,
            [_sheetcss.default.noTouchAction]: !hasScroll
        }),
        onScroll: handleScroll,
        ...contentContainerProps,
        children: children
    });
}
function useImperativeScrollRef(ref) {
    const innerRef = _react.useRef(null);
    _react.useImperativeHandle(ref, ()=>({
            getScrollState: ()=>innerRef.current ? (0, _scroll.getScrollState)(innerRef.current) : undefined,
            scrollTo: (options)=>{
                const el = innerRef?.current;
                if (el == null) return;
                if (typeof options === 'number') el.scrollTo(0, options);
                else el.scrollTo(options);
            },
            getBoundingClientRect: ()=>innerRef.current?.getBoundingClientRect(),
            get scrollTop () {
                return innerRef.current?.scrollTop;
            },
            get scrollLeft () {
                return innerRef.current?.scrollLeft;
            },
            get scrollHeight () {
                return innerRef.current?.scrollHeight;
            },
            get scrollWidth () {
                return innerRef.current?.scrollWidth;
            },
            get clientHeight () {
                return innerRef.current?.clientHeight;
            },
            get clientWidth () {
                return innerRef.current?.clientWidth;
            },
            get offsetHeight () {
                return innerRef.current?.offsetHeight;
            },
            get offsetWidth () {
                return innerRef.current?.offsetWidth;
            }
        }));
    return innerRef;
}
const globalNavigator = typeof navigator !== 'undefined' ? navigator : undefined;
const getIsIos26OrAbove = ()=>{
    return globalNavigator != null && !!globalNavigator.userAgent.match(/iPhone OS 18_/gi) && !globalNavigator.userAgent.match(/Version\/18/gi);
};
