{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/odgmusic/development/Da%20Graba_Studio/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client';\n\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\n\nexport const prisma = globalForPrisma.prisma || new PrismaClient();\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\n\nexport default prisma;\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA,MAAM;AAEC,MAAM,SAAS,gBAAgB,MAAM,IAAI,IAAI,yOAAY;AAEhE,wCAA2C,gBAAgB,MAAM,GAAG;uCAErD"}},
    {"offset": {"line": 62, "column": 0}, "map": {"version":3,"sources":["file:///Users/odgmusic/development/Da%20Graba_Studio/lib/ai/services/kie-service.ts"],"sourcesContent":["import { prisma } from '@/lib/prisma';\nimport { BaseMusicService, MusicGenerationRequest, TaskStatusResponse, VideoGenerationRequest, AudioEditRequest, ReplaceSectionRequest } from '../types';\n\ninterface KieTaskStatusResponse {\n    code: number;\n    msg: string;\n    data: {\n        taskId: string;\n        status: string;\n        errorMessage?: string;\n        response?: {\n            sunoData?: any[];\n        };\n    };\n}\n\nexport class KieService implements BaseMusicService {\n    private baseUrl = 'https://api.kie.ai/api/v1';\n\n    private async getApiKey(): Promise<string> {\n        try {\n            const dbSetting = await prisma.systemSetting.findUnique({\n                where: { key: 'KIE_API_KEY' }\n            });\n            if (dbSetting?.value) return dbSetting.value;\n        } catch (error) {\n            console.error('Failed to read KIE_API_KEY from DB, falling back to env');\n        }\n\n        const envKey = process.env.KIE_API_KEY;\n        if (!envKey) throw new Error('KIE_API_KEY is not configured');\n\n        return envKey;\n    }\n\n    async generateMusic(request: MusicGenerationRequest): Promise<string> {\n        const apiKey = await this.getApiKey();\n\n        // Map generic request to specific Kie/Suno format\n        const payload = {\n            prompt: request.prompt,\n            customMode: request.customMode ?? !!request.style,\n            instrumental: request.instrumental,\n            model: request.model || 'V4_5',\n            style: request.style,\n            title: request.title,\n            callBackUrl: request.callbackUrl || `${process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'}/api/ai/webhook`\n        };\n\n        const response = await fetch(`${this.baseUrl}/generate`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Bearer ${apiKey}`\n            },\n            body: JSON.stringify(payload)\n        });\n\n        const data = await response.json();\n\n        if (!response.ok || data.code !== 200) {\n            throw new Error(`KIE Generation failed: ${data.msg || 'Unknown error'}`);\n        }\n\n        return data.data.taskId;\n    }\n\n    async generateVideo(request: VideoGenerationRequest): Promise<string> {\n        const apiKey = await this.getApiKey();\n\n        const payload = {\n            taskId: request.taskId,\n            audioId: request.audioId,\n            callBackUrl: request.callBackUrl || `${process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'}/api/ai/webhook/video`,\n            author: request.author,\n            domainName: request.domainName\n        };\n\n        const response = await fetch(`${this.baseUrl}/mp4/generate`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Bearer ${apiKey}`\n            },\n            body: JSON.stringify(payload)\n        });\n\n        const data = await response.json();\n\n        if (!response.ok || data.code !== 200) {\n            throw new Error(`KIE Video Generation failed: ${data.msg || 'Unknown error'}`);\n        }\n\n        return data.data.taskId;\n    }\n\n    async getTaskStatus(taskId: string): Promise<TaskStatusResponse> {\n        const apiKey = await this.getApiKey();\n\n        const response = await fetch(`${this.baseUrl}/generate/record-info?taskId=${taskId}`, {\n            method: 'GET',\n            headers: {\n                'Authorization': `Bearer ${apiKey}`\n            }\n        });\n\n        const data: KieTaskStatusResponse = await response.json();\n\n        if (!response.ok || data.code !== 200) {\n            return {\n                status: 'ERROR',\n                taskId,\n                error: `Status check failed: ${data.msg || 'Unknown error'}`\n            };\n        }\n\n        const kieStatus = data.data.status;\n\n        // Map Suno specific statuses to our generic status\n        if (kieStatus === 'SUCCESS') {\n            return {\n                status: 'SUCCESS',\n                taskId,\n                tracks: data.data.response?.sunoData?.map(track => ({\n                    id: track.id,\n                    audioUrl: track.audioUrl,\n                    streamAudioUrl: track.streamAudioUrl,\n                    imageUrl: track.imageUrl,\n                    prompt: track.prompt,\n                    title: track.title,\n                    tags: track.tags,\n                    duration: track.duration,\n                    createTime: track.createTime\n                }))\n            };\n        }\n\n        if (kieStatus === 'PENDING') {\n            return { status: 'PENDING', taskId };\n        }\n\n        if (kieStatus === 'FIRST_SUCCESS' || kieStatus === 'TEXT_SUCCESS') {\n            return {\n                status: 'PARTIAL',\n                taskId,\n                tracks: data.data.response?.sunoData?.map(track => ({\n                    id: track.id,\n                    audioUrl: track.audioUrl,\n                    streamAudioUrl: track.streamAudioUrl,\n                    imageUrl: track.imageUrl,\n                    prompt: track.prompt,\n                    title: track.title,\n                    tags: track.tags,\n                    duration: track.duration,\n                    createTime: track.createTime\n                }))\n            };\n        }\n\n        // Handle error statuses\n        return {\n            status: 'ERROR',\n            taskId,\n            error: data.data.errorMessage || `Task failed with status: ${kieStatus}`\n        };\n    }\n\n    async getVideoTaskStatus(taskId: string): Promise<TaskStatusResponse> {\n        const apiKey = await this.getApiKey();\n\n        const response = await fetch(`${this.baseUrl}/mp4/record-info?taskId=${taskId}`, {\n            method: 'GET',\n            headers: {\n                'Authorization': `Bearer ${apiKey}`\n            }\n        });\n\n        const data = await response.json();\n\n        if (!response.ok || data.code !== 200) {\n            return {\n                status: 'ERROR',\n                taskId,\n                error: `Video Status check failed: ${data.msg || 'Unknown error'}`\n            };\n        }\n\n        const kieStatus = data.data?.response?.successFlag || data.data?.status;\n\n        if (kieStatus === 'SUCCESS') {\n            return {\n                status: 'SUCCESS',\n                taskId,\n                // The Video response from KIE will contain the mp4 url in the data, or response object.\n                // Assuming it comes in a `videoUrl` or similar based on typical payloads or callback structure.\n                // Reusing standard videoUrl mapping here based on the callback docs provided.\n                videoUrl: data.data?.response?.videoUrl || data.data?.response?.url || data.data?.videoUrl || data.data?.url\n            };\n        }\n\n        if (kieStatus === 'PENDING') {\n            return { status: 'PENDING', taskId };\n        }\n\n        return {\n            status: 'ERROR',\n            taskId,\n            error: data.data?.errorMessage || `Video task failed with status: ${kieStatus}`\n        };\n    }\n\n    async getMarketTaskStatus(taskId: string): Promise<TaskStatusResponse> {\n        const apiKey = await this.getApiKey();\n\n        const response = await fetch(`${this.baseUrl}/jobs/recordInfo?taskId=${taskId}`, {\n            method: 'GET',\n            headers: {\n                'Authorization': `Bearer ${apiKey}`\n            }\n        });\n\n        const data = await response.json();\n\n        if (!response.ok || data.code !== 200) {\n            return {\n                status: 'ERROR',\n                taskId,\n                error: `Market Status check failed: ${data.msg || 'Unknown error'}`\n            };\n        }\n\n        const kieState = data.data?.state;\n\n        if (kieState === 'success') {\n            let resultJsonObj = {};\n            try {\n                if (data.data?.resultJson) {\n                    resultJsonObj = JSON.parse(data.data.resultJson);\n                }\n            } catch (e) { /* ignore parse error */ }\n\n            return {\n                status: 'SUCCESS',\n                taskId,\n                // Using Tracks as a generic carrier for Market Model responses where resultUrls might be images\n                tracks: (resultJsonObj as any)?.resultUrls?.map((url: string, index: number) => ({\n                    id: `${taskId}_${index}`,\n                    audioUrl: url,\n                    imageUrl: url,\n                    title: `Market Output ${index}`,\n                    prompt: data.data?.param,\n                    tags: data.data?.model,\n                    duration: 0\n                })) || []\n            };\n        }\n\n        if (kieState === 'waiting' || kieState === 'queuing' || kieState === 'generating') {\n            return { status: 'PENDING', taskId };\n        }\n\n        return {\n            status: 'ERROR',\n            taskId,\n            error: data.data?.failMsg || `Market task failed with status: ${kieState}`\n        };\n    }\n\n    async addInstrumental(request: AudioEditRequest): Promise<string> {\n        const apiKey = await this.getApiKey();\n\n        const payload = {\n            uploadUrl: request.uploadUrl,\n            title: request.title,\n            tags: request.tags,\n            negativeTags: request.negativeTags,\n            model: request.model || 'V4_5PLUS',\n            vocalGender: request.vocalGender,\n            styleWeight: request.styleWeight,\n            weirdnessConstraint: request.weirdnessConstraint,\n            audioWeight: request.audioWeight,\n            callBackUrl: request.callBackUrl || `${process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'}/api/ai/webhook`\n        };\n\n        const response = await fetch(`${this.baseUrl}/generate/add-instrumental`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Bearer ${apiKey}`\n            },\n            body: JSON.stringify(payload)\n        });\n\n        const data = await response.json();\n\n        if (!response.ok || data.code !== 200) {\n            throw new Error(`KIE Add Instrumental failed: ${data.msg || 'Unknown error'}`);\n        }\n\n        return data.data.taskId;\n    }\n\n    async addVocals(request: AudioEditRequest): Promise<string> {\n        const apiKey = await this.getApiKey();\n\n        const payload = {\n            uploadUrl: request.uploadUrl,\n            prompt: request.prompt,\n            title: request.title,\n            style: request.style,\n            negativeTags: request.negativeTags,\n            model: request.model || 'V4_5PLUS',\n            vocalGender: request.vocalGender,\n            styleWeight: request.styleWeight,\n            weirdnessConstraint: request.weirdnessConstraint,\n            audioWeight: request.audioWeight,\n            callBackUrl: request.callBackUrl || `${process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'}/api/ai/webhook`\n        };\n\n        const response = await fetch(`${this.baseUrl}/generate/add-vocals`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Bearer ${apiKey}`\n            },\n            body: JSON.stringify(payload)\n        });\n\n        const data = await response.json();\n\n        if (!response.ok || data.code !== 200) {\n            throw new Error(`KIE Add Vocals failed: ${data.msg || 'Unknown error'}`);\n        }\n\n        return data.data.taskId;\n    }\n\n    async replaceSection(request: ReplaceSectionRequest): Promise<string> {\n        const apiKey = await this.getApiKey();\n\n        const payload = {\n            taskId: request.taskId,\n            audioId: request.audioId,\n            prompt: request.prompt,\n            tags: request.tags,\n            title: request.title,\n            infillStartS: request.infillStartS,\n            infillEndS: request.infillEndS,\n            negativeTags: request.negativeTags,\n            fullLyrics: request.fullLyrics,\n            callBackUrl: request.callBackUrl || `${process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'}/api/ai/webhook`\n        };\n\n        const response = await fetch(`${this.baseUrl}/generate/replace-section`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Bearer ${apiKey}`\n            },\n            body: JSON.stringify(payload)\n        });\n\n        const data = await response.json();\n\n        if (!response.ok || data.code !== 200) {\n            throw new Error(`KIE Replace Section failed: ${data.msg || 'Unknown error'}`);\n        }\n\n        return data.data.taskId;\n    }\n\n    async uploadAndExtend(request: AudioEditRequest & { continueAt: number, defaultParamFlag: boolean }): Promise<string> {\n        const apiKey = await this.getApiKey();\n\n        const payload: any = {\n            uploadUrl: request.uploadUrl,\n            defaultParamFlag: request.defaultParamFlag,\n            instrumental: request.instrumental || false,\n            continueAt: request.continueAt,\n            model: request.model || 'V4_5PLUS',\n            callBackUrl: request.callBackUrl || `${process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'}/api/ai/webhook`\n        };\n\n        if (request.defaultParamFlag) {\n            if (payload.instrumental) {\n                payload.style = request.style;\n                payload.title = request.title;\n            } else {\n                payload.style = request.style;\n                payload.title = request.title;\n                payload.prompt = request.prompt;\n            }\n        } else {\n            payload.prompt = request.prompt; // Used as lyrics\n        }\n        \n        // Optional\n        if (request.negativeTags) payload.negativeTags = request.negativeTags;\n        if (request.vocalGender) payload.vocalGender = request.vocalGender;\n        if (request.styleWeight) payload.styleWeight = request.styleWeight;\n        if (request.weirdnessConstraint) payload.weirdnessConstraint = request.weirdnessConstraint;\n        if (request.audioWeight) payload.audioWeight = request.audioWeight;\n\n        const response = await fetch(`${this.baseUrl}/generate/upload-extend`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Bearer ${apiKey}`\n            },\n            body: JSON.stringify(payload)\n        });\n\n        const data = await response.json();\n\n        if (!response.ok || data.code !== 200) {\n            throw new Error(`KIE Upload and Extend failed: ${data.msg || 'Unknown error'}`);\n        }\n\n        return data.data.taskId;\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 421, "column": 0}, "map": {"version":3,"sources":["file:///Users/odgmusic/development/Da%20Graba_Studio/lib/ai/services/musicgpt-service.ts"],"sourcesContent":["import { prisma } from '@/lib/prisma';\nimport { BaseMusicService, MusicGenerationRequest, TaskStatusResponse } from '../types';\n\nexport class MusicGptService implements BaseMusicService {\n\n    private async getApiKey(): Promise<string> {\n        try {\n            const dbSetting = await prisma.systemSetting.findUnique({\n                where: { key: 'MUSICGPT_API_KEY' }\n            });\n            if (dbSetting?.value) return dbSetting.value;\n        } catch (error) {\n            console.error('Failed to read MUSICGPT_API_KEY from DB, falling back to env');\n        }\n\n        const envKey = process.env.MUSICGPT_API_KEY;\n        if (!envKey) throw new Error('MUSICGPT_API_KEY is not configured');\n\n        return envKey;\n    }\n\n    async generateMusic(request: MusicGenerationRequest): Promise<string> {\n        const apiKey = await this.getApiKey();\n\n        // This is a stub implementation meant to be populated when MusicGPT documentation is provided.\n        console.log(`[MusicGPT] Triggering generation with key ending in: ...${apiKey.slice(-4)}`);\n\n        // Return a mock task ID for now\n        return `mgpt_task_${Date.now()}`;\n    }\n\n    async getTaskStatus(taskId: string): Promise<TaskStatusResponse> {\n        // Stub polling response\n        return {\n            status: 'PENDING',\n            taskId\n        };\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;;AAGO,MAAM;IAET,MAAc,YAA6B;QACvC,IAAI;YACA,MAAM,YAAY,MAAM,4JAAM,CAAC,aAAa,CAAC,UAAU,CAAC;gBACpD,OAAO;oBAAE,KAAK;gBAAmB;YACrC;YACA,IAAI,WAAW,OAAO,OAAO,UAAU,KAAK;QAChD,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC;QAClB;QAEA,MAAM,SAAS,QAAQ,GAAG,CAAC,gBAAgB;QAC3C,IAAI,CAAC,QAAQ,MAAM,IAAI,MAAM;QAE7B,OAAO;IACX;IAEA,MAAM,cAAc,OAA+B,EAAmB;QAClE,MAAM,SAAS,MAAM,IAAI,CAAC,SAAS;QAEnC,+FAA+F;QAC/F,QAAQ,GAAG,CAAC,CAAC,wDAAwD,EAAE,OAAO,KAAK,CAAC,CAAC,IAAI;QAEzF,gCAAgC;QAChC,OAAO,CAAC,UAAU,EAAE,KAAK,GAAG,IAAI;IACpC;IAEA,MAAM,cAAc,MAAc,EAA+B;QAC7D,wBAAwB;QACxB,OAAO;YACH,QAAQ;YACR;QACJ;IACJ;AACJ"}},
    {"offset": {"line": 462, "column": 0}, "map": {"version":3,"sources":["file:///Users/odgmusic/development/Da%20Graba_Studio/app/api/ai/generate/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nexport const dynamic = 'force-dynamic';\nimport { KieService } from '@/lib/ai/services/kie-service';\nimport { MusicGptService } from '@/lib/ai/services/musicgpt-service';\nimport { BaseMusicService, MusicGenerationRequest } from '@/lib/ai/types';\n\nexport async function POST(req: Request) {\n    try {\n        const body = await req.json();\n        const { provider = 'kie', ...requestParams } = body;\n\n        let service: BaseMusicService;\n\n        switch (provider.toLowerCase()) {\n            case 'musicgpt':\n                service = new MusicGptService();\n                break;\n            case 'kie':\n            default:\n                service = new KieService();\n                break;\n        }\n\n        const taskId = await service.generateMusic(requestParams as MusicGenerationRequest);\n\n        return NextResponse.json({ success: true, taskId }, { status: 200 });\n\n    } catch (error: any) {\n        console.error(`[AI Generation API Error]:`, error);\n        return NextResponse.json({\n            success: false,\n            error: error.message || 'Internal Server Error'\n        }, { status: 500 });\n    }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AAEA;AACA;;AAFO,MAAM,UAAU;;;AAKhB,eAAe,KAAK,GAAY;IACnC,IAAI;QACA,MAAM,OAAO,MAAM,IAAI,IAAI;QAC3B,MAAM,EAAE,WAAW,KAAK,EAAE,GAAG,eAAe,GAAG;QAE/C,IAAI;QAEJ,OAAQ,SAAS,WAAW;YACxB,KAAK;gBACD,UAAU,IAAI,oMAAe;gBAC7B;YACJ,KAAK;YACL;gBACI,UAAU,IAAI,0LAAU;gBACxB;QACR;QAEA,MAAM,SAAS,MAAM,QAAQ,aAAa,CAAC;QAE3C,OAAO,mLAAY,CAAC,IAAI,CAAC;YAAE,SAAS;YAAM;QAAO,GAAG;YAAE,QAAQ;QAAI;IAEtE,EAAE,OAAO,OAAY;QACjB,QAAQ,KAAK,CAAC,CAAC,0BAA0B,CAAC,EAAE;QAC5C,OAAO,mLAAY,CAAC,IAAI,CAAC;YACrB,SAAS;YACT,OAAO,MAAM,OAAO,IAAI;QAC5B,GAAG;YAAE,QAAQ;QAAI;IACrB;AACJ"}}]
}