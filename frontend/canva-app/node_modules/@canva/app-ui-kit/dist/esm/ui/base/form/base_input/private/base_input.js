import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { exists } from '../../../../../base/exists';
import { UnreachableError } from '../../../../../base/preconditions';
import { composeRefs } from '../../../../../base/react/compose_refs';
import classNames from 'classnames';
import { action } from 'mobx';
import { observer, useLocalObservable } from 'mobx-react-lite';
import * as React from 'react';
import { accessModeState } from '../../../a11y/access_mode_state/access_mode_state';
import { useIsHoveringInput } from '../../../a11y/pointer_input_state/pointer_input_state';
import { useControllableValue } from '../../../controllable_value/controllable_value';
import { isVirtualKeyboard } from '../../../device_capabilities/device_capabilities';
import { BaseInputContextProvider, useCreateInputControls, usePropOverrides } from '../../internal/input';
import { CalendarIcon } from '../../../icons/calendar/icon';
import { CreditCardBackIcon } from '../../../icons/credit_card_back/icon';
import { CreditCardFrontIcon } from '../../../icons/credit_card_front/icon';
import { EnvelopeIcon } from '../../../icons/envelope/icon';
import { LinkIcon } from '../../../icons/link/icon';
import { LocationIcon } from '../../../icons/location/icon';
import { SearchIcon } from '../../../icons/search/icon';
import { UserIcon } from '../../../icons/user/icon';
import { Spacer } from '../../../layout/layout';
import styles from './base_input.css';
function getLegacyIcon({ icon, iconClassName }, position) {
    return icon?.align === position && _jsx(Icon, {
        ...icon,
        className: iconClassName
    });
}
function getDecoration(decoration) {
    const content = typeof decoration === 'function' ? decoration() : decoration;
    return content ? _jsx("div", {
        className: styles.decoration,
        children: React.isValidElement(content) && content.type === React.Fragment ? React.Children.toArray(content.props.children).filter(exists).map(addLeadingSpace) : content
    }) : undefined;
}
function addLeadingSpace(child, index) {
    return index === 0 ? child : [
        _jsx(Spacer, {
            size: "0.5u"
        }, index),
        child
    ];
}
export function useFocusState() {
    const store = useLocalObservable(()=>({
            isFocused: false,
            setFocused: action((value)=>store.isFocused = value)
        }));
    return {
        isFocused: store.isFocused,
        isKeyboardMode: accessModeState.isKeyboardMode,
        setFocused: store.setFocused
    };
}
export function useOnWrapperClick() {
    const ref = React.useRef(null);
    const onClick = React.useCallback((e)=>{
        let el = e.target;
        while(el && el !== e.currentTarget){
            if (isInteractive(el)) return;
            el = el.parentElement;
        }
        e.stopPropagation();
        e.preventDefault();
        ref.current?.focus();
    }, []);
    return {
        ref,
        onClick
    };
}
function isInteractive(el) {
    return el.tagName === 'A' || el.tagName === 'BUTTON' || el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.getAttribute('tabIndex') != null;
}
export const BaseInput = observer(function BaseInput({ ref, ...props_ }) {
    const { props, setPropOverrides } = usePropOverrides(props_);
    const { blurOnEnterKeyDown, onChange: onChangeProp, onFocus: onFocusProp, onBlur: onBlurProp, onKeyDown: onKeyDownProp, onChangeComplete: onChangeCompleteProp } = props;
    const wrapperRef = React.useRef(null);
    const { ref: inputRef, onClick: onWrapperClick } = useOnWrapperClick();
    const { isFocused, isKeyboardMode, setFocused } = useFocusState();
    const [value, setValue] = useControllableValue({
        value: props.value,
        defaultValue: props.defaultValue ?? ''
    });
    const startDecoration = getDecoration(props.start ?? getLegacyIcon(props, 'start'));
    const endDecoration = getDecoration(props.end ?? getLegacyIcon(props, 'end'));
    const controls = useCreateInputControls({
        focus: ()=>inputRef.current?.focus(),
        setType: (type)=>setPropOverrides(type ? {
                type
            } : undefined),
        setDisabled: (disabled)=>setPropOverrides({
                disabled
            }),
        setValue: (value)=>{
            setValue(value);
            onChangeProp?.(value);
        }
    });
    const onChange = React.useCallback((e)=>{
        setValue(e.target.value);
        onChangeProp?.(e.target.value, e);
    }, [
        onChangeProp,
        setValue
    ]);
    const onFocus = React.useCallback((e)=>{
        onFocusProp?.(e);
        setFocused(true);
    }, [
        onFocusProp,
        setFocused
    ]);
    const onBlur = React.useCallback((e)=>{
        onBlurProp?.(e);
        onChangeCompleteProp?.(e.target.value);
        setFocused(false);
    }, [
        onBlurProp,
        onChangeCompleteProp,
        setFocused
    ]);
    const onKeyDown = React.useCallback((e)=>{
        if (e.keyCode === 229) {
            e.stopPropagation();
            return;
        }
        if (e.key === 'Enter' && blurOnEnterKeyDown)
        wrapperRef.current?.focus();
        onKeyDownProp?.(e);
        if (!blurOnEnterKeyDown && e.key === 'Enter')
            onChangeCompleteProp?.(e.currentTarget.value);
    }, [
        onKeyDownProp,
        onChangeCompleteProp,
        blurOnEnterKeyDown,
        wrapperRef
    ]);
    const hoverSupported = useIsHoveringInput();
    const wrapperClassName = classNames(styles.wrapper, styles.singleLineWrapper, {
        [styles.hoverSupported]: hoverSupported,
        [styles.focusOutline]: isFocused && isKeyboardMode,
        [styles.borderless]: props.borderless,
        [styles.withStartDecoration]: startDecoration != null,
        [styles.withEndDecoration]: endDecoration != null
    }, props.disabled && styles.disabled || isFocused && styles.active || props.error && styles.error, props.className);
    const inputClassName = classNames(styles.textField, styles.singleLineTextField, {
        [styles.textAlignCenter]: props.textAlignCenter,
        [styles.noAutocomplete]: props.autoComplete === 'off'
    }, props.inputClassName);
    return (_jsx("div", {
            ref: wrapperRef,
            tabIndex: blurOnEnterKeyDown ? -1 : undefined,
            className: wrapperClassName,
            onMouseDown: onWrapperClick,
            children: _jsxs(BaseInputContextProvider, {
                controls: controls,
                value: value,
                children: [
                    startDecoration,
                    _jsx("input", {
                        id: props.id,
                        className: inputClassName,
                        value: value,
                        onChange: onChange,
                        onFocus: onFocus,
                        onBlur: onBlur,
                        onKeyDown: onKeyDown,
                        onClick: props.onClick,
                        onMouseDown: props.onMouseDown,
                        onMouseUp: props.onMouseUp,
                        onContextMenu: props.onContextMenu,
                        onPaste: props.onPaste,
                        onKeyUp: props.onKeyUp,
                        ref: composeRefs(inputRef, ref),
                        dir: "auto",
                        spellCheck: props.disableSpellcheck ? false : undefined,
                        type: props.type,
                        inputMode: props.inputMode,
                        autoCapitalize: props.autoCapitalize,
                        autoCorrect: props.autoCorrect,
                        pattern: props.pattern,
                        autoFocus: props.autoFocus === 'always' || props.autoFocus === 'on-desktop' && !isVirtualKeyboard(),
                        autoComplete: props.autoComplete,
                        disabled: props.disabled,
                        readOnly: props.readOnly,
                        maxLength: props.maxLength,
                        max: props.max,
                        min: props.min,
                        placeholder: props.placeholder,
                        step: props.step,
                        name: props.name,
                        role: props.role,
                        enterKeyHint: props.enterKeyHint,
                        "aria-roledescription": props.ariaRoleDescription,
                        "aria-required": props.required || undefined,
                        "aria-invalid": props.error || undefined,
                        "aria-label": props.ariaLabel,
                        "aria-labelledby": props.ariaLabelledBy,
                        "aria-describedby": props.ariaDescribedBy,
                        "aria-autocomplete": props.ariaAutoComplete,
                        "aria-activedescendant": props.ariaActiveDescendant,
                        "aria-controls": props.ariaControls,
                        "aria-expanded": props.ariaExpanded,
                        "aria-haspopup": props.ariaHasPopup,
                        "aria-valuenow": props.ariaValueNow,
                        "aria-valuetext": props.ariaValueText,
                        "aria-valuemin": props.ariaValueMin,
                        "aria-valuemax": props.ariaValueMax
                    }),
                    endDecoration
                ]
            })
        }));
});
function Icon({ type, className }) {
    const props = {
        size: 'medium',
        tone: 'primary',
        className
    };
    switch(type){
        case 'credit-card':
            return _jsx(CreditCardFrontIcon, {
                ...props
            });
        case 'credit-card-expiry':
            return _jsx(CalendarIcon, {
                ...props
            });
        case 'credit-card-verification':
            return _jsx(CreditCardBackIcon, {
                ...props
            });
        case 'email':
            return _jsx(EnvelopeIcon, {
                ...props
            });
        case 'link':
            return _jsx(LinkIcon, {
                ...props
            });
        case 'location':
            return _jsx(LocationIcon, {
                ...props
            });
        case 'person':
            return _jsx(UserIcon, {
                ...props
            });
        case 'search':
            return _jsx(SearchIcon, {
                ...props
            });
        default:
            throw new UnreachableError(type);
    }
}
