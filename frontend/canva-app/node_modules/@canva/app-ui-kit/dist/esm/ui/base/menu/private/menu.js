import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { Preconditions } from '../../../../base/preconditions';
import classNames from 'classnames';
import { observer } from 'mobx-react-lite';
import * as React from 'react';
import { accessModeState } from '../../a11y/access_mode_state/access_mode_state';
import { Box } from '../../box/box';
import { BaseAnchor, BaseButton } from '../../button/base_button/base_button';
import { Button } from '../../button/button';
import { useControllableValue } from '../../controllable_value/controllable_value';
import { Divider } from '../../divider/divider';
import { ChevronDownIcon } from '../../icons/chevron_down/icon';
import { ChevronRightIcon } from '../../icons/chevron_right/icon';
import { Column, Columns, Rows, Spacer } from '../../layout/layout';
import { useIsTruncated } from '../../typography/truncated/truncated';
import { InheritColor, Text } from '../../typography/typography';
import styles, { getStyle } from './menu.css';
import { MenuMessages } from './menu.messages';
const MenuContext = React.createContext(undefined);
export const ITEM_HEIGHT_MULTIPIER = 5;
export const DIVIDER_HEIGHT_MULTIPIER = 2;
export const TEXT_DIVIDER_HEIGHT_MULTIPIER = 4;
const getMenuSpaceStyle = (spacing, variant = 'regular', direction = 'vertical')=>{
    const menuSpace = spacing || (direction === 'horizontal' ? '1u' : variant === 'regular' ? '0' : '0.5u');
    switch(menuSpace){
        case '0.5u':
            return getStyle('spacing050');
        case '1u':
            return getStyle('spacing1');
        default:
            return;
    }
};
export function Menu({ ref, ...props }) {
    const navigationRole = props.role === 'navigation';
    const [hasToggleMenu, setHasToggleMenu] = React.useState(false);
    const menuClassName = classNames(styles.menu, !navigationRole && props.className, getMenuSpaceStyle(props.spacing, props.variant, props.direction), {
        [styles.rounded]: props.variant === 'rounded',
        [styles.bleedX]: !!props.bleedX,
        [styles.horizontal]: props.role !== 'listbox' && props.direction === 'horizontal',
        [styles.hasToggleMenu]: hasToggleMenu
    });
    const content = _jsx(Box, {
        id: props.id,
        ariaActiveDescendant: props.ariaActiveDescendant,
        ariaMultiSelectable: props.ariaMultiSelectable,
        ariaLabel: props.ariaLabel,
        ariaLabelledBy: props.ariaLabelledBy,
        tagName: props.tagName ?? 'ul',
        role: props.role === 'navigation' ? 'list' : props.role,
        ref: ref,
        className: menuClassName,
        children: props.children
    });
    const maybeWrappedContent = navigationRole ? _jsx("nav", {
        className: navigationRole && props.className,
        children: content
    }) : content;
    const context = React.useMemo(()=>({
            menuRole: props.role,
            menuDirection: props.role !== 'listbox' ? props.direction : undefined,
            menuVariant: props.variant,
            menuSpacing: props.spacing,
            registerToggleMenu: ()=>setHasToggleMenu(true)
        }), [
        props.role,
        props.direction,
        props.variant,
        props.spacing
    ]);
    return _jsx(MenuContext.Provider, {
        value: context,
        children: maybeWrappedContent
    });
}
function getMenuItemRoles(menuRole) {
    switch(menuRole){
        case 'menu':
        case 'menubar':
            return {
                boxRole: 'none',
                buttonRole: 'menuitem'
            };
        case 'listbox':
        case 'group':
            return {
                boxRole: 'option',
                buttonRole: undefined
            };
        default:
            return {
                boxRole: undefined,
                buttonRole: undefined
            };
    }
}
export const MenuItem = React.memo(
    function MenuItem({ id, buttonId, children, className, active, selected, pressed, disabled, disclosure, draggable, onFocus, onBlur, onMouseEnter, onMouseLeave, tabIndex, start, end, label, description, lineClamp, buttonRef, tooltipLabel, tooltipDisabled, tooltipLineClamp, tooltipPlacement, tooltipShortcut, ariaLabel, ariaLabelledBy, ariaDescribedBy, ariaHasPopup, ariaControls, ariaSelected, ariaCurrent, href, target, download, onClick, onContextMenu }) {
        const context = Preconditions.checkExists(React.useContext(MenuContext), 'MenuItem should not be used outside of a Menu');
        const { boxRole, buttonRole } = getMenuItemRoles(context.menuRole);
        return _jsx(Box, {
            tagName: "li",
            id: id,
            role: boxRole,
            className: styles.menuItem,
            ariaDisabled: disabled,
            ariaSelected: ariaSelected,
            children: _jsx(MenuItemButton, {
                id: buttonId,
                role: buttonRole,
                tabIndex: tabIndex,
                buttonRef: buttonRef,
                className: className,
                href: href,
                target: target,
                download: download,
                onClick: onClick,
                start: start,
                end: end,
                label: label,
                description: description,
                lineClamp: lineClamp,
                alignment: context.menuDirection === 'horizontal' ? 'center' : 'start',
                active: active,
                selected: selected,
                pressed: pressed,
                disabled: disabled,
                disclosure: disclosure,
                draggable: draggable,
                onFocus: onFocus,
                onBlur: onBlur,
                onMouseEnter: onMouseEnter,
                onMouseLeave: onMouseLeave,
                onContextMenu: onContextMenu,
                tooltipLabel: tooltipLabel,
                tooltipDisabled: tooltipDisabled,
                tooltipLineClamp: tooltipLineClamp,
                tooltipPlacement: tooltipPlacement,
                tooltipShortcut: tooltipShortcut,
                ariaLabel: ariaLabel,
                ariaLabelledBy: ariaLabelledBy,
                ariaDescribedBy: ariaDescribedBy,
                ariaHasPopup: ariaHasPopup,
                ariaControls: ariaControls,
                ariaCurrent: ariaCurrent,
                children: children
            })
        });
    }
);
const Clickable = (props)=>{
    return props.href ? _jsx(BaseAnchor, {
        ...props
    }) : _jsx(BaseButton, {
        ...props
    });
};
export const MenuItemButton = observer(function MenuItemButton({ id, role, alignment, children, className, active, selected, pressed, disabled, draggable, disclosure, onClick, onFocus, onBlur, onMouseEnter, onMouseLeave, onContextMenu, tabIndex, start, end, label, description, lineClamp, buttonRef, tooltipLabel: tooltipLabelProp, tooltipDisabled, tooltipLineClamp, tooltipPlacement, tooltipShortcut, ariaLabel, ariaLabelledBy, ariaDescribedBy, ariaHasPopup, ariaControls, ariaSelected, ariaCurrent, href, target, download }) {
    const childrenIsTextLike = typeof children === 'string' || typeof children === 'number';
    const textContent = label ?? (childrenIsTextLike ? children.toString() : undefined);
    const { isTruncated, ref: isTruncatedRef } = useIsTruncated(textContent);
    const hideOutline = accessModeState.isMouseMode;
    const labelId = React.useId();
    const descriptionId = React.useId();
    const buttonClassName = classNames(styles.menuItemButton, {
        [styles.hideOutline]: hideOutline
    }, className);
    const contentNodes = [];
    if (children != null && !childrenIsTextLike) contentNodes.push(children);
    else {
        textContent !== undefined && contentNodes.push(_jsx(Text, {
            ref: textContent != null ? isTruncatedRef : undefined,
            id: label ? labelId : undefined,
            tagName: "span",
            tone: InheritColor,
            alignment: alignment,
            lineClamp: lineClamp,
            className: styles.menuItemButtonLabel,
            children: textContent
        }, contentNodes.length));
        label && description && contentNodes.push(_jsx(Text, {
            id: descriptionId,
            tagName: "span",
            size: "small",
            tone: "tertiary",
            alignment: alignment,
            children: description
        }, contentNodes.length));
    }
    const content = contentNodes.length > 1 ? _jsx(Rows, {
        tagName: "span",
        spacing: "0",
        children: contentNodes
    }) : contentNodes;
    const setRef = React.useCallback((handle)=>{
        if (buttonRef == null) return;
        const element = handle?.dangerouslyGetElement() ?? null;
        if (typeof buttonRef === 'function') buttonRef(element);
        else buttonRef.current = element;
    }, [
        buttonRef
    ]);
    const decoratedContent = start || end ? _jsxs(Columns, {
        tagName: "span",
        alignY: "center",
        spacing: "1u",
        children: [
            start ? renderDecorator(typeof start === 'function' ? start() : start) : null,
            _jsx(Column, {
                tagName: "span",
                children: content
            }),
            end ? renderDecorator(typeof end === 'function' ? end() : end) : null
        ]
    }) : content;
    const isButtonLike = onClick || href || disabled;
    if (!isButtonLike) return _jsx(Box, {
        id: id,
        className: classNames(styles.text, buttonClassName),
        ariaLabel: ariaLabel,
        ariaLabelledBy: label ? labelId : ariaLabelledBy,
        ariaDescribedBy: description ? descriptionId : ariaDescribedBy,
        width: "full",
        alignItems: "center",
        children: decoratedContent
    });
    const tooltipLabel = tooltipLabelProp ?? (isTruncated ? textContent : undefined);
    return _jsx(Clickable, {
        id: id,
        role: role,
        tabIndex: tabIndex,
        ref: setRef,
        className: buttonClassName,
        active: active,
        selected: active ?? selected,
        pressed: pressed,
        disabled: disabled,
        draggable: draggable,
        disclosure: disclosure,
        onClick: onClick,
        onFocus: onFocus,
        onBlur: onBlur,
        onMouseEnter: onMouseEnter,
        onMouseLeave: onMouseLeave,
        onContextMenu: onContextMenu,
        tooltipLabel: tooltipLabel,
        tooltipDisabled: tooltipDisabled,
        tooltipLineClamp: tooltipLineClamp,
        tooltipPlacement: tooltipPlacement,
        tooltipShortcut: tooltipShortcut,
        ariaLabel: ariaLabel,
        ariaLabelledBy: label ? labelId : ariaLabelledBy,
        ariaDescribedBy: description ? descriptionId : ariaDescribedBy,
        ariaHasPopup: ariaHasPopup,
        ariaControls: ariaControls,
        ariaCurrent: ariaCurrent,
        href: href,
        target: target,
        download: download,
        width: "full",
        alignItems: "center",
        tone: "tertiary",
        children: decoratedContent
    });
});
export const renderDecorator = (decorator)=>React.isValidElement(decorator) && decorator.type === React.Fragment ? _jsx(_Fragment, {
        children: React.Children.map(decorator.props.children, (child)=>child && renderDecorator(child))
    }) : _jsx(Column, {
        tagName: "span",
        width: "content",
        children: decorator
    });
export const MenuDivider = React.memo(function MenuDivider({ id, children }) {
    const context = Preconditions.checkExists(React.useContext(MenuContext), 'MenuDivider should not be used outside of a Menu');
    const dividerDirection = context.menuDirection === 'horizontal' ? 'vertical' : 'horizontal';
    const showChildren = context.menuDirection !== 'horizontal' && children;
    return _jsxs("li", {
        role: "none",
        id: id,
        children: [
            _jsx("div", {
                className: styles.menuDivider,
                children: _jsx(Divider, {
                    direction: dividerDirection
                })
            }),
            showChildren && _jsx(Text, {
                size: "small",
                weight: "bold",
                tagName: "div",
                tone: "secondary",
                className: styles.menuDividerText,
                children: children
            })
        ]
    });
});
export function ToggleMenu(
    { id, menuId: menuIdProp, labelId: labelIdProp, label, labelNode, disabled, draggable, start, end, active, selected, buttonRef, tooltipLabel, tooltipPlacement, href, onClick, onToggleClick, onContextMenu, toggleLabel, defaultExpanded, expanded: expandedProp, buttonClassName, ref, ...props }
) {
    const [expanded, setExpanded] = useControllableValue({
        value: expandedProp,
        defaultValue: defaultExpanded,
        onChange: onToggleClick
    });
    const toggleExpanded = React.useCallback(()=>setExpanded(!expanded), [
        expanded,
        setExpanded
    ]);
    const context = React.useContext(MenuContext);
    React.useEffect(()=>{
        context?.registerToggleMenu();
    }, [
        context
    ]);
    const Icon = expanded ? ChevronDownIcon : ChevronRightIcon;
    const generatedMenuId = React.useId();
    const menuId = menuIdProp ?? generatedMenuId;
    const generatedLabelId = React.useId();
    const labelId = labelIdProp ?? generatedLabelId;
    const toggleButtonProps = {
        onClick: toggleExpanded,
        disclosure: true,
        ariaControls: expanded ? menuId : undefined,
        open: expanded,
        disableActiveStyle: true
    };
    const showSeparateToggleButton = href || onClick;
    const menuItemClickProps = showSeparateToggleButton ? {
        href,
        onClick
    } : {
        ...toggleButtonProps
    };
    return _jsxs(Box, {
        ref: ref,
        tagName: context ? 'li' : 'div',
        id: id,
        className: styles.toggleMenuBox,
        children: [
            _jsx(MenuItemButton, {
                id: labelId,
                className: buttonClassName,
                active: active,
                selected: selected,
                disabled: disabled,
                start: _jsxs(_Fragment, {
                    children: [
                        showSeparateToggleButton ? _jsx(Spacer, {
                            size: "1u",
                            direction: "horizontal"
                        }) : _jsxs(Box, {
                            tagName: "span",
                            className: styles.toggleMenuIconBox,
                            children: [
                                _jsx(Spacer, {
                                    size: "1u",
                                    direction: "horizontal"
                                }),
                                _jsx(Icon, {
                                    size: "small",
                                    className: styles.toggleMenuIcon
                                })
                            ]
                        }),
                        typeof start === 'function' ? start() : start
                    ]
                }),
                end: end,
                lineClamp: 1,
                buttonRef: buttonRef,
                onContextMenu: onContextMenu,
                tooltipLabel: tooltipLabel,
                tooltipPlacement: tooltipPlacement,
                ariaLabel: labelNode ? label : undefined,
                draggable: draggable,
                ...menuItemClickProps,
                children: labelNode || label
            }),
            showSeparateToggleButton && _jsx(Button, {
                className: styles.toggleButton,
                variant: "tertiary",
                iconSize: "small",
                icon: Icon,
                ariaLabel: toggleLabel ?? expanded ? MenuMessages.collapseMenu(label) : MenuMessages.expandMenu(label),
                disabled: disabled,
                ...toggleButtonProps
            }),
            expanded && props.children && _jsx(Menu, {
                id: menuId,
                ariaLabelledBy: labelId,
                variant: context?.menuVariant,
                spacing: context?.menuSpacing,
                ...props
            })
        ]
    });
}
