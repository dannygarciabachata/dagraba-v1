import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { composeRefs } from '../../../../base/react/compose_refs';
import classNames from 'classnames';
import { observer } from 'mobx-react-lite';
import * as React from 'react';
import { accessModeState } from '../../a11y/access_mode_state/access_mode_state';
import { useAnnounceWhen } from '../../a11y/announcer/announcer';
import { getButtonAriaAttributes } from '../../a11y/button_aria_attributes/button_aria_attributes';
import { useIsHoveringInput } from '../../a11y/pointer_input_state/pointer_input_state';
import { ScreenReaderContent } from '../../a11y/screen_reader_content/screen_reader_content';
import { createBasicHTMLHandle } from '../../handle/handle';
import { SkipRenderOnClient } from '../../hydration/skip_render_on_client';
import { useIsomorphicLayoutEffect } from '../../hydration/use_isomorphic_layout_effect';
import { AnimatedSpinnerIcon } from '../../icons/animated_spinner/icon';
import { useEnableAnimations, useEnableButtonLoadingScan } from '../../provider/provider';
import { Tooltip } from '../../tooltip/tooltip';
import { useIsTruncated } from '../../typography/truncated/truncated';
import { Text } from '../../typography/typography';
import styles, { customProperties, getStyle } from './button.css';
import { ButtonMessages } from './button.messages';
const getButtonContent = (props)=>{
    const { children, iconPosition = 'start', noChildWrapper, icon: Icon, LoadingIcon = AnimatedSpinnerIcon, isTruncatedRef } = props;
    const content = [];
    let displayIcon = null;
    const hiddenAttrs = {
        ['aria-hidden']: props.loading || undefined
    };
    if (Icon) displayIcon = _jsx("span", {
        className: styles.iconWrapper,
        ...hiddenAttrs,
        children: _jsx(Icon, {
            size: props.iconSize || 'medium'
        })
    }, "icon");
    if (iconPosition === 'start' || iconPosition === 'top') content.push(displayIcon);
    if (children) content.push(noChildWrapper ? children : _jsx("span", {
        className: styles.text,
        ref: isTruncatedRef,
        ...hiddenAttrs,
        children: children
    }, "content"));
    if (iconPosition === 'end') content.push(displayIcon);
    if (props.loading) {
        const loadingIconSize = props.iconSize || 'medium';
        content.push(_jsxs("span", {
            className: styles.loadingIconWrapper,
            children: [
                _jsx(LoadingIcon, {
                    size: loadingIconSize
                }),
                _jsx(ScreenReaderContent, {
                    children: props.loadingMessage || ButtonMessages.loading()
                })
            ]
        }, "loading"));
    }
    return content;
};
const useClassName = (isAnchor, { children, alignment = 'center', active, selected, pressed, disableActiveStyle, disclosure, loading, loadingVariant, disabled, stretch, variant, hideOutline, iconPosition, shape, size, expandClickableArea, icon, iconSize })=>{
    const trueSize = getSize({
        children,
        iconSize,
        size,
        variant
    });
    const squareSizing = allowSquareSizing({
        children,
        variant,
        stretch,
        icon
    });
    const iconOnly = icon != null && !children;
    const enableButtonLoadingScan = useEnableButtonLoadingScan();
    loadingVariant ?? (loadingVariant = enableButtonLoadingScan ? 'scan' : 'spinner');
    return classNames(styles.base, {
        [styles.anchor]: isAnchor,
        [styles.button]: variant !== 'basic',
        [styles.hideOutline]: hideOutline,
        [styles.topIcon]: iconPosition === 'top',
        [styles.startIcon]: !iconOnly && icon && (!iconPosition || iconPosition === 'start'),
        [styles.endIcon]: !iconOnly && icon && iconPosition === 'end',
        [styles.noMinWidth]: squareSizing,
        [styles.circleShape]: shape === 'circle',
        [styles.expandClickableArea]: expandClickableArea
    }, getStyle(variant), !disableActiveStyle && getStateStyle({
        active,
        disclosure,
        selected,
        pressed
    }), trueSize && getStyle(trueSize), {
        [styles.stretch]: stretch,
        [styles.spinner]: loading && loadingVariant === 'spinner',
        [styles.scanning]: loading && loadingVariant === 'scan',
        [styles.disabled]: disabled,
        [styles.startAlign]: alignment === 'start',
        [styles.centerAlign]: iconOnly || alignment === 'center',
        [styles.endAlign]: alignment === 'end',
        [styles.hoverSupported]: useIsHoveringInput(),
        [styles.animate]: useEnableAnimations(),
        [styles.tinyWidth]: trueSize === 'tiny' && squareSizing,
        [styles.xsmallWidth]: trueSize === 'xsmall' && squareSizing,
        [styles.smallWidth]: trueSize === 'small' && squareSizing,
        [styles.mediumWidth]: trueSize === 'medium' && squareSizing,
        [styles.largeWidth]: trueSize === 'large' && squareSizing
    });
};
function getStateStyle(props) {
    const selected = props.selected ?? (props.disclosure ? undefined : props.active);
    const pressed = props.pressed ?? (props.disclosure ? props.active : undefined);
    return {
        [styles.selected]: selected,
        [styles.activeDisclosure]: pressed
    };
}
export const useShouldDisableSubmit = (initialShouldDisableSubmit)=>{
    const [disableSubmit, setDisableSubmit] = React.useState(initialShouldDisableSubmit);
    useIsomorphicLayoutEffect(()=>{
        setDisableSubmit(false);
    }, []);
    return disableSubmit;
};
export const ButtonInner = observer(function ButtonInner({ ref, ...props }) {
    const buttonRef = React.useRef(null);
    React.useImperativeHandle(ref, ()=>createBasicHTMLHandle(buttonRef), [
        buttonRef
    ]);
    const composedRef = composeRefs(buttonRef, props.buttonRef, ref);
    const isSubmitButton = props.type === 'submit';
    const disabledAttribute = useShouldDisableSubmit(isSubmitButton);
    const disabledStyle = disabledAttribute || props.disabled;
    const disabled = disabledAttribute || props.disabled || props.loading;
    const className = useClassName(false, {
        ...props,
        hideOutline: accessModeState.isMouseMode,
        disabled: disabledStyle
    });
    const elevationEnabled = props.elevated && props.shape === 'circle' && props.variant !== 'contrast';
    const loadingMessage = props.loadingMessage ?? ButtonMessages.loading();
    const loadingFinishedMessage = props.loadingFinishedMessage ?? ButtonMessages.loadingFinished();
    useAnnounceWhen(loadingMessage, !!props.loading, {
        priority: 'high'
    });
    useAnnounceWhen(loadingFinishedMessage, !props.loading, {
        priority: 'high',
        skipInitialRender: true
    });
    const children = getButtonContent({
        ...props,
        loadingMessage
    });
    const onClickImpl = props.onClick;
    const onClick = React.useCallback((e)=>{
        if (disabled) e.preventDefault();
        else onClickImpl?.(e);
    }, [
        disabled,
        onClickImpl
    ]);
    const stopPropagationWhenDisabled = disabled ? (e)=>{
        const shouldPrevent = [
            'click',
            'mousedown',
            'mouseup',
            'submit'
        ].includes(e.type) || !('code' in e) || [
            'Enter',
            'Space'
        ].includes(e.code);
        if (shouldPrevent) {
            e.stopPropagation();
            e.preventDefault();
        }
    } : undefined;
    return _jsx(ElevatedWrapper, {
        containerClassName: props.containerClassName,
        enabled: elevationEnabled,
        children: _jsxs("button", {
            ref: composedRef,
            id: props.id,
            onMouseDown: (e)=>accessModeState.setAccessMode('mouse') && props.onMouseDown?.(e),
            className: classNames(className, props.className),
            form: props.form,
            onMouseUp: props.onMouseUp,
            onMouseEnter: props.onMouseEnter,
            onMouseLeave: props.onMouseLeave,
            onPointerDown: props.onPointerDown,
            onPointerUp: props.onPointerUp,
            onPointerLeave: props.onPointerLeave,
            onContextMenu: props.onContextMenu,
            onBlur: props.onBlur,
            onFocus: props.onFocus,
            onDragStart: props.onDragStart,
            onDragEnd: props.onDragEnd,
            draggable: props.draggable,
            onClick: onClick,
            onClickCapture: stopPropagationWhenDisabled,
            onMouseDownCapture: stopPropagationWhenDisabled,
            onKeyDownCapture: stopPropagationWhenDisabled,
            onMouseUpCapture: stopPropagationWhenDisabled,
            disabled: disabledAttribute,
            type: props.type || 'button',
            ...getButtonAriaAttributes({
                ...props,
                tagName: 'button',
                selected: props.ariaPressed ?? props.selected,
                disabled
            }),
            children: [
                _jsx(LoadingScan, {
                    loading: props.loading,
                    buttonRef: buttonRef
                }),
                children
            ]
        })
    });
});
function LoadingScan({ loading, buttonRef }) {
    const [width, setWidth] = React.useState(undefined);
    React.useEffect(()=>{
        setWidth(loading ? buttonRef.current?.offsetWidth : undefined);
    }, [
        loading,
        buttonRef
    ]);
    if (!loading || !width) return null;
    return _jsx("span", {
        style: {
            [customProperties.buttonWidth]: `${width}px`
        },
        className: styles.oval
    });
}
export const AnchorInner = observer(function AnchorInner({ ref, ...props }) {
    const anchorRef = React.useRef(null);
    React.useImperativeHandle(ref, ()=>createBasicHTMLHandle(anchorRef), [
        anchorRef
    ]);
    const composedRef = composeRefs(anchorRef, props.buttonRef, ref);
    const semanticallyDisabled = props.disabled || props.loading;
    const targetBlank = props.target === '_blank';
    const rel = targetBlank && !props.rel ? 'noopener' : props.rel;
    const className = useClassName(true, {
        ...props,
        hideOutline: accessModeState.isMouseMode
    });
    const loadingMessage = props.loadingMessage ?? ButtonMessages.loading();
    const loadingFinishedMessage = props.loadingFinishedMessage ?? ButtonMessages.loadingFinished();
    useAnnounceWhen(loadingMessage, !!props.loading, {
        priority: 'high'
    });
    useAnnounceWhen(loadingFinishedMessage, !props.loading, {
        priority: 'high',
        skipInitialRender: true
    });
    const children = getButtonContent({
        ...props,
        loadingMessage
    });
    let linkProps;
    if (!semanticallyDisabled) linkProps = {
        onClick: props.onClick,
        onDragStart: props.onDragStart,
        onDragEnd: props.onDragEnd,
        onFocus: props.onFocus,
        onBlur: props.onBlur,
        onContextMenu: props.onContextMenu,
        onMouseEnter: props.onMouseEnter,
        onMouseLeave: props.onMouseLeave,
        href: props.href,
        target: props.target,
        rel,
        download: props.download,
        draggable: props.draggable
    };
    else
    linkProps = {
        onClick: (e)=>e.preventDefault(),
        onFocus: props.onFocus,
        onBlur: props.onBlur,
        onMouseEnter: props.onMouseEnter,
        onMouseLeave: props.onMouseLeave,
        href: props.href,
        target: props.target,
        download: props.download
    };
    return _jsxs("a", {
        id: props.id,
        ref: composedRef,
        ...linkProps,
        className: classNames(className, props.className),
        ...getButtonAriaAttributes({
            tagName: 'a',
            disabled: semanticallyDisabled,
            ...props
        }),
        children: [
            children,
            props.target != null && _jsx(SkipRenderOnClient, {
                tagName: "span",
                shouldRenderOnClient: ()=>targetBlank,
                children: _jsx(ScreenReaderContent, {
                    tagName: "span",
                    children: ButtonMessages.opensInNewWindow()
                })
            })
        ]
    });
});
function ButtonWithTooltipInner({ buttonProps, tooltipTriggerProps, ref }) {
    const ariaProps = getAriaProps({
        props: buttonProps,
        tooltipTriggerProps
    });
    const onMouseEnter = (event)=>{
        buttonProps.onMouseEnter?.(event);
        tooltipTriggerProps.onMouseEnter?.();
    };
    const onMouseLeave = (event)=>{
        buttonProps.onMouseLeave?.(event);
        tooltipTriggerProps.onMouseLeave?.();
    };
    const onMouseDown = (event)=>{
        buttonProps.onMouseDown?.(event);
        tooltipTriggerProps.onMouseDown?.();
    };
    const onFocus = (event)=>{
        buttonProps.onFocus?.(event);
        tooltipTriggerProps.onFocus?.();
    };
    const onBlur = (event)=>{
        buttonProps.onBlur?.(event);
        tooltipTriggerProps.onBlur?.();
    };
    return _jsx(ButtonInner, {
        ...buttonProps,
        ref: ref,
        ...ariaProps,
        onFocus: onFocus,
        onBlur: onBlur,
        onMouseEnter: onMouseEnter,
        onMouseLeave: onMouseLeave,
        onMouseDown: onMouseDown,
        tooltipLabel: undefined
    });
}
const ButtonWithTooltip = observer(function ButtonWithTooltip({ ref, ...props }) {
    return _jsx(Tooltip, {
        label: props.tooltipLabel,
        description: props.tooltipDescription,
        shortcut: props.tooltipShortcut,
        disabled: props.tooltipDisabled,
        placement: props.tooltipPlacement,
        lineClamp: props.tooltipLineClamp,
        closeOnClick: props.tooltipCloseOnClick,
        children: (triggerProps)=>{
            return _jsx(ButtonWithTooltipInner, {
                ref: ref,
                buttonProps: props,
                tooltipTriggerProps: triggerProps
            });
        }
    });
});
function AnchorWithTooltipInner({ anchorProps, tooltipTriggerProps, ref }) {
    const ariaProps = getAriaProps({
        props: anchorProps,
        tooltipTriggerProps
    });
    const onMouseEnter = (event)=>{
        anchorProps.onMouseEnter?.(event);
        tooltipTriggerProps.onMouseEnter?.();
    };
    const onMouseLeave = (event)=>{
        anchorProps.onMouseLeave?.(event);
        tooltipTriggerProps.onMouseLeave?.();
    };
    const onMouseDown = (event)=>{
        anchorProps.onMouseDown?.(event);
        tooltipTriggerProps.onMouseDown?.();
    };
    const onFocus = (event)=>{
        anchorProps.onFocus?.(event);
        tooltipTriggerProps.onFocus?.();
    };
    const onBlur = (event)=>{
        anchorProps.onBlur?.(event);
        tooltipTriggerProps.onBlur?.();
    };
    return _jsx(AnchorInner, {
        ...anchorProps,
        ref: ref,
        ...ariaProps,
        onFocus: onFocus,
        onBlur: onBlur,
        onMouseEnter: onMouseEnter,
        onMouseLeave: onMouseLeave,
        onMouseDown: onMouseDown,
        tooltipLabel: undefined
    });
}
export const AnchorWithTooltip = observer(function AnchorWithTooltip({ ref, ...props }) {
    return _jsx(Tooltip, {
        label: props.tooltipLabel,
        description: props.tooltipDescription,
        shortcut: props.tooltipShortcut,
        disabled: props.tooltipDisabled,
        placement: props.tooltipPlacement,
        lineClamp: props.tooltipLineClamp,
        closeOnClick: props.tooltipCloseOnClick,
        children: (triggerProps)=>_jsx(AnchorWithTooltipInner, {
                ref: ref,
                anchorProps: props,
                tooltipTriggerProps: triggerProps
            })
    });
});
export function CircleButtonWithoutLabel({ ref, ...props }) {
    return _jsx(InternalButton, {
        ...props,
        shape: "circle",
        ref: ref
    });
}
export function CircleButtonWithLabel({ variant, children, tooltipLabel: tooltipLabelProp, ref, ...props }) {
    const labelId = React.useId();
    const size = getSize({
        ...props,
        variant
    });
    const textChildren = typeof children === 'string' ? children : undefined;
    const { isTruncated, ref: isTruncatedRef } = useIsTruncated(textChildren);
    const tooltipLabel = tooltipLabelProp || (isTruncated ? textChildren : undefined);
    return _jsxs("div", {
        className: classNames(styles.circleShapeWrapper, {
            [styles.circleShapeWrapperXsmall]: size === 'xsmall',
            [styles.circleShapeWrapperSmall]: size === 'small',
            [styles.circleShapeWrapperMedium]: size === 'medium',
            [styles.circleShapeWrapperLarge]: size === 'large'
        }),
        children: [
            _jsx(InternalButton, {
                ...props,
                tooltipPlacement: props.tooltipPlacement || 'top',
                shape: "circle",
                ref: ref,
                variant: variant,
                ariaLabelledBy: labelId,
                tooltipLabel: tooltipLabel
            }),
            _jsx("label", {
                className: styles.circleButtonLabel,
                children: _jsx(Text, {
                    size: "small",
                    id: labelId,
                    tagName: "span",
                    alignment: "center",
                    tone: "secondary",
                    lineClamp: 2,
                    ref: typeof children !== 'object' ? isTruncatedRef : undefined,
                    children: children
                })
            })
        ]
    });
}
function getAriaProps({ props, tooltipTriggerProps }) {
    const ariaProps = {
        ariaLabel: props.ariaLabel
    };
    if ((props.children == null || typeof props.children !== 'string') && props.ariaLabelledBy == null && props.ariaLabel == null)
    ariaProps.ariaLabel = props.tooltipDescription != null ? `${props.tooltipLabel}: ${props.tooltipDescription}` : props.tooltipLabel;
    else {
        const hasRedundantTooltip = typeof props.children !== 'object' && props.children === props.tooltipLabel || props.ariaLabel === props.tooltipLabel;
        if (!hasRedundantTooltip && props.ariaDescribedBy == null) ariaProps.ariaDescribedBy = tooltipTriggerProps.tooltipId;
    }
    return ariaProps;
}
function allowSquareSizing({ children, stretch, variant, icon }) {
    return !children && !!icon && !stretch && [
        'subtleLinkButton'
    ].indexOf(variant) === -1;
}
function getSize({ children, iconSize, size, variant }) {
    if ([
        'subtleLinkButton'
    ].indexOf(variant) !== -1) return;
    if (size && size !== 'default') return size;
    if (variant === 'basic')
    return;
    if (!children && iconSize && [
        'tiny',
        'small',
        'large'
    ].indexOf(iconSize) !== -1) return iconSize;
    return 'medium';
}
const ElevatedWrapper = observer(function ElevatedWrapper(props) {
    if (props.enabled) return _jsx("span", {
        className: classNames(styles.elevatedWrapper, props.containerClassName, props.isInsideButton && styles.elevatedWrapperInsideButton),
        children: props.children
    });
    return props.children;
});
export function InternalButton({ tooltipLabel: tooltipLabelProp, ref, ...props }) {
    const textChildren = typeof props.children === 'string' ? props.children : undefined;
    const { isTruncated, ref: isTruncatedRef } = useIsTruncated(textChildren);
    const trackTruncation = typeof props.children !== 'object' && props.variant !== 'basic';
    const tooltipLabel = tooltipLabelProp || (isTruncated && trackTruncation ? textChildren : undefined);
    if (tooltipLabel != null && tooltipLabel.length > 0) return _jsx(ButtonWithTooltip, {
        ...props,
        ref: ref,
        isTruncatedRef: trackTruncation ? isTruncatedRef : undefined,
        tooltipLabel: tooltipLabel
    });
    return _jsx(ButtonInner, {
        ...props,
        ref: ref,
        isTruncatedRef: trackTruncation ? isTruncatedRef : undefined,
        tooltipLabel: undefined,
        tooltipDescription: undefined
    });
}
export function InternalAnchor({ tooltipLabel: tooltipLabelProp, ref, ...props }) {
    const textChildren = typeof props.children === 'string' ? props.children : undefined;
    const { isTruncated, ref: isTruncatedRef } = useIsTruncated(textChildren);
    const trackTruncation = typeof props.children !== 'object' && props.variant !== 'basic';
    const tooltipLabel = tooltipLabelProp || (isTruncated ? textChildren : undefined);
    if (tooltipLabel != null && tooltipLabel.length > 0) return _jsx(AnchorWithTooltip, {
        ref: ref,
        ...props,
        tooltipLabel: tooltipLabel,
        isTruncatedRef: trackTruncation ? isTruncatedRef : undefined
    });
    return _jsx(AnchorInner, {
        ref: ref,
        ...props,
        tooltipLabel: undefined,
        tooltipDescription: undefined,
        isTruncatedRef: trackTruncation ? isTruncatedRef : undefined
    });
}
export const renderButtonOrAnchor = ({ ...props }, ref)=>{
    if (props.type === 'link') return _jsx(InternalAnchor, {
        ...props,
        ref: ref
    });
    return _jsx(InternalButton, {
        ...props,
        ref: ref
    });
};
