import { jsx as _jsx } from "react/jsx-runtime";
import { composeRefs } from '../../../base/react/compose_refs';
import * as React from 'react';
import { useIsMouseAccessMode } from '../a11y/access_mode_state/access_mode_state';
import { useIsomorphicLayoutEffect } from '../hydration/use_isomorphic_layout_effect';
import styles from './focus.css';
import { createFocusState, FocusHistory, registerEvents } from './focus_history';
import { FocusManagerProvider, useCreateFocusManager, useFocusManager } from './focus_manager';
import { findFocusable, findFocusables, isFocusable } from './internal/focus_utils';
export { WithFocusManager, useFocusManager, FocusManagerProvider } from './focus_manager';
export { isFocusable, findFocusable } from './internal/focus_utils';
export function ApplyFocusHistory() {
    React.useEffect(()=>registerEvents(document), []);
    return null;
}
export function escapeFocusRecovery(element) {
    element.focus();
    element.blur();
}
export function useFocusVisible() {
    return !useIsMouseAccessMode();
}
export function useFocusScope({ onEnter, onLeave } = {}) {
    const ref = React.useRef(null);
    const isFocusWithinRef = React.useRef(false);
    const onFocusCapture = React.useCallback((e)=>{
        if (FocusHistory.enabled && e.target instanceof HTMLElement) FocusHistory.replace(createFocusState(e.target, ref.current));
        if (isFocusWithinRef.current) return;
        isFocusWithinRef.current = true;
        onEnter?.(e);
    }, [
        onEnter
    ]);
    const onBlur = React.useCallback((e)=>{
        if (!(e.relatedTarget instanceof HTMLElement)) return;
        if (ref.current?.contains(e.relatedTarget)) return;
        isFocusWithinRef.current = false;
        onLeave?.(e);
    }, [
        onLeave
    ]);
    const onLeaveRef = React.useRef(onLeave);
    useIsomorphicLayoutEffect(()=>{
        onLeaveRef.current = onLeave;
    }, [
        onLeave
    ]);
    React.useEffect(()=>{
        return ()=>{
            if (isFocusWithinRef.current)
                onLeaveRef.current?.();
        };
    }, []);
    return {
        ref,
        onFocusCapture,
        onBlur
    };
}
export function FocusScope(props) {
    const { onFocus: propOnFocus, onBlur: propOnBlur, ref } = props;
    const { ref: scopeRef, onBlur: scopeOnBlur, onFocusCapture: scopeOnFocusCapture } = useFocusScope(props);
    const { ref: focusManagerRef, onFocusCapture: managerOnFocusCapture, onBlur: managerOnBlur, focusManager } = useCreateFocusManager();
    const onFocusCapture = React.useCallback((e)=>{
        managerOnFocusCapture(e);
        scopeOnFocusCapture(e);
    }, [
        managerOnFocusCapture,
        scopeOnFocusCapture
    ]);
    const onBlur = React.useCallback((e)=>{
        managerOnBlur(e);
        scopeOnBlur(e);
        propOnBlur?.(e);
    }, [
        managerOnBlur,
        scopeOnBlur,
        propOnBlur
    ]);
    React.useImperativeHandle(ref, ()=>focusManager, [
        focusManager
    ]);
    return _jsx(FocusManagerProvider, {
        value: focusManager,
        children: _jsx("div", {
            ref: composeRefs(scopeRef, focusManagerRef),
            id: props.id,
            className: styles.nolayout,
            onFocusCapture: onFocusCapture,
            onFocus: propOnFocus,
            onBlur: onBlur,
            children: props.children
        })
    });
}
function getFocusableFrom(el, focusManager) {
    if (el instanceof HTMLElement) return isFocusable(el) ? el : findFocusable(el);
    return focusManager?.focusables[0];
}
export function useAutoFocus() {
    const wrapperRef = React.useRef(null);
    const focusManager = useFocusManager();
    useFocusWhen(true, ()=>getFocusableFrom(wrapperRef.current, focusManager));
    return {
        ref: wrapperRef
    };
}
export function AutoFocus(props) {
    const { ref } = useAutoFocus();
    return props.children && _jsx("div", {
        ref: ref,
        className: styles.nolayout,
        children: props.children
    });
}
export function useReturnFocus(props) {
    const focusManager = useFocusManager();
    const { to } = props;
    const toRef = React.useRef(to);
    useIsomorphicLayoutEffect(()=>{
        toRef.current = to;
    }, [
        to
    ]);
    React.useEffect(()=>{
        return ()=>{
            if (focusManager?.focused == null)
                return;
            const element = typeof toRef.current === 'string' ? document.getElementById(toRef.current) : toRef.current();
            if (!element) return;
            element.focus();
        };
    }, [
        focusManager
    ]);
}
export function ReturnFocus(props) {
    useReturnFocus(props);
    return null;
}
export function useFocusWhen(condition, getFocusable) {
    const lastValueRef = React.useRef(undefined);
    React.useEffect(()=>{
        if (condition === lastValueRef.current) return;
        if (condition === true) getFocusable()?.focus();
        lastValueRef.current = condition;
    }, [
        condition,
        getFocusable
    ]);
}
export function FocusWhen(props) {
    const wrapperRef = React.useRef(null);
    const focusManager = useFocusManager();
    useFocusWhen(props.condition, ()=>getFocusableFrom(wrapperRef.current, focusManager));
    return _jsx("div", {
        ref: wrapperRef,
        className: styles.nolayout,
        children: props.children
    });
}
export function useSyncFocus(index, onFocusIndex) {
    const wrapperRef = React.useRef(null);
    const focusManager = useFocusManager();
    const lastIndexRef = React.useRef(index);
    React.useEffect(()=>{
        if (index === lastIndexRef.current) return;
        lastIndexRef.current = index;
        if (wrapperRef.current instanceof HTMLElement) return findFocusables(wrapperRef.current)[index]?.focus();
        if (focusManager == null) return;
        focusManager.focusAt(index);
    }, [
        index,
        focusManager
    ]);
    const onFocusIndexRef = React.useRef(onFocusIndex);
    useIsomorphicLayoutEffect(()=>{
        onFocusIndexRef.current = onFocusIndex;
    }, [
        onFocusIndex
    ]);
    const onFocus = React.useCallback((e)=>{
        const focusables = wrapperRef.current instanceof HTMLElement ? findFocusables(wrapperRef.current) : focusManager?.focusables;
        const index = focusables?.findIndex((el)=>el === e.target) ?? -1;
        onFocusIndexRef.current?.(index);
    }, [
        focusManager
    ]);
    return {
        ref: wrapperRef,
        onFocus
    };
}
export function SyncFocus(props) {
    const { ref, onFocus } = useSyncFocus(props.index, props.onFocusIndex);
    return _jsx("div", {
        ref: ref,
        onFocus: onFocus,
        className: styles.nolayout,
        children: props.children
    });
}
