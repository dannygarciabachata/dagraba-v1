import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { Preconditions, UnreachableError } from '../../../../../base/preconditions';
import { composeRefs } from '../../../../../base/react/compose_refs';
import classNames from 'classnames';
import * as React from 'react';
import { getNonInteractiveHeight, getVirtualKeyboardOverlayHeight } from '../../../device_capabilities/keyboard';
import { useViewportHeightVariance } from '../../../device_capabilities/viewport_variance';
import { useViewportContainerSizeEffect } from '../../../device_capabilities/visual_viewport';
import { useIsomorphicLayoutEffect } from '../../../hydration/use_isomorphic_layout_effect';
import { Spacer } from '../../../layout/layout';
import { baseUnit } from '../../../metrics/metrics';
import { MobileEventHandler } from '../../../mobile_event_handler/mobile_event_handler';
import { getSafeAreaInsets } from '../../../platform_quirks/get_safe_area_insets';
import { getScrollState } from '../../../scroll/scroll';
import { useStableFunction } from '../../../stable_function/stable_function';
import backgroundStyles from '../../background/background.css';
import { SurfaceHeader, SurfaceHeaderCloseButton } from '../../header/header';
import { ContentContainer } from '../../internal/content_container';
import { ReferenceWrapper } from '../../internal/reference_wrapper';
import { useScrollPaddingRefs } from '../../internal/scroll_padding';
import { resolveTrigger } from '../../internal/trigger';
import { useSheetControls, useSheetDrag, useSheetScroll } from '../behavior/behavior';
import { useContentScrollable } from './content_scrollable';
import styles, { customProperties } from './sheet.css';
import { SheetWrapper } from './sheet_wrapper';
export function Sheet(
    { open, id: idProp, onOpenComplete, onCloseComplete, onBackButton, backdropVisible = true, markOutsideInert = backdropVisible, trigger, ref, ...inner }
) {
    const defaultId = React.useId();
    const id = idProp || defaultId;
    const handleBackButton = React.useCallback((event)=>{
        if (!open || onBackButton == null && inner.onRequestClose == null) return;
        event.stopPropagation();
        if (onBackButton) {
            onBackButton(event);
            return;
        }
        inner.onRequestClose?.({
            action: 'backButton'
        });
    }, [
        open,
        onBackButton,
        inner
    ]);
    const resolvedTrigger = resolveTrigger({
        open,
        id,
        role: inner.role,
        trigger
    });
    return _jsxs(_Fragment, {
        children: [
            _jsx(ReferenceWrapper, {
                content: resolvedTrigger
            }),
            _jsx(SheetWrapper, {
                open: open,
                onOpenComplete: onOpenComplete,
                onCloseComplete: onCloseComplete,
                markOutsideInert: markOutsideInert,
                children: _jsx(MobileEventHandler, {
                    onBackButton: handleBackButton,
                    children: _jsx(SheetInner, {
                        ...inner,
                        id: id,
                        backdropVisible: backdropVisible,
                        handleRef: ref
                    })
                })
            })
        ]
    });
}
const heightMap = {
    ['half']: 50,
    ['full']: 100
};
const dismissPoint = {
    type: 'fixed',
    height: 0
};
function resolveHeight(height) {
    if (height === 'auto') height = {
        autoUpTo: 'full'
    };
    return typeof height === 'string' ? {
        type: 'fixed',
        height: heightMap[height]
    } : {
        type: 'auto',
        height: heightMap[height.autoUpTo]
    };
}
const VIEWPORT_DEBOUNCE_DURATION = 600;
function SheetInner({ handleRef, height = 'auto', scrollToResizeBelow, onHeightChange, onRequestClose, onScroll, backdropVisible, handleSafeAreaInsetBottom = true, id, children, title, description, header, headerStart, headerEnd, headerAlignment = 'center', headerDivider = 'always', footer, handleVisible = 'auto', _tempVideoOnlyIgnoreVirtualKeyboardOffset = false, ...contentContainerProps }) {
    const heights = ensureArray(height);
    Preconditions.checkArgument(heights.length > 0, 'Sheets require at least one height value');
    const snapPoints = [
        ...heights.map(resolveHeight),
        ...(onRequestClose != null ? [
            dismissPoint
        ] : [])
    ];
    const [snapPointIndex, setSnapPointIndex] = useStabilizedSnapPoint({
        snapPoints,
        onSnapPointChange: (index)=>onHeightChange?.(heights[index])
    });
    const containerRef = React.useRef(null);
    const footerRef = React.useRef(null);
    const contentRef = React.useRef(null);
    const endMarkerRef = React.useRef(null);
    React.useImperativeHandle(handleRef, ()=>({
            getScrollState: ()=>contentRef.current?.getScrollState(),
            setHeight: (height)=>{
                const newPoint = resolveHeight(height);
                const newIndex = snapPoints.findIndex((point)=>pointsEqual(point, newPoint));
                Preconditions.checkArgument(newIndex !== -1);
                setSnapPointIndex(newIndex);
            },
            scrollTo: (options)=>contentRef.current?.scrollTo(options),
            getBoundingClientRect: ()=>contentRef.current?.getBoundingClientRect(),
            get scrollTop () {
                return contentRef.current?.scrollTop;
            },
            get scrollLeft () {
                return contentRef.current?.scrollLeft;
            },
            get scrollHeight () {
                return contentRef.current?.scrollHeight;
            },
            get scrollWidth () {
                return contentRef.current?.scrollWidth;
            },
            get clientHeight () {
                return contentRef.current?.clientHeight;
            },
            get clientWidth () {
                return contentRef.current?.clientWidth;
            },
            get offsetHeight () {
                return contentRef.current?.offsetHeight;
            },
            get offsetWidth () {
                return contentRef.current?.offsetWidth;
            }
        }));
    const { resizing, controls } = useSheetControls({
        snapPoints,
        snapPointIndex,
        setSnapPointIndex: (index)=>{
            if (onRequestClose != null && snapPoints[index] === dismissPoint) {
                onRequestClose({
                    action: 'resize'
                });
                return;
            }
            setSnapPointIndex(index);
        },
        getScrollHeight: ()=>{
            const endMarkerTop = endMarkerRef.current?.offsetTop ?? 0;
            const footerHeight = footerRef.current?.clientHeight ?? 0;
            const dragHandleContainerHeight = baseUnit;
            return dragHandleContainerHeight + endMarkerTop + footerHeight + getSafeAreaInsets().bottom;
        },
        setOffset: (offset, snapPointHeight)=>requestAnimationFrame(()=>{
                const el = containerRef.current;
                if (el == null) return;
                let finalOffset = offset;
                if (offset != null && offset > 0) {
                    if (el.clientHeight === snapPointHeight) finalOffset = undefined;
                }
                el.style.transform = finalOffset != null ? `translateY(${-finalOffset}px)` : '';
                const footerEl = footerRef.current;
                if (footerEl == null) return;
                const footerDisplacementY = el.clientHeight - (snapPointHeight ?? 0);
                footerEl.style.transform = finalOffset != null ? `translateY(${finalOffset - footerDisplacementY}px)` : '';
            })
    });
    const viewportDifferenceHeight = useViewportHeightVariance();
    const customPropertyRef = React.useRef(null);
    const previousContainer = React.useRef(undefined);
    useViewportContainerSizeEffect((maybeViewportContainer)=>{
        if (maybeViewportContainer == null || customPropertyRef.current == null) return;
        const viewportContainer = maybeViewportContainer;
        const customPropertyEl = customPropertyRef.current;
        const virtualKeyboardHeight = _tempVideoOnlyIgnoreVirtualKeyboardOffset ? 0 : getVirtualKeyboardOverlayHeight();
        const visualViewportHeight = viewportContainer.height - (virtualKeyboardHeight > 0 ? getNonInteractiveHeight() : 0);
        const { scrollHeight = 0, clientHeight = 0, scrollTop = 0 } = contentRef.current || {};
        function updateCustomProperties(viewportIsExpanding) {
            const virtualKeyboardHeight = getVirtualKeyboardOverlayHeight();
            const style = customPropertyEl.style;
            style.setProperty(customProperties.visualViewportOffsetTop, `${viewportContainer.offsetTop}px`);
            style.setProperty(customProperties.visualViewportHeight, `${visualViewportHeight}px`);
            style.setProperty(customProperties.virtualKeyboardHeight, `${virtualKeyboardHeight}px`);
            const needScrollPositionAdjustment = !viewportIsExpanding && viewportContainer.offsetTop !== 0;
            const contentScrollBottom = scrollHeight - clientHeight - scrollTop;
            if (needScrollPositionAdjustment) {
                const { scrollHeight: newScrollHeight = 0, clientHeight: newClientHeight = 0 } = contentRef.current || {};
                const viewportTopDisplacement = viewportContainer.offsetTop - virtualKeyboardHeight;
                contentRef.current?.scrollTo({
                    top: viewportTopDisplacement + newScrollHeight - newClientHeight - contentScrollBottom
                });
            }
        }
        const previousHeight = previousContainer.current?.height ?? 0;
        previousContainer.current = viewportContainer;
        if (viewportContainer.height > previousHeight) {
            updateCustomProperties(true);
            return;
        }
        const id = setTimeout(updateCustomProperties, VIEWPORT_DEBOUNCE_DURATION);
        return ()=>clearTimeout(id);
    });
    const hasHandle = handleVisible === 'auto' && snapPoints.length > 1;
    const snapPoint = snapPoints[snapPointIndex];
    const snapHeight = calculateSnapHeight(snapPoint, resizing, containerRef);
    const onRequestCloseByBackdrop = React.useCallback(()=>{
        onRequestClose?.({
            action: 'backdrop'
        });
    }, [
        onRequestClose
    ]);
    const [isScrolled, setIsScrolled] = React.useState(false);
    const scrollTopRef = React.useRef(0);
    const handleScroll = React.useCallback(({ scrollTop })=>{
        onScroll?.({
            scrollTop
        });
        if (headerDivider !== 'when-scrolled') return;
        if (scrollTopRef.current === 0 && scrollTop > 0 || scrollTopRef.current > 0 && scrollTop === 0) {
            scrollTopRef.current = scrollTop;
            setIsScrolled(scrollTop > 0);
        }
    }, [
        onScroll,
        headerDivider,
        setIsScrolled,
        scrollTopRef
    ]);
    const { containerRef: scrollPaddingContainerRef, headerRef: scrollPaddingHeaderRef, footerRef: scrollPaddingFooterRef } = useScrollPaddingRefs();
    let content = _jsxs(_Fragment, {
        children: [
            children,
            _jsx("div", {
                ref: endMarkerRef
            })
        ]
    });
    const showHeaderDivider = headerDivider === 'always' || headerDivider === 'when-scrolled' && isScrolled;
    let endDecorator;
    if (headerEnd == null && onRequestClose != null) endDecorator = _jsx(SurfaceHeaderCloseButton, {
        onClick: ()=>onRequestClose()
    });
    else endDecorator = headerEnd === 'none' ? undefined : headerEnd;
    const standardHeader = title != null ? _jsx(SurfaceHeader, {
        title: title,
        description: description,
        start: headerStart,
        end: endDecorator,
        alignment: headerAlignment,
        divider: false
    }) : undefined;
    const hasDecorations = standardHeader != null || header != null || footer != null;
    if (hasDecorations) content = _jsxs(_Fragment, {
        children: [
            (standardHeader != null || header != null) && _jsxs("div", {
                ref: scrollPaddingHeaderRef,
                className: classNames(styles.header, {
                    [styles.headerBorder]: showHeaderDivider
                }),
                children: [
                    standardHeader,
                    header
                ]
            }),
            _jsx("div", {
                className: styles.content,
                children: content
            }),
            footer != null && _jsx("div", {
                className: styles.footer,
                ref: composeRefs(footerRef, scrollPaddingFooterRef),
                children: footer
            })
        ]
    });
    const isIos26OrAbove = getIsIos26OrAbove();
    const isFullHeight = snapPoint.height === heightMap['full'];
    return _jsxs("div", {
        ref: customPropertyRef,
        className: classNames(styles.sheetContainer, backdropVisible && styles.backdrop, hasDecorations && styles.hasDecorations, !isFullHeight && styles.sheetContainerTransition),
        style: {
            [customProperties.viewportDifferenceHeight]: viewportDifferenceHeight,
            [customProperties.snapHeight]: snapHeight
        },
        children: [
            _jsx("div", {
                className: styles.safeAreaHandler,
                children: _jsxs("div", {
                    className: classNames(styles.sheet, snapPoint.type === 'auto' && styles.auto, resizing && styles.resizing),
                    ref: containerRef,
                    children: [
                        backdropVisible && onRequestClose != null && _jsx("div", {
                            role: "none",
                            className: styles.dismissArea,
                            onClick: onRequestCloseByBackdrop
                        }),
                        hasHandle ? _jsx(SheetDragHandle, {
                            controls: controls
                        }) : _jsx(Spacer, {
                            size: "1u"
                        }),
                        _jsx(SheetContent, {
                            ref: contentRef,
                            scrollPaddingRef: scrollPaddingContainerRef,
                            scrollToResizeBelow: scrollToResizeBelow && resolveHeight(scrollToResizeBelow),
                            controls: controls,
                            handleSafeAreaInsetBottom: handleSafeAreaInsetBottom,
                            id: id,
                            onScroll: handleScroll,
                            ...contentContainerProps,
                            children: content
                        })
                    ]
                })
            }),
            isIos26OrAbove && _jsx("div", {
                className: styles.safari26ControlsBackground
            }),
            isIos26OrAbove && _jsx("div", {
                className: styles.safari26KeyboardBackground
            })
        ]
    });
}
function ensureArray(argument) {
    if (Array.isArray(argument)) return argument;
    return [
        argument
    ];
}
function useStabilizedSnapPoint({ snapPoints, onSnapPointChange }) {
    const [index, setRawIndex] = React.useState(0);
    const previousSnapPoints = React.useRef(snapPoints);
    const setIndex = useStableFunction((newIndex)=>{
        setRawIndex(newIndex);
        if (!pointsEqual(snapPoints[newIndex], previousSnapPoints.current[index]))
            onSnapPointChange(newIndex);
    });
    useIsomorphicLayoutEffect(()=>{
        const previousPoint = previousSnapPoints.current[index];
        if (!pointsEqual(snapPoints[index], previousPoint)) {
            let newIndex = snapPoints.findIndex((point)=>pointsEqual(point, previousPoint));
            if (newIndex === -1) newIndex = 0;
            setIndex(newIndex);
        }
        previousSnapPoints.current = snapPoints;
    }, [
        snapPoints,
        index,
        setIndex
    ]);
    return [
        Math.min(index, snapPoints.length - 1),
        setIndex
    ];
}
const pointsEqual = (a, b)=>a != null && b != null && a.type === b.type && a.height === b.height;
function calculateSnapHeight(snapPoint, resizing, containerRef) {
    switch(snapPoint.type){
        case 'fixed':
            return snapPoint.height + '%';
        case 'auto':
            if (!resizing)
                return snapPoint.height + '%';
            return (containerRef.current?.clientHeight ?? 0) - getSafeAreaInsets().bottom + 'px';
        default:
            throw new UnreachableError(snapPoint);
    }
}
function SheetDragHandle({ controls }) {
    const { dragRef } = useSheetDrag({
        controls
    });
    return _jsx("div", {
        className: styles.dragHandleContainer,
        ref: dragRef,
        children: _jsx("div", {
            className: styles.dragHandle
        })
    });
}
function SheetContent(
    { controls, scrollToResizeBelow, handleSafeAreaInsetBottom, onScroll, id, children, scrollPaddingRef, ref, ...contentContainerProps }
) {
    const { contentRef } = useSheetScroll({
        controls,
        scrollToResizeBelow
    });
    const { hasScroll, contentScrollRef } = useContentScrollable();
    const imperativeScrollRef = useImperativeScrollRef(ref);
    const handleScroll = React.useCallback((e)=>{
        const scrollTop = e.target?.scrollTop ?? 0;
        onScroll?.({
            scrollTop
        });
    }, [
        onScroll
    ]);
    return _jsx(ContentContainer, {
        ref: composeRefs(contentRef, contentScrollRef, imperativeScrollRef, scrollPaddingRef),
        id: id,
        className: classNames(styles.contentContainer, backgroundStyles.elevationSurfaceRaisedBackground, {
            [styles.handleSafeAreaInsetBottom]: handleSafeAreaInsetBottom,
            [styles.noTouchAction]: !hasScroll
        }),
        onScroll: handleScroll,
        ...contentContainerProps,
        children: children
    });
}
function useImperativeScrollRef(ref) {
    const innerRef = React.useRef(null);
    React.useImperativeHandle(ref, ()=>({
            getScrollState: ()=>innerRef.current ? getScrollState(innerRef.current) : undefined,
            scrollTo: (options)=>{
                const el = innerRef?.current;
                if (el == null) return;
                if (typeof options === 'number') el.scrollTo(0, options);
                else el.scrollTo(options);
            },
            getBoundingClientRect: ()=>innerRef.current?.getBoundingClientRect(),
            get scrollTop () {
                return innerRef.current?.scrollTop;
            },
            get scrollLeft () {
                return innerRef.current?.scrollLeft;
            },
            get scrollHeight () {
                return innerRef.current?.scrollHeight;
            },
            get scrollWidth () {
                return innerRef.current?.scrollWidth;
            },
            get clientHeight () {
                return innerRef.current?.clientHeight;
            },
            get clientWidth () {
                return innerRef.current?.clientWidth;
            },
            get offsetHeight () {
                return innerRef.current?.offsetHeight;
            },
            get offsetWidth () {
                return innerRef.current?.offsetWidth;
            }
        }));
    return innerRef;
}
const globalNavigator = typeof navigator !== 'undefined' ? navigator : undefined;
const getIsIos26OrAbove = ()=>{
    return globalNavigator != null && !!globalNavigator.userAgent.match(/iPhone OS 18_/gi) && !globalNavigator.userAgent.match(/Version\/18/gi);
};
