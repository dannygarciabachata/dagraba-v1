import { jsx as _jsx } from "react/jsx-runtime";
import { createContext, useCallback, useContext, useEffect, useId, useRef, useState } from 'react';
import 'react';
import { useControllableValue } from '../../controllable_value/controllable_value';
import { useIsomorphicLayoutEffect } from '../../hydration/use_isomorphic_layout_effect';
import { useStableFunction } from '../../stable_function/stable_function';
import { useCache } from './cache';
import { useFocusableChildren, useKeyboardFocusNavigation } from './focusable_children';
import { generateId } from './generate_id';
export const useTab = ({ id, active: activeProp, onClick: onClickProp, ariaControls: ariaControlsProp })=>{
    const context = useTabsContext();
    const isControlled = !context || activeProp != null;
    const active = isControlled ? activeProp : context.activeId === id;
    const registerTabId = context?.registerTabId;
    const unregisterTabId = context?.unregisterTabId;
    const setActiveId = context?.setActiveId;
    const role = 'tab';
    const htmlId = context ? generateId(context.tabsId, id, role) : id;
    const tabIndex = active ? undefined : -1;
    const ariaControls = context && context.tabPanelIds.includes(id) ? generateId(context.tabsId, id, 'tabpanel') : ariaControlsProp;
    useEffect(()=>{
        if (isControlled) return;
        registerTabId?.(id);
        return ()=>{
            unregisterTabId?.(id);
        };
    }, [
        isControlled,
        registerTabId,
        unregisterTabId,
        id
    ]);
    const onClick = useCallback(()=>{
        if (active) return;
        onClickProp?.(id);
        if (!isControlled) setActiveId?.(id);
    }, [
        isControlled,
        active,
        setActiveId,
        id,
        onClickProp
    ]);
    const onFocus = useCallback(()=>{
        onClick();
    }, [
        onClick
    ]);
    return {
        active,
        id: htmlId,
        role,
        ariaControls,
        tabIndex,
        onClick,
        onFocus
    };
};
export const useTabList = ()=>{
    const { ref } = useKeyboardFocusNavigation();
    return {
        ref: ref,
        role: 'tablist'
    };
};
export const useTabPanel = ({ id, active: activeProp, ariaLabelledBy: ariaLabelledByProp, children: childrenProp, contentRenderStrategy = 'lazy' })=>{
    const context = useTabsContext();
    const { ref, focusableChildren } = useFocusableChildren({
        onlyTabbables: true
    });
    const isControlled = !context || activeProp != null;
    const active = isControlled ? activeProp : context.activeId === id;
    const registerTabPanelId = context?.registerTabPanelId;
    const unregisterTabPanelId = context?.unregisterTabPanelId;
    const role = 'tabpanel';
    const htmlId = context ? generateId(context.tabsId, id, role) : id;
    const ariaLabelledBy = context && context.tabIds.includes(id) ? generateId(context.tabsId, id, 'tab') : ariaLabelledByProp;
    useEffect(()=>{
        if (isControlled) return;
        registerTabPanelId?.(id);
        return ()=>{
            unregisterTabPanelId?.(id);
        };
    }, [
        isControlled,
        registerTabPanelId,
        unregisterTabPanelId,
        id
    ]);
    let children = childrenProp;
    const { setItem, getItem } = useCache();
    if (contentRenderStrategy === 'lazy') {
        if (active) setItem(id, children);
        children = getItem(id);
    } else if (contentRenderStrategy === 'always-remount' && !active) children = null;
    return {
        ref: ref,
        active,
        id: htmlId,
        role,
        ariaLabelledBy,
        tabIndex: active ? focusableChildren.length > 0 ? undefined : 0 : -1,
        children
    };
};
export const TabsContext = createContext(null);
export function useTabsContext() {
    return useContext(TabsContext);
}
export const useTabs = ({ activeId: activeIdProp, defaultActiveId, onSelect })=>{
    const tabsId = useId();
    const [activeId, setActiveId] = useControllableValue({
        value: activeIdProp,
        defaultValue: defaultActiveId
    });
    const [tabIds, setTabIds] = useState([]);
    const [tabPanelIds, setTabPanelIds] = useState([]);
    const registerTabId = useStableFunction((id)=>{
        setTabIds((prevIds)=>[
                ...prevIds,
                id
            ]);
    });
    const unregisterTabId = useStableFunction((id)=>{
        setTabIds((prevIds)=>prevIds.filter((i)=>i !== id));
    });
    const registerTabPanelId = useStableFunction((id)=>{
        setTabPanelIds((prevIds)=>[
                ...prevIds,
                id
            ]);
    });
    const unregisterTabPanelId = useStableFunction((id)=>{
        setTabPanelIds((prevIds)=>prevIds.filter((i)=>i !== id));
    });
    useEffect(()=>{
        if (!activeId || tabIds.length > 0 && !tabIds.includes(activeId))
            setActiveId(tabIds[0]);
    }, [
        activeId,
        setActiveId,
        tabIds
    ]);
    const prevActiveId = useRef(activeId);
    useEffect(()=>{
        if (activeId == null || activeId === prevActiveId.current) return;
        onSelect?.(activeId, prevActiveId.current);
        prevActiveId.current = activeId;
    }, [
        activeId,
        onSelect
    ]);
    return {
        tabsId,
        activeId,
        setActiveId,
        tabIds,
        tabPanelIds,
        registerTabId,
        unregisterTabId,
        registerTabPanelId,
        unregisterTabPanelId
    };
};
const TabsElementsContext = createContext(null);
export const TabsElementsProvider = ({ children })=>{
    const [activeElementRef, setActiveElementRef] = useState(null);
    const [elementRefs, setElementRefs] = useState([]);
    const [isAnimating, setIsAnimating] = useState(false);
    const registerElementRef = useStableFunction((element)=>{
        setElementRefs((prevRefs)=>[
                ...prevRefs,
                element
            ].sort(byDocumentPosition));
    });
    const unregisterElementRef = useStableFunction((element)=>{
        setElementRefs((prevRefs)=>prevRefs.filter((i)=>i !== element));
    });
    return _jsx(TabsElementsContext.Provider, {
        value: {
            elementRefs,
            registerElementRef,
            unregisterElementRef,
            activeElementRef,
            setActiveElementRef,
            isAnimating,
            setIsAnimating
        },
        children: children
    });
};
function byDocumentPosition(a, b) {
    return a.compareDocumentPosition?.(b) & Node.DOCUMENT_POSITION_PRECEDING ? 1 : -1;
}
export function useRegisterTabsElements(active) {
    const ref = useRef(null);
    const context = useContext(TabsElementsContext);
    const registerElementRef = context?.registerElementRef;
    const unregisterElementRef = context?.unregisterElementRef;
    useIsomorphicLayoutEffect(()=>{
        const element = ref.current;
        if (!element) return;
        registerElementRef?.(element);
        return ()=>{
            unregisterElementRef?.(element);
        };
    }, [
        registerElementRef,
        unregisterElementRef
    ]);
    useIsomorphicLayoutEffect(()=>{
        if (context && active && ref.current && context.activeElementRef !== ref.current) context.setActiveElementRef(ref.current);
    }, [
        context,
        active
    ]);
    return {
        ref
    };
}
export function useTabsElements() {
    const context = useContext(TabsElementsContext);
    return {
        activeElementRef: context?.activeElementRef ?? null,
        setActiveElementRef: context?.setActiveElementRef,
        elementRefs: context?.elementRefs ?? [],
        registerElementRef: context?.registerElementRef,
        unregisterElementRef: context?.registerElementRef,
        isAnimating: context?.isAnimating,
        setIsAnimating: context?.setIsAnimating
    };
}
