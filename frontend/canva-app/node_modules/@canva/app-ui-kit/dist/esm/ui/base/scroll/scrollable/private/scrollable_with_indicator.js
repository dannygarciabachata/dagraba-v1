import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { debounce } from '../../../../../base/debounce';
import { UnreachableError } from '../../../../../base/preconditions';
import classNames from 'classnames';
import * as React from 'react';
import { useDirection, useEnableAnimations } from '../../../provider/provider';
import { BaseScrollable } from './base_scrollable';
import styles from './scrollable_with_indicator.css';
const isWebkit = ()=>typeof window !== 'undefined' ? /AppleWebKit\//i.test(window.navigator.userAgent) : undefined;
const runningInWebkit = isWebkit();
export const ScrollableWithIndicator = (props)=>{
    const [showStartIndicator, setShowStartIndicator] = React.useState(false);
    const [showEndIndicator, setShowEndIndicator] = React.useState(false);
    const [widths, setWidths] = React.useState(null);
    const isRtl = useDirection() === 'RTL';
    const { children, direction, onScroll, onScrollStateChange, debounceMs, ariaLabel, role, type, background, ref } = props;
    const applyWebkitRtlFix = runningInWebkit && isRtl && direction === 'horizontal';
    const enableAnimations = useEnableAnimations();
    const updateWidths = React.useCallback((scrollState)=>{
        const { scrollable, containerWidth, scrollWidth } = scrollState;
        if (!scrollable || containerWidth === widths?.client && scrollWidth === widths?.scroll) return;
        setWidths({
            client: containerWidth,
            scroll: scrollWidth
        });
    }, [
        widths
    ]);
    const updateIndicators = React.useCallback((scrollState)=>{
        const atStart = direction === 'horizontal' ? scrollState.atStart : scrollState.atTop;
        const atEnd = direction === 'horizontal' ? scrollState.atEnd : scrollState.atBottom;
        if (!scrollState.scrollable) {
            setShowStartIndicator(false);
            setShowEndIndicator(false);
        } else {
            setShowStartIndicator(!atStart);
            setShowEndIndicator(!atEnd);
        }
        if (applyWebkitRtlFix)
            updateWidths(scrollState);
    }, [
        direction,
        applyWebkitRtlFix,
        updateWidths
    ]);
    const handleScrollStateChange = React.useMemo(()=>{
        const debouncedOnScrollStateChange = onScrollStateChange && debounceMs ? debounce(onScrollStateChange, debounceMs, {
            leading: true
        }) : onScrollStateChange;
        return (scrollState)=>{
            updateIndicators(scrollState);
            debouncedOnScrollStateChange?.(scrollState);
        };
    }, [
        onScrollStateChange,
        debounceMs,
        updateIndicators
    ]);
    const handleOnScroll = React.useMemo(()=>{
        return onScroll && debounceMs ? debounce(onScroll, debounceMs, {
            leading: true
        }) : onScroll;
    }, [
        onScroll,
        debounceMs
    ]);
    const indicatorWrapperSharedStyles = classNames(styles.indicatorWrapper, getDirectionClassName(direction));
    const indicatorSharedStyles = classNames(styles.indicator, getBackgroundClassName(background), getIndicatorTypeClassName(type), getDirectionClassName(direction), {
        [styles.animate]: enableAnimations
    });
    return _jsxs(BaseScrollable, {
        direction: direction,
        onScroll: handleOnScroll,
        onScrollStateChange: handleScrollStateChange,
        ariaLabel: ariaLabel,
        role: role,
        ref: ref,
        className: classNames(styles.scrollContainer, getDirectionClassName(direction)),
        children: [
            _jsx("div", {
                className: classNames(indicatorWrapperSharedStyles, styles.start),
                style: {
                    right: applyWebkitRtlFix && !!widths ? `${widths.scroll - widths.client}px` : undefined
                },
                children: _jsx("div", {
                    className: classNames(indicatorSharedStyles, styles.start, {
                        [styles.isVisible]: showStartIndicator
                    })
                })
            }),
            _jsx("div", {
                className: classNames(indicatorWrapperSharedStyles, styles.end),
                style: {
                    right: applyWebkitRtlFix && !!widths ? `${widths.scroll}px` : undefined
                },
                children: _jsx("div", {
                    className: classNames(indicatorSharedStyles, styles.end, {
                        [styles.isVisible]: showEndIndicator
                    })
                })
            }),
            _jsx("div", {
                className: styles.childrenWrapper,
                children: children
            })
        ]
    });
};
function getBackgroundClassName(background) {
    switch(background){
        case 'canvas':
            return styles.canvas;
        case 'tabdock':
            return styles.tabdock;
        case 'surface':
            return styles.surface;
        case 'page':
            return styles.page;
        default:
            throw new UnreachableError(background);
    }
}
function getIndicatorTypeClassName(type) {
    switch(type){
        case 'shadow':
            return styles.shadow;
        case 'fade':
            return styles.fade;
        default:
            throw new UnreachableError(type);
    }
}
function getDirectionClassName(direction) {
    switch(direction){
        case 'vertical':
            return styles.vertical;
        case 'horizontal':
            return styles.horizontal;
        default:
            throw new UnreachableError(direction);
    }
}
