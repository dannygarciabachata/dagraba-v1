import { jsx as _jsx } from "react/jsx-runtime";
import { composeRefs } from '../../../base/react/compose_refs';
import * as React from 'react';
import styles from './focus.css';
import { findFocusables } from './internal/focus_utils';
function useMutationObserver(callback) {
    const ref = React.useRef(null);
    const observerRef = React.useRef(undefined);
    React.useEffect(()=>{
        if (!ref.current) return;
        observerRef.current = new MutationObserver(callback);
        observerRef.current.observe(ref.current, {
            childList: true,
            subtree: true
        });
        callback([], observerRef.current);
        return ()=>observerRef.current?.disconnect();
    }, [
        callback
    ]);
    return {
        ref
    };
}
export function useCreateFocusManager() {
    const rootRef = React.useRef(null);
    const focusablesRef = React.useRef([]);
    const focusedRef = React.useRef(null);
    const onMutation = React.useCallback(()=>{
        if (rootRef.current) focusablesRef.current = findFocusables(rootRef.current);
    }, []);
    const { ref: observerRef } = useMutationObserver(onMutation);
    const ref = composeRefs(rootRef, observerRef);
    const onFocusCapture = React.useCallback((e)=>{
        if (!(e.target instanceof HTMLElement)) return;
        focusedRef.current = e.target;
    }, []);
    const onBlur = React.useCallback((e)=>{
        if (!(e.relatedTarget instanceof HTMLElement)) return;
        if (rootRef.current?.contains(e.relatedTarget)) return;
        focusedRef.current = null;
    }, []);
    const focusManager = React.useMemo(()=>({
            get focused () {
                return focusedRef.current;
            },
            get focusables () {
                return focusablesRef.current.slice();
            },
            focusAt (index, options) {
                const { wrap = true } = options ?? {};
                const focusables = focusablesRef.current;
                const focusable = focusables[wrap ? index % focusables.length : index];
                if (!focusable) return;
                focusable.focus();
                return focusable;
            },
            focusNext (options) {
                const { wrap = true } = options ?? {};
                const focusables = focusablesRef.current;
                const currentIndex = focusables.findIndex((el)=>el === focusedRef.current);
                if (currentIndex === -1) return;
                const nextIndex = wrap ? (currentIndex + 1) % focusables.length : Math.min(currentIndex + 1, focusables.length - 1);
                const focusable = focusables[nextIndex];
                if (!focusable) return;
                focusable.focus();
                return focusable;
            },
            focusPrevious (options) {
                const { wrap = true } = options ?? {};
                const focusables = focusablesRef.current;
                const currentIndex = focusables.findIndex((el)=>el === focusedRef.current);
                if (currentIndex === -1) return;
                const prevIndex = wrap ? currentIndex > 0 ? currentIndex - 1 : focusables.length - 1 : Math.max(0, currentIndex - 1);
                const focusable = focusables[prevIndex];
                if (!focusable) return;
                focusable.focus();
                return focusable;
            },
            focusFirst () {
                const focusables = focusablesRef.current;
                const focusable = focusables[0];
                if (!focusable) return;
                focusable.focus();
                return focusable;
            },
            focusLast () {
                const focusables = focusablesRef.current;
                const focusable = focusables[focusables.length - 1];
                if (!focusable) return;
                focusable.focus();
                return focusable;
            }
        }), []);
    return {
        ref,
        onFocusCapture,
        onBlur,
        focusManager
    };
}
const FocusManagerContext = React.createContext(null);
export const FocusManagerProvider = FocusManagerContext.Provider;
export function WithFocusManager(props) {
    const { ref, onFocusCapture, onBlur, focusManager } = useCreateFocusManager();
    return _jsx(FocusManagerProvider, {
        value: focusManager,
        children: _jsx("div", {
            ref: ref,
            onFocusCapture: onFocusCapture,
            onBlur: onBlur,
            className: styles.nolayout,
            children: props.children
        })
    });
}
export function useFocusManager() {
    return React.useContext(FocusManagerContext);
}
