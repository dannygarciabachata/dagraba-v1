"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get Carousel () {
        return Carousel;
    },
    get CarouselCenterAlignSpacer () {
        return CarouselCenterAlignSpacer;
    },
    get CarouselItem () {
        return CarouselItem;
    },
    get CarouselSkipLinks () {
        return CarouselSkipLinks;
    },
    get ProminentScrollButton () {
        return ProminentScrollButton;
    },
    get SubtleScrollButton () {
        return SubtleScrollButton;
    },
    get carouselGaps () {
        return carouselGaps;
    },
    get useScrollButtonAriaLabel () {
        return _scroll_button.useScrollButtonAriaLabel;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _debounce = require('../../../../base/debounce');
const _compose_refs = require('../../../../base/react/compose_refs');
const _react = _interop_require_wildcard(require("react"));
const _skip_link = require('../../a11y/skip_link/skip_link');
const _focus = require('../../focus/focus');
const _metrics = require('../../metrics/metrics');
const _use_responsive_value = require('../../responsive/use_responsive_value');
const _scroll_button = require('../../scroll/scroll_button/scroll_button');
const _scrollable_items = require('../../scroll/scrollable_items/scrollable_items');
const _scroll_window = require('../../scroll_controls/scroll_window');
const _stable_function = require('../../stable_function/stable_function');
const _carouselcss = _interop_require_default(require("./carousel.css"));
const _carouselmessages = require("./carousel.messages");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const ProminentScrollButton = (props)=>{
    return (0, _jsxruntime.jsx)(_scroll_button.ProminentScrollButton, {
        position: "bounded",
        ...props
    });
};
const SubtleScrollButton = (props)=>{
    return (0, _jsxruntime.jsx)(_scroll_button.SubtleScrollButton, {
        position: "bounded",
        ...props
    });
};
const carouselGaps = _scrollable_items.scrollableItemsGaps;
const Carousel = _react.memo(
    function Carousel({ role, ariaLabel, ariaLabelledBy, ariaDescribedBy, ariaSetSize, children, onScroll: onScrollProp, onScrollStateChange: onScrollStateChangeProp, scrollableRef, scrollHandleRef, padding, paddingX, paddingY, paddingTop, paddingBottom, paddingStart, paddingEnd, gap = '2u', snap = 'proximity', snapAlign = 'start', virtualization, skipLinksScrollMarginTop, disableSkipLinks = true, outOfViewItemBehavior = 'inert', fadeSize = '6u', itemWidth = 'intrinsic', scrollButton = (props)=> (0, _jsxruntime.jsx)(ProminentScrollButton, {
            ...props
        }) }) {
        const prevButtonHandle = _react.useRef(null);
        const nextButtonHandle = _react.useRef(null);
        const carouselId = _react.useId();
        const responsiveGap = typeof gap === 'object' ? gap : {
            default: gap
        };
        const gapValue = (0, _use_responsive_value.useResponsiveValue)(responsiveGap);
        const gapInPixel = (0, _metrics.unitSizeToNumber)(gapValue);
        const itemWidths = virtualization ? Array.isArray(virtualization.itemWidths) ? virtualization.itemWidths : new Array(_react.Children.count(children)).fill(virtualization.itemWidths) : undefined;
        const getItemWidth = _react.useCallback((index)=>{
            if (itemWidths) return itemWidths[index];
            return 0;
        }, [
            itemWidths
        ]);
        const scrollableItemsHandle = _react.useRef(null);
        _react.useImperativeHandle(scrollHandleRef, ()=>{
            return mapScrollHandle(scrollableItemsHandle);
        });
        const [atStart, setAtStart] = _react.useState(true);
        const [atEnd, setAtEnd] = _react.useState(true);
        const onScrollStateChange = (0, _stable_function.useStableFunction)((scrollableItemsState)=>{
            const state = mapScrollState(scrollableItemsState);
            onScrollStateChangeProp?.(state);
            setAtStart(state.atStart);
            setAtEnd(state.atEnd);
        });
        const onScroll = (0, _stable_function.useStableFunction)((state)=>{
            onScrollProp?.(mapScrollState(state));
        });
        const { ref: focusManagementRef, onFocus, focusNextItem, focusPreviousItem } = useCarouselFocusManagement();
        const scrollableItemsProps = {
            id: carouselId,
            onFocus,
            direction: 'horizontal',
            ref: scrollableItemsHandle,
            onScrollStateChange,
            onScroll,
            snap,
            snapAlign,
            padding,
            paddingX,
            paddingY,
            paddingTop,
            paddingBottom,
            paddingStart,
            paddingEnd,
            gap,
            fadeSize,
            role,
            ariaLabel,
            ariaLabelledBy,
            ariaDescribedBy,
            ariaSetSize,
            outOfViewItemBehavior
        };
        const scrollToPreviousPage = _react.useCallback(()=>{
            scrollableItemsHandle.current?.scrollByPage({
                x: -1
            });
        }, [
            scrollableItemsHandle
        ]);
        const scrollToNextPage = _react.useCallback(()=>{
            scrollableItemsHandle.current?.scrollByPage({
                x: 1
            });
        }, [
            scrollableItemsHandle
        ]);
        const containerRef = _react.useRef(null);
        return (0, _jsxruntime.jsx)("div", {
            className: _carouselcss.default.carouselContainer,
            ref: containerRef,
            tabIndex: -1,
            children: (0, _jsxruntime.jsxs)(CarouselSkipLinks, {
                carouselName: ariaLabel,
                disableSkipLinks: disableSkipLinks,
                scrollMarginTop: skipLinksScrollMarginTop,
                children: [
                    scrollButton({
                        scrollableId: carouselId,
                        direction: 'backward',
                        onClick: ()=>{
                            if (outOfViewItemBehavior === 'inert') {
                                containerRef.current?.focus();
                                onScrollEnd(focusManagementRef.current, focusPreviousItem, {
                                    once: true
                                });
                            }
                            scrollToPreviousPage();
                        },
                        atStart,
                        atEnd,
                        buttonHandle: prevButtonHandle,
                        oppositeButtonHandle: nextButtonHandle,
                        ariaLabel,
                        ariaLabelledBy
                    }),
                    virtualization ? (0, _jsxruntime.jsx)(_scroll_window.ScrollWindow, {
                        innerRef: scrollableRef,
                        layout: "horizontal",
                        children: ({ scrollableRef: scrollWindowRef, scrollState: windowScrollState })=>(0, _jsxruntime.jsx)(_scrollable_items.ScrollableItems, {
                                scrollableRef: (0, _compose_refs.composeRefs)(scrollWindowRef, focusManagementRef),
                                getItemWidth: getItemWidth,
                                itemCount: itemWidths.length,
                                ...scrollableItemsProps,
                                children: (0, _jsxruntime.jsx)(VirtualizedChildren, {
                                    virtualization: virtualization,
                                    scrollState: windowScrollState,
                                    itemWidths: itemWidths,
                                    itemGap: gapInPixel,
                                    children: children,
                                    snap: snap
                                })
                            })
                    }) : (0, _jsxruntime.jsx)(_scrollable_items.ScrollableItems, {
                        scrollableRef: (0, _compose_refs.composeRefs)(scrollableRef, focusManagementRef),
                        itemSize: itemWidth,
                        ...scrollableItemsProps,
                        children: children
                    }),
                    scrollButton({
                        scrollableId: carouselId,
                        direction: 'forward',
                        onClick: ()=>{
                            if (outOfViewItemBehavior === 'inert') {
                                containerRef.current?.focus();
                                onScrollEnd(focusManagementRef.current, focusNextItem, {
                                    once: true
                                });
                            }
                            scrollToNextPage();
                        },
                        atStart,
                        atEnd,
                        buttonHandle: nextButtonHandle,
                        oppositeButtonHandle: prevButtonHandle,
                        ariaLabel,
                        ariaLabelledBy
                    })
                ]
            })
        });
    }
);
const mapScrollState = (scrollableItemsState)=>{
    const itemState = scrollableItemsState.itemX;
    const pageState = scrollableItemsState.pageX;
    return {
        x: scrollableItemsState.x,
        currentItemIndex: itemState?.currentItemIndex,
        numberOfItems: itemState?.numberOfItems,
        currentPageIndex: pageState?.currentPageIndex,
        numberOfPages: pageState?.numberOfPages,
        scrollable: scrollableItemsState.scrollableX,
        containerWidth: scrollableItemsState.containerWidth,
        containerHeight: scrollableItemsState.containerHeight,
        scrollWidth: scrollableItemsState.scrollWidth,
        scrollHeight: scrollableItemsState.scrollHeight,
        atStart: scrollableItemsState.atStart,
        atEnd: scrollableItemsState.atEnd
    };
};
const mapScrollHandle = (scrollableItemsHandle)=>{
    const handle = scrollableItemsHandle?.current;
    return {
        getScrollState: ()=>{
            const state = handle?.getScrollState();
            return state ? mapScrollState(state) : undefined;
        },
        scrollTo: (to, options)=>handle?.scrollTo({
                x: to,
                ...options
            }),
        scrollBy: (by, options)=>handle?.scrollBy({
                x: by,
                ...options
            }),
        scrollToPage: (to, options)=>handle?.scrollToPage({
                x: to,
                ...options
            }),
        scrollByPage: (by, options)=>handle?.scrollByPage({
                x: by,
                ...options
            }),
        scrollToItem: (to, options)=>handle?.scrollToItem({
                x: to,
                ...options
            }),
        scrollByItem: (by, options)=>handle?.scrollByItem({
                x: by,
                ...options
            })
    };
};
const CarouselItem = ({ width, ...props })=>{
    return (0, _jsxruntime.jsx)(_scrollable_items.ScrollableItem, {
        ...props,
        size: width
    });
};
const CarouselCenterAlignSpacer = ()=>{
    return (0, _jsxruntime.jsx)(_scrollable_items.ScrollableItemsCenterAlignSpacer, {});
};
const Spacer = _react.memo(function Spacer({ width }) {
    return (0, _jsxruntime.jsx)("span", {
        className: _carouselcss.default.spacer,
        style: {
            width
        }
    });
});
const CarouselSkipLinks = _react.memo(
    function CarouselSkipLinks({ carouselName, children, scrollMarginTop, disableSkipLinks }) {
        const idStart = _react.useId();
        const idEnd = _react.useId();
        if (disableSkipLinks) return children;
        return (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
            children: [
                (0, _jsxruntime.jsx)(_skip_link.SkipTarget, {
                    id: idStart,
                    scrollMarginTop: scrollMarginTop,
                    label: carouselName ? _carouselmessages.CarouselMessages.namedListStart(carouselName) : _carouselmessages.CarouselMessages.listStart()
                }),
                (0, _jsxruntime.jsx)(_skip_link.SkipLink, {
                    to: idEnd,
                    position: "top",
                    children: carouselName ? _carouselmessages.CarouselMessages.skipToNamedListEnd(carouselName) : _carouselmessages.CarouselMessages.skipToEnd()
                }),
                children,
                (0, _jsxruntime.jsx)(_skip_link.SkipLink, {
                    to: idStart,
                    position: "bottom",
                    children: carouselName ? _carouselmessages.CarouselMessages.skipToNamedListStart(carouselName) : _carouselmessages.CarouselMessages.skipToStart()
                }),
                (0, _jsxruntime.jsx)(_skip_link.SkipTarget, {
                    id: idEnd,
                    scrollMarginTop: scrollMarginTop,
                    label: carouselName ? _carouselmessages.CarouselMessages.namedListEnd(carouselName) : _carouselmessages.CarouselMessages.listEnd()
                })
            ]
        });
    }
);
const VirtualizedChildren = _react.memo(
    function VirtualizedChildren({ scrollState, virtualization, itemWidths, itemGap = 0, children, snap }) {
        const itemWidthsWithGap = _react.useMemo(()=>{
            const value = itemGap > 0 ? itemWidths.map((width)=>width + itemGap) : itemWidths;
            if (itemGap > 0 && value.length > 0) value[value.length - 1] -= itemGap;
            return value;
        }, [
            itemGap,
            itemWidths
        ]);
        return (0, _jsxruntime.jsx)(_scroll_window.WindowedList, {
            scrollState: scrollState,
            itemSizes: itemWidthsWithGap,
            overscan: virtualization.overscan,
            children: (windowedListState, itemPositions)=>{
                const { firstVisible, lastVisible } = windowedListState ?? {
                    firstVisible: 0,
                    lastVisible: Math.min(virtualization.initialRender ?? 1, itemPositions.length - 1)
                };
                if (snap !== 'none')
                return _react.Children.map(children, (child, index)=>{
                    const width = Array.isArray(virtualization.itemWidths) ? virtualization.itemWidths[index] : virtualization.itemWidths;
                    return firstVisible <= index && index < lastVisible ? child : (0, _jsxruntime.jsx)(CarouselItem, {
                        index: index,
                        children: (0, _jsxruntime.jsx)(Spacer, {
                            width: width
                        })
                    });
                });
                const spaceBeforeWithTrailingGap = itemPositions[firstVisible];
                const spaceBefore = spaceBeforeWithTrailingGap === 0 ? 0 : spaceBeforeWithTrailingGap - itemGap;
                const spaceAfter = itemPositions[itemPositions.length - 1] - itemPositions[lastVisible];
                return (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
                    children: [
                        spaceBefore !== 0 && (0, _jsxruntime.jsx)(Spacer, {
                            width: spaceBefore
                        }),
                        _react.Children.toArray(children).slice(firstVisible, lastVisible),
                        spaceAfter !== 0 && (0, _jsxruntime.jsx)(Spacer, {
                            width: spaceAfter
                        })
                    ]
                });
            }
        });
    }
);
function onScrollEnd(element, listener, options = {}) {
    if (!element || !listener) return;
    const { once, debounceMs = 50 } = options;
    const wrappedCallback = ()=>{
        listener();
        once && element.removeEventListener('scroll', onScroll);
    };
    const onScroll = (0, _debounce.debounce)(wrappedCallback, debounceMs);
    element.addEventListener('scroll', onScroll);
}
function useCarouselFocusManagement() {
    const scrollContainerRef = _react.useRef(null);
    const lastFocusedItemRef = _react.useRef(null);
    const onFocus = _react.useEffectEvent((e)=>{
        let el = e.target;
        while(el?.parentElement != null && el.parentElement !== scrollContainerRef.current)el = el.parentElement;
        lastFocusedItemRef.current = el;
    });
    const focusNextItem = _react.useEffectEvent(()=>{
        if (!lastFocusedItemRef.current || lastFocusedItemRef.current.inert) focusFirstVisibleItem(scrollContainerRef.current);
        else (0, _focus.findFocusable)(lastFocusedItemRef.current)?.focus({
            preventScroll: true
        });
    });
    const focusPreviousItem = _react.useEffectEvent(()=>{
        if (!lastFocusedItemRef.current || lastFocusedItemRef.current.inert) focusLastVisibleItem(scrollContainerRef.current);
        else (0, _focus.findFocusable)(lastFocusedItemRef.current)?.focus({
            preventScroll: true
        });
    });
    return {
        ref: scrollContainerRef,
        onFocus,
        focusNextItem,
        focusPreviousItem
    };
}
function focusFirstVisibleItem(container) {
    if (container == null) return;
    let firstVisibleItem = null;
    for(let i = 0; i < container.children.length - 1; i++){
        const child = container.children.item(i);
        if (child?.getAttribute('inert') == null) {
            firstVisibleItem = child;
            break;
        }
    }
    firstVisibleItem && (0, _focus.findFocusable)(firstVisibleItem)?.focus({
        preventScroll: true
    });
}
function focusLastVisibleItem(container) {
    if (container == null) return;
    let lastVisibleItem = null;
    for(let i = container.children.length - 1; i > 0; i--){
        const child = container.children.item(i);
        if (child?.getAttribute('inert') == null) {
            lastVisibleItem = child;
            break;
        }
    }
    lastVisibleItem && (0, _focus.findFocusable)(lastVisibleItem)?.focus({
        preventScroll: true
    });
}
