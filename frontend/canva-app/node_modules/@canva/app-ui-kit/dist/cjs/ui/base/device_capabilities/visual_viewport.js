"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get getViewportContainerSize () {
        return getViewportContainerSize;
    },
    get getVisualViewport () {
        return getVisualViewport;
    },
    get useViewportContainerSize () {
        return useViewportContainerSize;
    },
    get useViewportContainerSizeEffect () {
        return useViewportContainerSizeEffect;
    }
});
const _react = _interop_require_wildcard(require("react"));
const _use_isomorphic_layout_effect = require('../hydration/use_isomorphic_layout_effect');
const _stable_function = require('../stable_function/stable_function');
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const globalWindow = typeof window !== 'undefined' ? window : undefined;
let proxied = null;
const proxyVisualViewport = (visualViewport)=>{
    if (!globalWindow) return null;
    if (proxied) return proxied;
    let listeners = [];
    let hasBoundUnload = false;
    const bindUnload = ()=>{
        if (hasBoundUnload) return;
        hasBoundUnload = true;
        globalWindow.addEventListener('unload', ()=>{
            listeners.forEach((args)=>{
                visualViewport.removeEventListener(...args);
            });
            listeners = [];
        });
    };
    proxied = {
        addEventListener (name, fn, options) {
            const useCapture = options && (options === true || options.capture === true);
            listeners.push([
                name,
                fn,
                useCapture
            ]);
            bindUnload();
            return visualViewport.addEventListener(name, fn, options);
        },
        removeEventListener (name, fn, options) {
            const useCapture = options && (options === true || options.capture === true);
            listeners = listeners.filter(([listenerName, listenerFn, listenerUseCapture])=>{
                return !(listenerName === name && listenerFn === fn && listenerUseCapture === useCapture);
            });
            return visualViewport.removeEventListener(name, fn, options);
        },
        get offsetLeft () {
            return visualViewport.offsetLeft;
        },
        get offsetTop () {
            return visualViewport.offsetTop;
        },
        get pageLeft () {
            return visualViewport.pageLeft;
        },
        get pageTop () {
            return visualViewport.pageTop;
        },
        get width () {
            return visualViewport.width;
        },
        get height () {
            return visualViewport.height;
        },
        get scale () {
            return visualViewport.scale;
        }
    };
    return proxied;
};
const getVisualViewport = (targetWindow = globalWindow)=>{
    if (!targetWindow) return null;
    try {
        if (targetWindow.top && targetWindow.top.visualViewport) return proxyVisualViewport(targetWindow.top.visualViewport);
        return targetWindow.visualViewport;
    } catch (e) {
        return targetWindow.visualViewport;
    }
};
const getViewportContainerSize = (targetWindow = globalWindow)=>{
    if (!targetWindow) return null;
    const visualViewport = getVisualViewport(targetWindow);
    if (!visualViewport) return null;
    if (!targetWindow.frameElement) return {
        offsetLeft: visualViewport.offsetLeft,
        offsetTop: visualViewport.offsetTop,
        width: visualViewport.width,
        height: visualViewport.height
    };
    const iframeRect = targetWindow.frameElement.getBoundingClientRect();
    const viewportTop = visualViewport.offsetTop - iframeRect.top;
    const viewportLeft = visualViewport.offsetLeft - iframeRect.left;
    const viewportBottom = viewportTop + visualViewport.height;
    const viewportRight = viewportLeft + visualViewport.width;
    const iframeTop = 0;
    const iframeLeft = 0;
    const iframeBottom = iframeTop + iframeRect.height;
    const iframeRight = iframeLeft + iframeRect.width;
    const offsetTop = Math.max(viewportTop, iframeTop);
    const offsetLeft = Math.max(viewportLeft, iframeLeft);
    const offsetBottom = Math.min(viewportBottom, iframeBottom);
    const offsetRight = Math.min(viewportRight, iframeRight);
    return {
        offsetLeft,
        offsetTop,
        width: offsetRight - offsetLeft,
        height: offsetBottom - offsetTop
    };
};
function useViewportContainerSize() {
    const [containerSize, setContainerSize] = _react.useState(null);
    useViewportContainerSizeEffect(setContainerSize);
    return containerSize ?? null;
}
function useViewportContainerSizeEffect(callback) {
    const visualViewport = getVisualViewport();
    const stableCallback = (0, _stable_function.useStableFunction)(callback);
    const cleanup = _react.useRef(undefined);
    (0, _use_isomorphic_layout_effect.useIsomorphicLayoutEffect)(()=>{
        if (!visualViewport) return;
        function onVisualViewportChange() {
            cleanup.current?.();
            cleanup.current = stableCallback(getViewportContainerSize()) ?? undefined;
        }
        onVisualViewportChange();
        visualViewport.addEventListener('resize', onVisualViewportChange);
        visualViewport.addEventListener('scroll', onVisualViewportChange);
        return ()=>{
            visualViewport?.removeEventListener('resize', onVisualViewportChange);
            visualViewport?.removeEventListener('scroll', onVisualViewportChange);
            cleanup.current?.();
            cleanup.current = undefined;
        };
    }, [
        visualViewport,
        stableCallback
    ]);
}
