"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "BaseSlider", {
    enumerable: true,
    get: function() {
        return BaseSlider;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _classnames = _interop_require_default(require("classnames"));
const _react = _interop_require_wildcard(require("react"));
const _use_isomorphic_layout_effect = require('../../../hydration/use_isomorphic_layout_effect');
const _behavior = require('../../../surface/sheet/behavior/behavior');
const _bar_snap_behavior = require("./bar_snap_behavior");
const _base_slidercss = _interop_require_wildcard(require("./base_slider.css"));
const _slidercss = _interop_require_wildcard(require("./slider.css"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const clamp = ({ value, min, max })=>{
    return Math.min(Math.max(min, value), max);
};
const valueAsPercent = ({ value, min, max })=>{
    const range = max - min;
    const valueFromMin = clamp({
        value,
        min,
        max
    }) - min;
    const percent = valueFromMin / range * 100;
    return percent > 99.5 ? 100 : percent;
};
const BaseSlider = _react.memo(
    function BaseSlider({ id, min, max, step, snap, value, disabled, ariaLabel, ariaLabelledBy, ariaDescribedBy, ariaValueText, trackColor, track: trackProp, fill: fillProp, handle: handleProp, snapBehavior: snapBehaviorProp, blurOnDragEnd, onDragStart, onDragEnd, onChange, onChangeComplete, onBarResize, origin, fillColor }) {
        const [state, setState] = _react.useState({
            active: false,
            focused: false,
            handleHovering: false,
            trackHovering: false,
            leftBound: 0,
            width: 0
        });
        const inputRef = _react.useRef(null);
        const styledBarRef = _react.useRef(null);
        const snapBehavior = _react.useMemo(()=>snapBehaviorProp || new _bar_snap_behavior.NeverSnap(), [
            snapBehaviorProp
        ]);
        const isDraggingRef = _react.useRef(false);
        const dragStartValueRef = _react.useRef(clamp({
            value,
            min,
            max
        }));
        const keyPressedRef = _react.useRef(false);
        const onChangeCompleteRef = _react.useRef(onChangeComplete);
        const onDragEndRef = _react.useRef(onDragEnd);
        _react.useEffect(()=>{
            onChangeCompleteRef.current = onChangeComplete;
        }, [
            onChangeComplete
        ]);
        _react.useEffect(()=>{
            onDragEndRef.current = onDragEnd;
        }, [
            onDragEnd
        ]);
        _react.useEffect(()=>{
            return ()=>{
                if (isDraggingRef.current) onDragEndRef.current?.();
            };
        }, []);
        (0, _use_isomorphic_layout_effect.useIsomorphicLayoutEffect)(()=>{
            const measureWidth = ()=>{
                if (styledBarRef.current) {
                    const width = styledBarRef.current.offsetWidth;
                    const leftBound = styledBarRef.current.getBoundingClientRect().left;
                    setState((prev)=>({
                            ...prev,
                            width,
                            leftBound
                        }));
                    onBarResize?.({
                        width,
                        start: leftBound
                    });
                }
            };
            measureWidth();
            if (typeof ResizeObserver !== 'undefined' && styledBarRef.current) {
                const resizeObserver = new ResizeObserver(measureWidth);
                resizeObserver.observe(styledBarRef.current);
                return ()=>{
                    resizeObserver.disconnect();
                };
            }
        }, [
            onBarResize
        ]);
        const fillCalculations = _react.useMemo(()=>{
            const trackWidth = state.width;
            const startingPoint = origin != null ? clamp({
                value: origin,
                min,
                max
            }) : snap;
            const handleWidth = parseInt(_slidercss.default.handleDiameter, 10);
            const leftValue = startingPoint === undefined || startingPoint === min ? min : Math.min(startingPoint, value);
            const leftAsPercent = (leftValue - min) / (max - min) * 100;
            const startFill = leftAsPercent === 0 ? 0 : handleWidth / 2 + (trackWidth - handleWidth) * leftAsPercent / 100;
            const rightValue = startingPoint === max ? max : startingPoint === undefined ? value : Math.max(startingPoint, value);
            const rightAsPercent = (rightValue - min) / (max - min) * 100;
            const endFill = rightAsPercent === 100 ? trackWidth : handleWidth / 2 + (trackWidth - handleWidth) * rightAsPercent / 100;
            const color = fillColor !== undefined ? fillColor : trackColor !== undefined || value == null ? 'transparent' : undefined;
            return {
                startFill,
                endFill,
                color
            };
        }, [
            state.width,
            min,
            max,
            value,
            trackColor,
            origin,
            snap,
            fillColor
        ]);
        const handlePositionerPercent = _react.useMemo(()=>{
            const finalValue = value == null ? min + (max - min) / 2 : value;
            return valueAsPercent({
                value: finalValue,
                min,
                max
            });
        }, [
            value,
            min,
            max
        ]);
        const handlePositionerStyle = _react.useMemo(()=>{
            const startingPoint = origin != null ? clamp({
                value: origin,
                min,
                max
            }) : snap;
            const snapAsPercent = startingPoint != null ? (startingPoint - min) / (max - min) * 100 : undefined;
            if (snapAsPercent == null) return {
                width: `${handlePositionerPercent}%`
            };
            if (handlePositionerPercent >= snapAsPercent) return {
                width: `${handlePositionerPercent - snapAsPercent}%`,
                [_base_slidercss.customProperties.handlePositionerMargin]: `${snapAsPercent}%`
            };
            return {
                width: `${snapAsPercent - handlePositionerPercent}%`,
                [_base_slidercss.customProperties.handlePositionerMargin]: `${handlePositionerPercent}%`,
                transform: `scaleX(-1)`
            };
        }, [
            min,
            max,
            handlePositionerPercent,
            origin,
            snap
        ]);
        const track = _react.useCallback((props)=>trackProp != null ? trackProp(props) : defaultTrack({
                ...props,
                insetStart: handlePositionerPercent <= 0.5,
                insetEnd: handlePositionerPercent >= 99.5
            }), [
            trackProp,
            handlePositionerPercent
        ]);
        const fill = _react.useCallback((props)=>fillProp != null ? fillProp(props) : defaultFill({
                ...props,
                insetStart: handlePositionerPercent <= 0.5,
                insetEnd: handlePositionerPercent >= 99.5
            }), [
            fillProp,
            handlePositionerPercent
        ]);
        const handle = handleProp ?? defaultHandle;
        const handleDragStart = _react.useCallback((value)=>{
            dragStartValueRef.current = clamp({
                value,
                min,
                max
            });
            isDraggingRef.current = true;
            setState((prev)=>({
                    ...prev,
                    active: true
                }));
            onDragStart?.();
        }, [
            min,
            max,
            onDragStart
        ]);
        const handleDragEnd = _react.useCallback((newValue)=>{
            if (!isDraggingRef.current) return;
            isDraggingRef.current = false;
            setState((prev)=>({
                    ...prev,
                    active: false
                }));
            blurOnDragEnd && inputRef.current?.blur();
            newValue != null && onChangeCompleteRef.current?.(dragStartValueRef.current, newValue);
            onDragEndRef.current?.();
        }, [
            blurOnDragEnd
        ]);
        const handleMouseUp = _react.useCallback((event)=>{
            const target = event.target;
            const value = clamp({
                value: parseFloat(target.value),
                min,
                max
            });
            handleDragEnd(value);
        }, [
            min,
            max,
            handleDragEnd
        ]);
        const handleMouseDown = _react.useCallback((event)=>{
            const target = event.target;
            target.addEventListener('mouseup', handleMouseUp, {
                once: true
            });
            const value = clamp({
                value: parseFloat(target.value),
                min,
                max
            });
            handleDragStart(value);
        }, [
            min,
            max,
            handleDragStart,
            handleMouseUp
        ]);
        const handleTouchStart = _react.useCallback((event)=>{
            if (event.touches.length > 1) return;
            const target = event.target;
            const value = clamp({
                value: parseFloat(target.value),
                min,
                max
            });
            handleDragStart(value);
        }, [
            min,
            max,
            handleDragStart
        ]);
        const handleTouchEnd = _react.useCallback((event)=>{
            if (event.touches.length > 0) return;
            const target = event.target;
            const value = clamp({
                value: parseFloat(target.value),
                min,
                max
            });
            handleDragEnd(value);
        }, [
            min,
            max,
            handleDragEnd
        ]);
        const handleKeyDown = _react.useCallback(()=>{
            keyPressedRef.current = true;
            snapBehavior.onKeyDown();
        }, [
            snapBehavior
        ]);
        const handleKeyUp = _react.useCallback(()=>{
            keyPressedRef.current = false;
            snapBehavior.onKeyUp();
        }, [
            snapBehavior
        ]);
        const handleFocus = _react.useCallback(()=>{
            setState((prev)=>({
                    ...prev,
                    focused: true
                }));
        }, []);
        const handleBlur = _react.useCallback(()=>{
            setState((prev)=>({
                    ...prev,
                    focused: false
                }));
        }, []);
        const handleMouseEnter = _react.useCallback(()=>{
            setState((prev)=>({
                    ...prev,
                    trackHovering: true
                }));
        }, []);
        const handleMouseMove = _react.useCallback((e)=>{
            const handleWidth = parseInt(_slidercss.default.handleDiameter, 10);
            const trackWidth = state.width;
            const handleOverlayDiameter = parseInt(_slidercss.default.handleOverlayDiameter, 10);
            const mouseX = e.clientX - state.leftBound;
            const handleX = handleWidth / 2 + (trackWidth - handleWidth) * handlePositionerPercent / 100;
            if (mouseX >= handleX - handleOverlayDiameter / 2 && mouseX <= handleX + handleOverlayDiameter / 2) setState((prev)=>({
                    ...prev,
                    handleHovering: true
                }));
            else setState((prev)=>({
                    ...prev,
                    handleHovering: false
                }));
        }, [
            state.width,
            state.leftBound,
            handlePositionerPercent
        ]);
        const handleMouseLeave = _react.useCallback(()=>{
            setState((prev)=>({
                    ...prev,
                    trackHovering: false,
                    handleHovering: false
                }));
        }, []);
        const handleChange = _react.useCallback((event)=>{
            const newValue = clamp({
                value: parseFloat(event.target.value),
                min,
                max
            });
            const range = max - min;
            const pxPerUnit = state.width / range;
            snapBehavior.onChange({
                onChange,
                value
            }, newValue, pxPerUnit);
            if (keyPressedRef.current) onChangeComplete?.(value, newValue);
        }, [
            max,
            min,
            state.width,
            snapBehavior,
            value,
            onChange,
            onChangeComplete
        ]);
        const sheetScrollIsolationRef = (0, _behavior.useSheetScrollIsolation)();
        return (0, _jsxruntime.jsxs)("div", {
            className: _base_slidercss.default.root,
            ref: sheetScrollIsolationRef,
            children: [
                (0, _jsxruntime.jsxs)("div", {
                    className: _base_slidercss.default.styledBarRoot,
                    ref: styledBarRef,
                    children: [
                        track({
                            color: trackColor,
                            min,
                            max,
                            snap
                        }),
                        fill({
                            disabled,
                            trackWidth: state.width,
                            startFill: fillCalculations.startFill,
                            endFill: fillCalculations.endFill,
                            color: fillCalculations.color
                        }),
                        (0, _jsxruntime.jsx)("div", {
                            className: _base_slidercss.default.handlePositionerContainer,
                            children: (0, _jsxruntime.jsx)("div", {
                                className: _base_slidercss.default.handlePositioner,
                                style: handlePositionerStyle,
                                children: handle({
                                    ...state,
                                    disabled
                                })
                            })
                        })
                    ]
                }),
                (0, _jsxruntime.jsx)("input", {
                    id: id,
                    className: (0, _classnames.default)(_base_slidercss.default.hiddenSlider, {
                        [_base_slidercss.default.disabled]: disabled
                    }),
                    ref: inputRef,
                    type: "range",
                    onChange: handleChange,
                    onKeyDown: handleKeyDown,
                    onKeyUp: handleKeyUp,
                    onFocus: handleFocus,
                    onBlur: handleBlur,
                    onMouseEnter: handleMouseEnter,
                    onMouseMove: handleMouseMove,
                    onMouseLeave: handleMouseLeave,
                    onTouchStart: handleTouchStart,
                    onTouchEnd: handleTouchEnd,
                    onMouseDown: handleMouseDown,
                    min: min,
                    max: max,
                    step: step,
                    value: value,
                    disabled: disabled,
                    "aria-label": ariaLabel,
                    "aria-labelledby": ariaLabelledBy,
                    "aria-describedby": ariaDescribedBy,
                    "aria-valuetext": ariaValueText
                })
            ]
        });
    }
);
const defaultTrack = ({ min, max, snap, color, insetStart, insetEnd })=>{
    const snapIndicatorBufferWidth = snap != null && `calc(${(snap - min) / (max - min) * 100}% - 0.5 * ${_slidercss.default.snapIndicatorSize})`;
    return (0, _jsxruntime.jsxs)("div", {
        className: _slidercss.default.track,
        children: [
            (0, _jsxruntime.jsx)("div", {
                className: (0, _classnames.default)(_slidercss.default.trackFill, {
                    [_slidercss.default.insetStart]: insetStart,
                    [_slidercss.default.insetEnd]: insetEnd
                }),
                style: {
                    [_slidercss.customProperties.trackColor]: color
                }
            }),
            (0, _jsxruntime.jsx)("div", {
                className: (0, _classnames.default)(_slidercss.default.startStopIndicator, {
                    [_slidercss.default.insetStart]: insetStart
                })
            }),
            (0, _jsxruntime.jsx)("div", {
                className: (0, _classnames.default)(_slidercss.default.endStopIndicator, {
                    [_slidercss.default.insetEnd]: insetEnd
                })
            }),
            snapIndicatorBufferWidth && (0, _jsxruntime.jsxs)("div", {
                className: _slidercss.default.snapIndicatorContainer,
                children: [
                    (0, _jsxruntime.jsx)("div", {
                        className: _slidercss.default.snapIndicatorBuffer,
                        style: {
                            width: snapIndicatorBufferWidth
                        }
                    }),
                    (0, _jsxruntime.jsx)("div", {
                        className: _slidercss.default.snapIndicator
                    })
                ]
            })
        ]
    });
};
const defaultFill = ({ disabled, trackWidth, startFill, endFill, color, insetStart, insetEnd })=>{
    return (0, _jsxruntime.jsx)("div", {
        className: (0, _classnames.default)(_slidercss.default.fill, {
            [_slidercss.default.insetStart]: insetStart,
            [_slidercss.default.insetEnd]: insetEnd,
            [_slidercss.default.disabled]: disabled
        }),
        style: {
            [_slidercss.customProperties.fillColor]: color,
            [_slidercss.customProperties.fillStart]: `${startFill}px`,
            [_slidercss.customProperties.fillEnd]: `${trackWidth - endFill}px`
        }
    });
};
const defaultHandle = ({ handleHovering, trackHovering, focused, disabled })=>{
    return (0, _jsxruntime.jsx)("div", {
        className: (0, _classnames.default)(_slidercss.default.handle, {
            [_slidercss.default.focused]: !disabled && focused,
            [_slidercss.default.handleHovering]: !disabled && handleHovering,
            [_slidercss.default.trackHovering]: !disabled && trackHovering,
            [_slidercss.default.disabled]: disabled
        })
    });
};
