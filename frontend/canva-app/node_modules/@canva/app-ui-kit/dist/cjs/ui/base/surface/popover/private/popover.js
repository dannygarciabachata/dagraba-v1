"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "Popover", {
    enumerable: true,
    get: function() {
        return Popover;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _compose_refs = require('../../../../../base/react/compose_refs');
const _classnames = _interop_require_default(require("classnames"));
const _react = _interop_require_wildcard(require("react"));
const _reactmeasure = _interop_require_default(require("react-measure"));
const _reacttransitiongroup = require("react-transition-group");
const _metrics = require('../../../metrics/metrics');
const _provider = require('../../../provider/provider');
const _stable_function = require('../../../stable_function/stable_function');
const _backgroundcss = _interop_require_default(require('../../background/background.css'));
const _header = require('../../header/header');
const _content_container = require('../../internal/content_container');
const _trigger = require('../../internal/trigger');
const _pin = require('../../pin/pin');
const _arrow = require("./arrow");
const _popovercss = _interop_require_wildcard(require("./popover.css"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const WIDTH_CLASS = {
    ['16u']: _popovercss.default.width16U,
    ['32u']: _popovercss.default.width32U,
    ['40u']: _popovercss.default.width40U,
    ['45u']: _popovercss.default.width45U,
    ['52u']: _popovercss.default.width52U,
    ['trigger']: _popovercss.default.widthReference,
    ['auto']: _popovercss.default.widthAuto
};
function Popover({ id: idProp, open, onRequestClose, onCloseComplete, onScroll, blockOutsidePointerEvents = false, trigger, placement = 'auto', enableFlip, enableShift, width = 'auto', widthMode = 'fixed', offset = '1u', arrow = false, borderRadius = 'container', background = 'surface', shadow = 'surface', children, title, description, header, headerStart, headerEnd, headerAlignment, headerDivider = 'always', footer, ...contentContainerProps }) {
    const defaultId = _react.useId();
    const id = idProp || defaultId;
    const PinComponent = (0, _provider.useEnableAnimations)() ? TransitionPin : StaticPin;
    const contentContainerRef = _react.useRef(null);
    const contentContainerClassName = (0, _classnames.default)(_popovercss.default.contentContainer, WIDTH_CLASS[width], widthMode === 'maximum' && _popovercss.default.widthModeMaximum, borderRadius === 'container' && _popovercss.default.withBorderRadius, background === 'surface' && _popovercss.default.withBackground, background === 'surface' && _backgroundcss.default.elevationSurfaceFloatingBackground, shadow === 'surface' && _popovercss.default.withShadow);
    const onCalculateLayout = _react.useCallback((data)=>{
        const element = contentContainerRef.current;
        if (element == null) return;
        element.style.setProperty(_popovercss.customProperties.referenceWidth, `${Math.floor(data.reference.width)}px`);
        element.style.setProperty(_popovercss.customProperties.availableWidth, `${data.available.width}px`);
        element.style.setProperty(_popovercss.customProperties.availableHeight, `${data.available.height}px`);
    }, []);
    const pinRef = _react.useRef(null);
    const contentHeightRef = _react.useRef(0);
    const updatePinPosition = _react.useCallback(()=>{
        pinRef.current?.update();
    }, []);
    const onResize = _react.useCallback((contentRect)=>{
        const contentHeight = contentRect.client?.height ?? 0;
        if (contentHeightRef.current !== contentHeight) {
            contentHeightRef.current = contentHeight;
            updatePinPosition();
        }
    }, [
        updatePinPosition
    ]);
    const [isScrolled, setIsScrolled] = _react.useState(false);
    const scrollTopRef = _react.useRef(0);
    const handleScroll = _react.useCallback((e)=>{
        const scrollTop = e.target?.scrollTop ?? 0;
        onScroll?.({
            scrollTop
        });
        if (headerDivider !== 'when-scrolled') return;
        if (scrollTopRef.current === 0 && scrollTop > 0 || scrollTopRef.current > 0 && scrollTop === 0) {
            scrollTopRef.current = scrollTop;
            setIsScrolled(scrollTop > 0);
        }
    }, [
        onScroll,
        setIsScrolled,
        headerDivider
    ]);
    const showHeaderDivider = headerDivider === 'always' || headerDivider === 'when-scrolled' && isScrolled;
    const onOutsidePointerDown = _react.useCallback(({ target })=>{
        if (onRequestClose && target !== 'reference')
        onRequestClose();
    }, [
        onRequestClose
    ]);
    const resolvedTrigger = (0, _trigger.resolveTrigger)({
        trigger,
        open,
        id,
        role: contentContainerProps.role
    });
    const standardHeader = title != null ? (0, _jsxruntime.jsx)(_header.SurfaceHeader, {
        title: title,
        description: description,
        start: headerStart,
        end: headerEnd,
        alignment: headerAlignment,
        divider: false
    }) : undefined;
    return (0, _jsxruntime.jsx)(PinComponent, {
        ref: pinRef,
        placement: placement,
        enableFlip: enableFlip,
        enableShift: enableShift,
        offset: resolveOffset(offset),
        open: open,
        onOutsidePointerDown: onOutsidePointerDown,
        onCloseComplete: onCloseComplete,
        blockOutsidePointerEvents: blockOutsidePointerEvents,
        onCalculateLayout: onCalculateLayout,
        reference: resolvedTrigger,
        children: ({ setArrow })=>(0, _jsxruntime.jsx)(_reactmeasure.default, {
                onResize: onResize,
                client: true,
                children: ({ measureRef })=>(0, _jsxruntime.jsxs)(_content_container.ContentContainer, {
                        ref: (0, _compose_refs.composeRefs)(contentContainerRef, measureRef),
                        className: contentContainerClassName,
                        id: id,
                        onRequestEscape: onRequestClose,
                        onScroll: handleScroll,
                        ...contentContainerProps,
                        children: [
                            arrow ? (0, _jsxruntime.jsx)(_arrow.Arrow, {
                                ref: setArrow,
                                placement: placement
                            }) : null,
                            (standardHeader != null || header != null) && (0, _jsxruntime.jsxs)("div", {
                                className: (0, _classnames.default)(_popovercss.default.header, {
                                    [_popovercss.default.headerBorder]: showHeaderDivider
                                }),
                                children: [
                                    standardHeader,
                                    header
                                ]
                            }),
                            (0, _jsxruntime.jsx)("div", {
                                className: _popovercss.default.content,
                                children: children
                            }),
                            footer != null && (0, _jsxruntime.jsx)("div", {
                                className: _popovercss.default.footer,
                                children: footer
                            })
                        ]
                    })
            })
    });
}
const TRANSITION_DURATION = parseInt(_popovercss.default.transitionTime, 10);
const TRANSITION_CLASS_NAMES = {
    appear: _popovercss.default.visible,
    appearActive: _popovercss.default.visible,
    appearDone: _popovercss.default.visible,
    enter: _popovercss.default.visible,
    enterActive: _popovercss.default.visible,
    enterDone: _popovercss.default.visible,
    exit: _popovercss.default.hidden,
    exitActive: _popovercss.default.hidden,
    exitDone: _popovercss.default.hidden
};
function TransitionPin({ open, onCloseComplete, children, ref, ...props }) {
    const [transitionOpen, setTransitionOpen] = _react.useState(open);
    const wrapper = (children)=>
        (0, _jsxruntime.jsx)(SuspendableCssTransition, {
            classNames: TRANSITION_CLASS_NAMES,
            open: open,
            onEnter: ()=>setTransitionOpen(true),
            onExiting: ()=>setTransitionOpen(false),
            onExited: onCloseComplete,
            timeout: TRANSITION_DURATION,
            children: children
        });
    const wrappedChildren = typeof children === 'function' ? (options)=>wrapper(children(options)) : wrapper(children);
    return (0, _jsxruntime.jsx)(_pin.Pin, {
        ...props,
        ref: ref,
        open: open || transitionOpen,
        children: wrappedChildren
    });
}
function StaticPin({ open, onCloseComplete, children, ref, ...props }) {
    const prevOpen = _react.useRef(open);
    _react.useEffect(()=>{
        if (prevOpen.current && !open)
            onCloseComplete?.();
        prevOpen.current = open;
    }, [
        open,
        onCloseComplete
    ]);
    const wrappedChildren = typeof children === 'function' ? (options)=>(0, _jsxruntime.jsx)("div", {
            className: _popovercss.default.visible,
            children: children(options)
        }) : (0, _jsxruntime.jsx)("div", {
        className: _popovercss.default.visible,
        children: children
    });
    return (0, _jsxruntime.jsx)(_pin.Pin, {
        ...props,
        ref: ref,
        open: open,
        children: wrappedChildren
    });
}
function resolveOffset(offset) {
    if (typeof offset === 'object') return offset;
    return {
        main: offset === '0' ? 0 : parseUnitMultiplier(offset),
        cross: 0
    };
}
const parseUnitMultiplier = (value)=>parseFloat(value.slice(0, -1)) * _metrics.baseUnit;
function SuspendableCssTransition({ children, classNames, onEnter, onExited, onExiting, open, timeout }) {
    const stableOnExiting = (0, _stable_function.useStableFunction)(onExiting ?? (()=>{}));
    const stableOnExited = (0, _stable_function.useStableFunction)(onExited ?? (()=>{}));
    const nodeRef = _react.useRef(null);
    _react.useEffect(()=>{
        if (open)
            return;
        const timerId = setTimeout(stableOnExiting, timeout);
        return ()=>clearTimeout(timerId);
    }, [
        timeout,
        stableOnExiting,
        open
    ]);
    _react.useEffect(()=>stableOnExited, [
        stableOnExited
    ]);
    return (0, _jsxruntime.jsx)(_reacttransitiongroup.CSSTransition, {
        in: open,
        appear: true,
        timeout: timeout,
        classNames: classNames,
        onEnter: onEnter,
        nodeRef: nodeRef,
        children: (0, _jsxruntime.jsx)("div", {
            ref: nodeRef,
            children: children
        })
    });
}
