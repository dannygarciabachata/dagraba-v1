"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function _export(target, all) {
  for (var name in all) Object.defineProperty(target, name, {
    enumerable: true,
    get: Object.getOwnPropertyDescriptor(all, name).get
  });
}
_export(exports, {
  get BaseColorPicker() {
    return BaseColorPicker;
  },
  get ColorPicker() {
    return ColorPicker;
  }
});
const _jsxruntime = require("react/jsx-runtime");
const _react = _interop_require_wildcard(require("react"));
const _button = require('../../button/button');
const _alpha_slider = require('../alpha_slider/alpha_slider');
const _color_code_input = require('../color_code_input/color_code_input');
const _eye_dropper_button = require('../eye_dropper_button/eye_dropper_button');
const _hsv_color = require('../hsv_color/hsv_color');
const _hue_slider = require('../hue_slider/hue_slider');
const _color_picker_provider = require('../internal/color_picker_provider');
const _sat_val_picker = require('../sat_val_picker/sat_val_picker');
const _controllable_value = require('../../controllable_value/controllable_value');
const _icon = require('../../icons/trash/icon');
const _layout = require('../../layout/layout');
const _stable_function = require('../../stable_function/stable_function');
const _color_pickercss = _interop_require_default(require("./color_picker.css"));
const _color_pickermessages = require("./color_picker.messages");
function _interop_require_default(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {
    __proto__: null
  };
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
function ColorPicker({
  color,
  alpha,
  onChange,
  onChangeStart,
  onChangeComplete,
  onStartEyedropper,
  onEyedropperBackButton,
  onDeleteColor,
  body,
  header,
  footer,
  autoFocusHexInput,
  showHandlePreview = 'touch-only'
}) {
  const showAlpha = alpha != null;
  return (0, _jsxruntime.jsx)(BaseColorPicker, {
    color: color,
    alpha: alpha,
    onChange: onChange,
    onChangeStart: onChangeStart,
    onChangeComplete: onChangeComplete,
    children: (0, _jsxruntime.jsxs)(_layout.Rows, {
      spacing: "1.5u",
      children: [header, (0, _jsxruntime.jsx)(_sat_val_picker.SatValPicker, {
        showHandlePreview: showHandlePreview
      }), (0, _jsxruntime.jsx)(_hue_slider.HueSlider, {
        showHandlePreview: showHandlePreview
      }), showAlpha && (0, _jsxruntime.jsx)(_alpha_slider.AlphaSlider, {
        showHandlePreview: showHandlePreview
      }), body, (0, _jsxruntime.jsxs)(_layout.Columns, {
        alignY: "start",
        spacing: "1u",
        children: [onDeleteColor != null && (0, _jsxruntime.jsx)(_layout.Column, {
          width: "content",
          children: (0, _jsxruntime.jsx)(DeleteColorButton, {
            onDeleteColor: onDeleteColor
          })
        }), (0, _jsxruntime.jsx)(_layout.Column, {
          children: (0, _jsxruntime.jsx)(_color_code_input.ColorCodeInput, {
            showAlpha: showAlpha,
            autoFocus: autoFocusHexInput
          })
        }), onStartEyedropper != null && (0, _jsxruntime.jsx)(_layout.Column, {
          width: "content",
          children: (0, _jsxruntime.jsx)(_eye_dropper_button.EyeDropperButton, {
            onStart: onStartEyedropper,
            onBackButton: onEyedropperBackButton
          })
        })]
      }), footer]
    })
  });
}
function useControllableProps({
  color: colorProp,
  alpha: alphaProp,
  onChange
}) {
  const hasOnChange = onChange != null;
  const [hexColor, setHexColor] = (0, _controllable_value.useControllableValue)({
    value: hasOnChange ? colorProp : undefined,
    defaultValue: colorProp != null && !hasOnChange ? colorProp : '#000000'
  });
  const [alpha, setAlpha] = (0, _controllable_value.useControllableValue)({
    value: hasOnChange ? alphaProp : undefined,
    defaultValue: alphaProp != null && !hasOnChange ? alphaProp : 1
  });
  return {
    hexColor,
    alpha,
    setHexColor,
    setAlpha
  };
}
function useHsvColor({
  color: colorProp,
  alpha,
  onChange
}) {
  const hsvColorRef = _react.useRef(_hsv_color.HsvColor.fromHexString(colorProp, alpha));
  const [_, forceRender] = _react.useState({});
  const setColor = (0, _stable_function.useStableFunction)((hsvChannels, source) => {
    const newColor = hsvColorRef.current.with(hsvChannels);
    hsvColorRef.current = newColor;
    const newHexColor = newColor.toRgb().toHexString();
    onChange?.(newHexColor, source, newColor.alpha);
    if (newHexColor === colorProp)
      forceRender({});
  });
  const color = hsvColorRef.current.matchHexString(colorProp);
  if (!color.equals(hsvColorRef.current)) hsvColorRef.current = color;
  return {
    color,
    setColor
  };
}
function BaseColorPicker({
  color: colorProp,
  alpha: alphaProp,
  onChange: onChangeProp,
  onChangeStart,
  onChangeComplete,
  children
}) {
  const {
    hexColor,
    alpha,
    setHexColor,
    setAlpha
  } = useControllableProps({
    color: colorProp,
    alpha: alphaProp,
    onChange: onChangeProp
  });
  const onChange = (0, _stable_function.useStableFunction)((color, source, alpha) => {
    onChangeProp?.(color, source, alpha);
    setHexColor(color);
    setAlpha(alpha);
  });
  const {
    color,
    setColor
  } = useHsvColor({
    color: hexColor,
    alpha,
    onChange
  });
  return (0, _jsxruntime.jsx)(_color_picker_provider.ColorPickerControlsProvider, {
    setColor: setColor,
    onChangeStart: onChangeStart,
    onChangeComplete: onChangeComplete,
    children: (0, _jsxruntime.jsx)(_color_picker_provider.ColorPickerHueProvider, {
      hue: color.h,
      children: (0, _jsxruntime.jsx)(_color_picker_provider.ColorPickerSaturationProvider, {
        saturation: color.s,
        children: (0, _jsxruntime.jsx)(_color_picker_provider.ColorPickerValueProvider, {
          value: color.v,
          children: (0, _jsxruntime.jsx)(_color_picker_provider.ColorPickerAlphaProvider, {
            alpha: alpha,
            children: children
          })
        })
      })
    })
  });
}
const DeleteColorButton = ({
  onDeleteColor
}) => (0, _jsxruntime.jsx)(_button.Button, {
  variant: "tertiary",
  icon: _icon.TrashIcon,
  className: _color_pickercss.default.deleteColorButton,
  tooltipLabel: _color_pickermessages.ColorPickerMessages.deleteColorTooltip(),
  onClick: onDeleteColor
});