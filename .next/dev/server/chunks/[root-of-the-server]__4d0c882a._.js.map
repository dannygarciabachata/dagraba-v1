{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/odgmusic/development/Da%20Graba_Studio/lib/ai/sao-client.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient();\n\n// Note: These will need to be added to .env.local\nconst SPOTIFY_CLIENT_ID = process.env.SPOTIFY_CLIENT_ID;\nconst SPOTIFY_CLIENT_SECRET = process.env.SPOTIFY_CLIENT_SECRET;\nconst LASTFM_API_KEY = process.env.LASTFM_API_KEY;\nconst LASTFM_API_SECRET = process.env.LASTFM_API_SECRET;\n\nexport interface SAOTrainingConfig {\n    name: string;\n    description?: string;\n    tags: string[];\n    midiFolder: string;\n    vst3Plugins: string[];\n}\n\nexport class SAOClient {\n    /**\n     * Triggers a Modal job to start fine-tuning a Stable Audio Open model.\n     */\n    static async startTraining(config: SAOTrainingConfig) {\n        console.log(`Starting SAO Training for: ${config.name}`);\n\n        // This would call the Modal background function via their API or a runner\n        // For now, we simulate the job creation in the DB\n        const model = await prisma.instrumentModel.create({\n            data: {\n                name: config.name,\n                description: config.description,\n                tags: config.tags,\n                baseModel: \"stabilityai/stable-audio-open-1.0\",\n                // weightsUrl will be updated when training completes\n            }\n        });\n\n        return model;\n    }\n\n    /**\n     * Fetches a client credentials access token from Spotify.\n     */\n    private static async fetchSpotifyAccessToken() {\n        if (!SPOTIFY_CLIENT_ID || !SPOTIFY_CLIENT_SECRET) return null;\n\n        try {\n            const auth = Buffer.from(`${SPOTIFY_CLIENT_ID}:${SPOTIFY_CLIENT_SECRET}`).toString('base64');\n            const response = await fetch('https://accounts.spotify.com/api/token', {\n                method: 'POST',\n                headers: {\n                    'Authorization': `Basic ${auth}`,\n                    'Content-Type': 'application/x-www-form-urlencoded',\n                },\n                body: 'grant_type=client_credentials',\n            });\n\n            const data = await response.json();\n            return data.access_token;\n        } catch (error) {\n            console.error(\"Error fetching Spotify token:\", error);\n            return null;\n        }\n    }\n\n    /**\n     * Fetches metadata for a track from Spotify/Last.fm\n     */\n    static async fetchTrackMetadata(artist: string, track: string) {\n        const token = await this.fetchSpotifyAccessToken();\n\n        // Enrichment results\n        const result: any = {\n            artist,\n            track,\n            fetchedAt: new Date().toISOString(),\n            spotify: null,\n            lastfm: null\n        };\n\n        if (token) {\n            try {\n                const query = encodeURIComponent(`track:${track} artist:${artist}`);\n                const response = await fetch(`https://api.spotify.com/v1/search?q=${query}&type=track&limit=1`, {\n                    headers: { 'Authorization': `Bearer ${token}` }\n                });\n                const data = await response.json();\n\n                if (data.tracks?.items?.length > 0) {\n                    const item = data.tracks.items[0];\n                    result.spotify = {\n                        id: item.id,\n                        href: item.href,\n                        name: item.name,\n                        popularity: item.popularity,\n                        preview_url: item.preview_url,\n                        album: item.album.name,\n                        release_date: item.album.release_date\n                    };\n                }\n            } catch (error) {\n                console.error(\"Spotify search error:\", error);\n            }\n        }\n\n        // Last.fm enrichment for Tags, Genre, and Mood\n        if (LASTFM_API_KEY) {\n            try {\n                const query = encodeURIComponent(`track=${track}&artist=${artist}`);\n                const response = await fetch(`https://ws.audioscrobbler.com/2.0/?method=track.getInfo&api_key=${LASTFM_API_KEY}&artist=${encodeURIComponent(artist)}&track=${encodeURIComponent(track)}&format=json`);\n                const data = await response.json();\n\n                if (data.track) {\n                    const tags = data.track.toptags?.tag?.map((t: any) => t.name) || [];\n                    result.lastfm = {\n                        listeners: data.track.listeners,\n                        playcount: data.track.playcount,\n                        tags: tags.slice(0, 5), // Top 5 tags\n                        summary: data.track.wiki?.summary\n                    };\n\n                    // Auto-suggest tags based on Last.fm\n                    if (tags.length > 0) {\n                        result.suggestedTags = tags.slice(0, 3);\n                    }\n                }\n            } catch (error) {\n                console.error(\"Last.fm enrichment error:\", error);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Registers a new sample (audio + midi + metadata) in the database.\n     */\n    static async registerSample(data: {\n        name: string,\n        audioUrl: string,\n        midiUrl?: string,\n        prompt: string,\n        metadata?: any,\n        modelId: string\n    }) {\n        return await prisma.instrumentSample.create({\n            data: {\n                name: data.name,\n                audioUrl: data.audioUrl,\n                midiUrl: data.midiUrl,\n                prompt: data.prompt,\n                metadata: data.metadata,\n                instrumentModelId: data.modelId\n            }\n        });\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 177, "column": 0}, "map": {"version":3,"sources":["file:///Users/odgmusic/development/Da%20Graba_Studio/app/api/ai/train/sao/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport { SAOClient } from '@/lib/ai/sao-client';\n\nexport async function POST(req: Request) {\n    try {\n        const body = await req.json();\n        const { name, description, tags, midiFolder, vst3Plugins } = body;\n\n        if (!name) {\n            return NextResponse.json({ error: 'Model name is required' }, { status: 400 });\n        }\n\n        // 1. Initial metadata and model registration\n        const model = await SAOClient.startTraining({\n            name,\n            description,\n            tags: tags || [],\n            midiFolder: midiFolder || 'clean_midi',\n            vst3Plugins: vst3Plugins || []\n        });\n\n        // 2. Simulate or trigger the Modal job\n        // In a real production environment, this would hit a Modal webhook or use their SDK\n        console.log(`[SAO Training] Job queued for model: ${model.id}`);\n\n        return NextResponse.json({\n            message: 'Training job started successfully',\n            modelId: model.id,\n            status: 'QUEUED'\n        });\n    } catch (error: any) {\n        console.error('SAO Training Route Error:', error);\n        return NextResponse.json({ error: 'Internal server error' }, { status: 500 });\n    }\n}\n\nexport async function GET() {\n    try {\n        // Return available models from the database\n        // This would be used to populate the \"Available Instruments\" rack in the admin panel\n        return NextResponse.json({\n            instruments: [\n                { id: 'bolero-v1', name: 'Bolero Orchestra', tags: ['Bolero', 'Orchestra', 'Acoustic'] },\n                { id: 'trap-v1', name: 'Trap Base', tags: ['Trap', 'Bass', 'Electronic'] }\n            ]\n        });\n    } catch (error: any) {\n        return NextResponse.json({ error: 'Failed to fetch instruments' }, { status: 500 });\n    }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAEO,eAAe,KAAK,GAAY;IACnC,IAAI;QACA,MAAM,OAAO,MAAM,IAAI,IAAI;QAC3B,MAAM,EAAE,IAAI,EAAE,WAAW,EAAE,IAAI,EAAE,UAAU,EAAE,WAAW,EAAE,GAAG;QAE7D,IAAI,CAAC,MAAM;YACP,OAAO,mLAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAyB,GAAG;gBAAE,QAAQ;YAAI;QAChF;QAEA,6CAA6C;QAC7C,MAAM,QAAQ,MAAM,4KAAS,CAAC,aAAa,CAAC;YACxC;YACA;YACA,MAAM,QAAQ,EAAE;YAChB,YAAY,cAAc;YAC1B,aAAa,eAAe,EAAE;QAClC;QAEA,uCAAuC;QACvC,oFAAoF;QACpF,QAAQ,GAAG,CAAC,CAAC,qCAAqC,EAAE,MAAM,EAAE,EAAE;QAE9D,OAAO,mLAAY,CAAC,IAAI,CAAC;YACrB,SAAS;YACT,SAAS,MAAM,EAAE;YACjB,QAAQ;QACZ;IACJ,EAAE,OAAO,OAAY;QACjB,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,OAAO,mLAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAwB,GAAG;YAAE,QAAQ;QAAI;IAC/E;AACJ;AAEO,eAAe;IAClB,IAAI;QACA,4CAA4C;QAC5C,qFAAqF;QACrF,OAAO,mLAAY,CAAC,IAAI,CAAC;YACrB,aAAa;gBACT;oBAAE,IAAI;oBAAa,MAAM;oBAAoB,MAAM;wBAAC;wBAAU;wBAAa;qBAAW;gBAAC;gBACvF;oBAAE,IAAI;oBAAW,MAAM;oBAAa,MAAM;wBAAC;wBAAQ;wBAAQ;qBAAa;gBAAC;aAC5E;QACL;IACJ,EAAE,OAAO,OAAY;QACjB,OAAO,mLAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAA8B,GAAG;YAAE,QAAQ;QAAI;IACrF;AACJ"}}]
}